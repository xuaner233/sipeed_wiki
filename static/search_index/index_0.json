{"/hardware/zh/maixsense/maixsense-a075v/maixsense-a075v.html":{"title":"MaixSense-A075V","content":"# MaixSense A075V 时间 负责人 更新内容 : : : : : : 2022.08.10 lyx 初次编写文档 2022.11.15 lyx 补充细节 ## 产品概述 ![mt_big](asstes/../assets/mt_big.jpg) **MaixSense A075V** 是一款具有 **320x240** 分辨率及 **RGB** 功能的 **3D TOF** 摄像机模组， 支持 **Linux** 下免驱的即插即用，可通过上位机显示彩色 **3D** 画面并记录点云 ## 产品开箱指南 ### 准备工作 在 Windows 系统上运行预览 **MaixSense A075V** 的话需要安装驱动。 **Windows 安装驱动教程**：[点击查看](./install_drivers.html) ### 网页上位机预览 >**注意**：模组上电前一定要确保网络环境中没有使用 `192.168.233.0/24` 的地址段， >**MaixSense A075V** 会使用 **RNDIS** 并设置自己的 `iP` 地址为 `http://192.168.233.1`. ![tof 07514](asstes/../assets/mt_pin.jpg) 根据上图将模组通电接入 `PC` 端，这时自带的风扇会开始工作以及镜头处会显示有蓝灯在闪烁，选择浏览器输入 `http://192.168.233.1` 预览 3D 点云图，上电后有延迟等待 `10s 15s` 系统和程序才会启动完成。 **使用网页上位机快速预览（正面和侧面）：** <html> <img src \"./assets/mt_examle.jpg\" width 48%> <img src \"./assets/mt_examleb.jpg\" width 48%> </html> 可选预览深度伪彩点云，取消勾选页面右侧的交互面板上的第一行 `RGB_Map` 即可。 ![mt_examlec](assets/mt_examlec.jpg) ### 互动配置 网页上位机交互面板提供了一系列配置和功能，可以实时预览变动的效果。 ![mt_examled](assets/mt_examled.jpg) **交互面板控件说明** **RGB_Map**：多选框 开关 RGB 映射，即关闭时只显示深度伪彩点云，打开时显示 RGB 映射点云。 **colorMap**：下拉栏 提供了几个伪彩映射选项(即 cmap )，推荐使用 jet，RGB_Map 关闭时有效。 **deepRangeMax** 和 **deepRangeMin** 滑动条是设定 cmap 的映射范围的，即只有位于 deepRangeMin 和 deepRangeMax 之间的数值（深度值）会通过 cmap，RGB_Map 关闭时有效。 **NormalPoint**：多选框 开关显示正常点（TOF 成像会有无效点，对应的相反描述），需要打开。 **OE_Points**：多选框 开关显示 OE 点，建议关闭。 **UE_Points**：多选框 开关显示 UE 点，建议关闭。 **Bad_Points**：多选框 开关显示无效点，建议关闭。 **SpatialFilter**：多选框 开关空间滤波，基于下面的 SpatialFilterSize 值和 SpatialFilterType 指定的算法进行处理。 **TemporalFilter**：多选框 开关时间滤波，基于下面的 TemporalFilteralpha 值做了一个时间上的平均。 **TemporalFilteralpha**：滑动条 设定时间滤波所需时长，适中即可，可自行尝试体验其它效果。 **SpatialFilterType**：下拉栏 设定空间滤波算法，提供高斯滤波（Gaussian）和双边滤波（Bilateral），双边滤波性能要求较高，不建议使用。 **SpatialFilterSize**：滑动条 设定空间滤波所需范围，适中即可，可自行尝试体验其它效果。 **FlyingPointFilter**：多选框 开关飞点过滤，基于下面的 FlyingPointThreshold 值作为过滤阈值，超过阈值的将被过滤掉，建议适中配置，否则有效点也会被剔除。 ### 保存数据 网页版上位机控件栏最下方提供两个按钮，用户可根据以下的说明去使用。 **SaveRaw**：可保存一帧 raw 数据，如果需要使用深度或 IR 或 RGB 数据进行二次开发的话，则需要了解 raw 的数据结构。不过我们也提供详细的 `jupyter notebook` 供用户和开发者使用和了解 raw 数据的处理过程。 **SavePointCloud**：可保存一帧 3D 点云图，保存格式为 `pcd` ，同样可以通过上述提供的脚本预览。 >注意：**raw** 数据可通过开放的接口获取，开发者进行解析即可基于此二次开发，但点云 **pointcloud** 是基于 **raw** 数据和相机内参进行计算得到的，无相应接口提供。 ### SSH 登录 除了直接使用网页上位机进行预览，我们还可以使用 SSH 进行登录操作。 .. details::点此展开查看 MobaXterm 介绍 MobaXterm 是在 Windows 下使用的全能终端管理软件，而 Linux 系统可以使用 ssh 远程被操作，使用 MobaXterm 进行 ssh 登陆板子直接编辑板内的代码或执行命令，也能方便的拖拽文件上传或下载到电脑里，类似的工具还有 vscode remote 远程登录 linux 服务器。 ![mobaxterm_ssh](./../../maixIII/assets/ssh.jpg) **MobaXterm**：[点击前往下载](mobaxterm.mobatek.net/download) 分别有付费与免费双版本，下载免费版本即可。 **MobaXterm 使用例程**：[点击查看](https://wiki.sipeed.com/hardware/zh/maixII/M2/tools/mobaxterm.html?highlight ssh) 根据上面网页预览的画面可以知道所使用的 ip 为 `192.168.233.1`, 所以我们可以使用这个 ip 和登录密码 `root` 来登录到 TOF 模组的终端系统中。 Windows：参照上文例程使用模组自带的 `ip` 地址 `192.168.233.1` 进行登录。 Linux：使用登录密码 `root` 直接使用以下的命令行登录终端进行操作。 ```bash ssh root@192.168.233.1 ``` ### 固件更新 替换 `/root/maix_dist` 下对应的文件即可。 [点击下载更新文件](https://dl.sipeed.com/shareURL/MaixSense/MaixSense_A075V/03_Firmware) ## 案例：远中近点云实拍 高精度的映射物品摆放距离的差异，点云图可直观清楚感受到更真实的可视化。 ![mt_cloud](assets/mt_cloud.jpg) ## 案例：避障小车 模组可搭载小车或无人机来回移动获取障碍物的远近深度值，并通过差异判断画面中是否有障碍物，做出快速反应并精准规避障碍物。 ![me_car](./../assets/me_car.jpg) >例程暂未开源，待整理公开 ## 案例：检测人流 可实时监控人流，进行更高精度以及大分辨率的统计。 ![me_pt](./../assets/me_pt.jpg) >例程暂未开源，待整理公开。 ## 二次开发：SDK 支持 ### python SDK 这是基于 `python 3` 软件开发工具包，MaixSense A075V 对外开发了 `http` 接口，我们可通过 `http` 请求获取到原生数据（包括深度图，ir 图，rgb 图），为了方便用户理解数据包的结构及获取还有解码的相关逻辑，因此我们提供封装了 `http` 请求和原生数据的解码相关函数，用户基于此可进行二次开发。 **SDK 获取方式**：[点击下载](https://dl.sipeed.com/fileList/others/maixsense_example/maixsense_075_tutorial.ipynb) **使用方式**：安装 `jupyter` 后连接模组打开我们提供的 `toturial.py` 即可。 ### 解包推流 理解了上述 `python SDK` 数据获取和解码的逻辑后，我们可以尝试进阶版，连续获取解码并调用第三方 `python` 图像库。例如：`matplotlib` 进行实时显示，而 `toturial.py` 给出了获取一帧数据的逻辑实现，通过 `plt` 显示并外套循环即可做到实时显示。 **解包推流**：[点此展开查看 stream.py 内容](./../maixsense a010/code.html#streampy) **使用方式**：装好所有的依赖包后即可 `python stream.py` 运行。 ![mt_sdk](assets/mt_sdk.jpg) ### 检测体积 基于第三方 `python` 包，理解了上述数据获取和解码的逻辑后再次进阶， 持续显示多帧并且再通过 `SDK` 获取模组内参数计算出粗略的点云，并进行累加得到物品的总体积。 >限制：要求俯视图可以看到除底面外的所有细节 **检测体积**：[点此展开查看 calVolumes.py 内容](./../maixsense a010/code.html#calvolumespy) **使用方式**：装好所有的依赖包后即可 `python calVolumes.py` 运行，命令行有后续操作提示。 ![mt_volumbs](assets/mt_volumbs.jpg) ## 二次开发：接入 ROS > 首先需要根据自己电脑安装对应版本的 ROS ### 接入 ROS1 **1. 准备工作** 运行 ROS 前我们要准备适用的环境：`Linux` 系统。 可使用虚拟机 `virtual box` 或者 `vmware`：[点击前往下载](https://www.vmware.com/cn/products/workstation player/workstation player evaluation.html) 也可以自行安装双系统，安装方法请自行搜索或参考右侧：[双系统安装教程](https://neucrack.com/p/330) **2. 安装运行** ROS1 接入包：[点击前往下载](https://dl.sipeed.com/shareURL/MaixSense/MaixSense_A075V/software/SDK) ```bash #解压缩sipeed tofv075 ros.zip，并进入目录 source /opt/ros/*/setup.sh catkin_make source devel/setup.sh rosrun sipeed_tof_cpp publisher #之后终端会持续刷新命令行 ``` ![mt_adb](./assets/mt_adb.jpg) **3. 可自行在 RQT 查看帧率** ![mt_rqta](./assets/mt_rqta.jpg) **4. RVIZ 预览** 打开 `rviz2` 后，在界面左下角的 `Add` >`By topic` >`PointCloud2或/depth` >`Image 添加` >`Display/Global Options/Fixed Frame` 需要修改成 `tof` 才能正常显示点云，根据添加的内容左侧会显示 **Image** 而中间则显示点云。 ![mt_ros](assets/mt_ros.jpg) ### 接入 ROS2 **1. 准备工作** 运行 ROS 前我们要准备适用的环境：`Linux` 系统。 可使用虚拟机 `virtual box` 或者 `vmware`：[点击获取](https://www.vmware.com/cn/products/workstation player/workstation player evaluation.html) 也可以自行安装双系统，安装方法请自行搜索或参考右侧：[双系统安装教程](https://neucrack.com/p/330) **2. 安装运行** 我们提供了 ROS2 的接入功能包，用户需要在运行 ROS2 的系统上编译安装。 ROS2 接入包：[点击前往下载](https://dl.sipeed.com/shareURL/MaixSense/MaixSense_A075V/software/SDK) ``` bash #解压缩sipeed tofv075 ros2.zip，并进入目录 source /opt/ros/*/setup.sh colcon build #（如提示缺少colcon时需要sudo apt install python3 colcon ros） source install/setup.sh ros2 run sipeed_tof_cpp publisher #之后终端会持续刷新显示[sipeed_tof]: Publishing，即正常工作 ``` **3. RQT 查看帧率** 打开 `RQT` 后选择 `Plugins` >`Topics` >`Topic Monitor`。 ![mt_rqt](asstes/../assets/mt_rqt.jpg) **4. RVIZ2 预览** 打开 `rviz2` 后，在界面左下角的 `Add` >`By topic` >`PointCloud2` 或 `/depth、/intensity、/rgb` >`Image 添加` >`Display/Global Options/Fixed Frame` 需要修改成 `“tof”` 才能正常显示点云。根据添加的内容左侧会显示 **Image** 而中间则显示点云。 **伪彩点云和 RGBD 融合的点云效果：** <html> <img src \"./assets/mt_rosb.jpg\" width 48%> <img src \"./assets/mt_rosc.jpg\" width 48%> </html>"},"/hardware/zh/maixsense/maixsense-a075v/install_drivers.html":{"title":"安装 RNDIS 驱动","content":"# 安装 RNDIS 驱动 > 编辑于 2022年8月9日 ## 说明 RNDIS 全称为 Remote Network Driver Interface Specification，即远程网络驱动接口规范，是在 USB 设备上跑 TCP/IP 一种规范。 ## 相关操作 在 Windows7 及其以上的操作系统中，均已经内置了 RNDIS，但是如果不进行一些特殊操作的话，电脑一般是识别不到相关符合 RNDIS 设备的。 ### 下载驱动 <! **Windows 驱动**：[点击获取](https://dl.sipeed.com/shareURL/MaixSense/Drivers) > **Windows 驱动**：[点击获取](https://dl.sipeed.com/fileList/MaixSense/Drivers/Ethernet_RNDIS_drivers_20220808.zip) ### 安装驱动 将目标设备与电脑通过 USB 接口连接起来，且能够在电脑的设备管理器中看到串行设备。如果没有看到有串行设备的话大概率是供电不足所导致的：对于台式机建议使用主机背部的 USB 接口；使用 USB hub 的话建议使用带有额外供电的；另外建议使用 USB 3.0 的数据口，因为 USB 2.0 驱动供电可能不足。 ![串行设备](./assets/install_drivers/serial.png) 右键它，选择更新驱动程序，接着在下面的界面中选择更新驱动程序 ![更新驱动](./assets/install_drivers/update.png) 这里我们选择下面的 `让我从计算机上的可用驱动列表中选出(L)` ![选择驱动](./assets/install_drivers/scan.png) 接着对于下面的图我们选择偏右下方的 `从磁盘安装(H)...` ![从磁盘安装](./assets/install_drivers/install.png) 然后在下面的对话框中选择右下角的浏览 ![浏览](./assets/install_drivers/path.png) 选中我们所下载且解压之后的文件夹里面，选择一个 .inf 文件后，点击右下角的 `打开` ![inf](./assets/install_drivers/inf.png) 接着会回退到下面的界面，这里直接右下角的点击下一页即可 ![下一页](./assets/install_drivers/next.png) 然后就会显示已经更新驱动了 ![结束安装驱动](./assets/install_drivers/finish.png) 重新拔插 USB 设备后，等待大概十秒左右，可以在系统的设备管理器里网络适配器中看到看到有 `RNDIS/Ethernet Gadget`，到此已经成功安装驱动了"},"/hardware/zh/maixsense/maixsense-a010/code.html":{"title":"源码总览","content":"# 源码总览 [源码总览](#源码总览) [tof_mainpy](#tof_mainpy) [streampy](#streampy) [calvolumespy](#calvolumespy) ## tof_mainpy ```python from fpioa_manager import fm from machine import UART import lcd, image # lcd.init(invert True) lcd.init() img image.Image() fm.register(24, fm.fpioa.UART1_TX, force True) fm.register(25, fm.fpioa.UART1_RX, force True) uart_A UART(UART.UART1, 115200, 8, 0, 0, timeout 1000, read_buf_len 4096) def uart_readBytes(): return uart_A.read() def uart_hasData(): return uart_A.any() def uart_sendCmd(cmd): uart_A.write(cmd) uart_sendCmd(b\"AT+BAUD 5\\r\") uart_A.deinit() uart_A UART(UART.UART1, 921600, 8, 0, 0, timeout 1000, read_buf_len 4096) jetcolors [ (128, 0, 0), (132, 0, 0), (136, 0, 0), (140, 0, 0), (144, 0, 0), (148, 0, 0), (152, 0, 0), (156, 0, 0), (160, 0, 0), (164, 0, 0), (168, 0, 0), (172, 0, 0), (176, 0, 0), (180, 0, 0), (184, 0, 0), (188, 0, 0), (192, 0, 0), (196, 0, 0), (200, 0, 0), (204, 0, 0), (208, 0, 0), (212, 0, 0), (216, 0, 0), (220, 0, 0), (224, 0, 0), (228, 0, 0), (232, 0, 0), (236, 0, 0), (240, 0, 0), (244, 0, 0), (248, 0, 0), (252, 0, 0), (255, 0, 0), (255, 4, 0), (255, 8, 0), (255, 12, 0), (255, 16, 0), (255, 20, 0), (255, 24, 0), (255, 28, 0), (255, 32, 0), (255, 36, 0), (255, 40, 0), (255, 44, 0), (255, 48, 0), (255, 52, 0), (255, 56, 0), (255, 60, 0), (255, 64, 0), (255, 68, 0), (255, 72, 0), (255, 76, 0), (255, 80, 0), (255, 84, 0), (255, 88, 0), (255, 92, 0), (255, 96, 0), (255, 100, 0), (255, 104, 0), (255, 108, 0), (255, 112, 0), (255, 116, 0), (255, 120, 0), (255, 124, 0), (255, 128, 0), (255, 132, 0), (255, 136, 0), (255, 140, 0), (255, 144, 0), (255, 148, 0), (255, 152, 0), (255, 156, 0), (255, 160, 0), (255, 164, 0), (255, 168, 0), (255, 172, 0), (255, 176, 0), (255, 180, 0), (255, 184, 0), (255, 188, 0), (255, 192, 0), (255, 196, 0), (255, 200, 0), (255, 204, 0), (255, 208, 0), (255, 212, 0), (255, 216, 0), (255, 220, 0), (255, 224, 0), (255, 228, 0), (255, 232, 0), (255, 236, 0), (255, 240, 0), (255, 244, 0), (255, 248, 0), (255, 252, 0), (254, 255, 1), (250, 255, 6), (246, 255, 10), (242, 255, 14), (238, 255, 18), (234, 255, 22), (230, 255, 26), (226, 255, 30), (222, 255, 34), (218, 255, 38), (214, 255, 42), (210, 255, 46), (206, 255, 50), (202, 255, 54), (198, 255, 58), (194, 255, 62), (190, 255, 66), (186, 255, 70), (182, 255, 74), (178, 255, 78), (174, 255, 82), (170, 255, 86), (166, 255, 90), (162, 255, 94), (158, 255, 98), (154, 255, 102), (150, 255, 106), (146, 255, 110), (142, 255, 114), (138, 255, 118), (134, 255, 122), (130, 255, 126), (126, 255, 130), (122, 255, 134), (118, 255, 138), (114, 255, 142), (110, 255, 146), (106, 255, 150), (102, 255, 154), (98, 255, 158), (94, 255, 162), (90, 255, 166), (86, 255, 170), (82, 255, 174), (78, 255, 178), (74, 255, 182), (70, 255, 186), (66, 255, 190), (62, 255, 194), (58, 255, 198), (54, 255, 202), (50, 255, 206), (46, 255, 210), (42, 255, 214), (38, 255, 218), (34, 255, 222), (30, 255, 226), (26, 255, 230), (22, 255, 234), (18, 255, 238), (14, 255, 242), (10, 255, 246), (6, 255, 250), (2, 255, 254), (0, 252, 255), (0, 248, 255), (0, 244, 255), (0, 240, 255), (0, 236, 255), (0, 232, 255), (0, 228, 255), (0, 224, 255), (0, 220, 255), (0, 216, 255), (0, 212, 255), (0, 208, 255), (0, 204, 255), (0, 200, 255), (0, 196, 255), (0, 192, 255), (0, 188, 255), (0, 184, 255), (0, 180, 255), (0, 176, 255), (0, 172, 255), (0, 168, 255), (0, 164, 255), (0, 160, 255), (0, 156, 255), (0, 152, 255), (0, 148, 255), (0, 144, 255), (0, 140, 255), (0, 136, 255), (0, 132, 255), (0, 128, 255), (0, 124, 255), (0, 120, 255), (0, 116, 255), (0, 112, 255), (0, 108, 255), (0, 104, 255), (0, 100, 255), (0, 96, 255), (0, 92, 255), (0, 88, 255), (0, 84, 255), (0, 80, 255), (0, 76, 255), (0, 72, 255), (0, 68, 255), (0, 64, 255), (0, 60, 255), (0, 56, 255), (0, 52, 255), (0, 48, 255), (0, 44, 255), (0, 40, 255), (0, 36, 255), (0, 32, 255), (0, 28, 255), (0, 24, 255), (0, 20, 255), (0, 16, 255), (0, 12, 255), (0, 8, 255), (0, 4, 255), (0, 0, 255), (0, 0, 252), (0, 0, 248), (0, 0, 244), (0, 0, 240), (0, 0, 236), (0, 0, 232), (0, 0, 228), (0, 0, 224), (0, 0, 220), (0, 0, 216), (0, 0, 212), (0, 0, 208), (0, 0, 204), (0, 0, 200), (0, 0, 196), (0, 0, 192), (0, 0, 188), (0, 0, 184), (0, 0, 180), (0, 0, 176), (0, 0, 172), (0, 0, 168), (0, 0, 164), (0, 0, 160), (0, 0, 156), (0, 0, 152), (0, 0, 148), (0, 0, 144), (0, 0, 140), (0, 0, 136), (0, 0, 132), (0, 0, 128) ] def show(frameData, res): resR res[0] resC res[1] for y in range(resR): for x in range(resC): pixel_cmap_rgb jetcolors[frameData[y*resR + x]] img.set_pixel(110 + x, 70 + y, pixel_cmap_rgb) lcd.display(img) img.clear() FRAME_HEAD b\"\\x00\\xFF\" FRAME_TAIL b\"\\xCC\" from struct import unpack # send_cmd(\"AT+BINN 2\\r\") uart_sendCmd(b\"AT+DISP 5\\r\") uart_sendCmd(b\"AT+FPS 10\\r\") # while True: # if uart_hasData(): # print(uart_readBytes()) rawData b'' while True: if not uart_hasData(): continue rawData + uart_readBytes() idx rawData.find(FRAME_HEAD) if idx < 0: continue rawData rawData[idx:] # print(rawData) # check data length 2Byte dataLen unpack(\"H\", rawData[2: 4])[0] # print(\"len: \"+str(dataLen)) frameLen len(FRAME_HEAD) + 2 + dataLen + 2 frameDataLen dataLen 16 if len(rawData) < frameLen: continue # get data frame rawData[:frameLen] # print(frame.hex()) rawData rawData[frameLen:] frameTail frame[ 1] # print(\"tail: \"+str(hex(frameTail))) _sum frame[ 2] # print(\"checksum: \"+str(hex(_sum))) # check sum # spi has no checksum but i add one if frameTail ! 0xdd and _sum ! sum(frame[:frameLen 2]) % 256: continue frameID unpack(\"H\", frame[16:18])[0] # print(\"frame ID: \"+str(frameID)) resR unpack(\"B\", frame[14:15])[0] resC unpack(\"B\", frame[15:16])[0] res (resR, resC) # print(res) # frameData [ unpack(\"H\", frame[20+i:22+i])[0] for i in range(0, frameDataLen, 2) ] frameData [unpack(\"B\", frame[20+i:21+i])[0] for i in range(0, frameDataLen, 1)] show(frameData, res) del frameData ``` ## streampy ```python from PIL import Image import requests import matplotlib.pyplot as plt import struct import numpy as np import cv2 def frame_config_decode(frame_config): ''' @frame_config bytes @return fields, tuple (trigger_mode, deep_mode, deep_shift, ir_mode, status_mode, status_mask, rgb_mode, rgb_res, expose_time) ''' return struct.unpack(\"<BBBBBBBBi\", frame_config) def frame_config_encode(trigger_mode 1, deep_mode 1, deep_shift 255, ir_mode 1, status_mode 2, status_mask 7, rgb_mode 1, rgb_res 0, expose_time 0): return struct.pack(\"<BBBBBBBBi\", trigger_mode, deep_mode, deep_shift, ir_mode, status_mode, status_mask, rgb_mode, rgb_res, expose_time) def frame_payload_decode(frame_data: bytes, with_config: tuple): deep_data_size, rgb_data_size struct.unpack(\"<ii\", frame_data[:8]) frame_payload frame_data[8:] # 0:16bit 1:8bit, resolution: 320*240 deepth_size (320*240*2) >> with_config[1] deepth_img struct.unpack(\"<%us\" % deepth_size, frame_payload[:deepth_size])[ 0] if 0 ! deepth_size else None frame_payload frame_payload[deepth_size:] # 0:16bit 1:8bit, resolution: 320*240 ir_size (320*240*2) >> with_config[3] ir_img struct.unpack(\"<%us\" % ir_size, frame_payload[:ir_size])[ 0] if 0 ! ir_size else None frame_payload frame_payload[ir_size:] status_size (320*240//8) * (16 if 0 with_config[4] else 2 if 1 with_config[4] else 8 if 2 with_config[4] else 1) status_img struct.unpack(\"<%us\" % status_size, frame_payload[:status_size])[ 0] if 0 ! status_size else None frame_payload frame_payload[status_size:] assert(deep_data_size deepth_size+ir_size+status_size) rgb_size len(frame_payload) assert(rgb_data_size rgb_size) rgb_img struct.unpack(\"<%us\" % rgb_size, frame_payload[:rgb_size])[ 0] if 0 ! rgb_size else None if (not rgb_img is None) and (1 with_config[6]): jpeg cv2.imdecode(np.frombuffer( rgb_img, 'uint8', rgb_size), cv2.IMREAD_COLOR) if not jpeg is None: rgb cv2.cvtColor(jpeg, cv2.COLOR_BGR2RGB) rgb_img rgb.tobytes() else: rgb_img None return (deepth_img, ir_img, status_img, rgb_img) HOST '192.168.233.1' PORT 80 def post_encode_config(config frame_config_encode(), host HOST, port PORT): r requests.post('http://{}:{}/set_cfg'.format(host, port), config) if(r.status_code requests.codes.ok): return True return False def get_frame_from_http(host HOST, port PORT): r requests.get('http://{}:{}/getdeep'.format(host, port)) if(r.status_code requests.codes.ok): # print('Get deep image') deepimg r.content # print('Length {}'.format(len(deepimg))) (frameid, stamp_msec) struct.unpack('<QQ', deepimg[0:8+8]) # print((frameid, stamp_msec/1000)) return deepimg def show_frame(fig, frame_data: bytes): config frame_config_decode(frame_data[16:16+12]) frame_bytes frame_payload_decode(frame_data[16+12:], config) depth np.frombuffer(frame_bytes[0], 'uint16' if 0 config[1] else 'uint8').reshape( 240, 320) if frame_bytes[0] else None ir np.frombuffer(frame_bytes[1], 'uint16' if 0 config[3] else 'uint8').reshape( 240, 320) if frame_bytes[1] else None status np.frombuffer(frame_bytes[2], 'uint16' if 0 config[4] else 'uint8').reshape( 240, 320) if frame_bytes[2] else None rgb np.frombuffer(frame_bytes[3], 'uint8').reshape( (480, 640, 3)) if frame_bytes[3] else None ax1 fig.add_subplot(221) if not depth is None: # center_dis depth[240//2, 320//2] # if 0 config[1]: # print(\"%f mm\" % (center_dis/4)) # else: # print(\"%f mm\" % ((center_dis/5.1) ** 2)) # depth depth.copy() # l,r 200,5000 # depth_f ((depth.astype('float64') l) * (65535 / (r l))) # depth_f[np.where(depth_f < 0)] 0 # depth_f[np.where(depth_f > 65535)] 65535 # depth depth_f.astype(depth.dtype) # depth[240//2, 320//2 5:320//2+5] 0x00 # depth[240//2 5:240//2+5, 320//2] 0x00 ax1.imshow(depth, cmap 'jet_r') ax2 fig.add_subplot(222) if not ir is None: ax2.imshow(ir, cmap 'gray') ax3 fig.add_subplot(223) if not status is None: ax3.imshow(status) ax4 fig.add_subplot(224) if not rgb is None: ax4.imshow(rgb) if post_encode_config(frame_config_encode(1, 1, 255, 0, 2, 7, 1, 0, 0)): # 打开交互模式 plt.ion() figsize (12, 12) fig plt.figure('2D frame', figsize figsize) while True: p get_frame_from_http() show_frame(fig, p) # 停顿时间 plt.pause(0.001) # 清除当前画布 fig.clf() plt.ioff() ``` ## calvolumespy ```python from PIL import Image, ImageDraw import requests import matplotlib.pyplot as plt import struct import numpy as np import cv2 HOST '192.168.233.1' PORT 80 def depth2xyz(xp, yp, z, fx, fy, cx, cy, depth_scale 1000): # h,w np.mgrid[0:depth_map.shape[0],0:depth_map.shape[1]] z z/depth_scale x (xp cx)*z/fx y (yp cy)*z/fy # xyz np.dstack((x,y,z)) # xyz cv2.rgbd.depthTo3d(depth_map,depth_cam_matrix) return [x, y, z] def polygon_area(polygon): area 0 q polygon[ 1] for p in polygon: area + p[0] * q[1] p[1] * q[0] q p return abs(area) / 2.0 def get_lenscoeff(host HOST, port PORT): r requests.get('http://{}:{}/getinfo'.format(host, port)) if(r.status_code requests.codes.ok): lenscoeff_bin r.content (_fx,_fy,_cx,_cy) struct.unpack('<ffff', lenscoeff_bin[41:41+4*4]) # print((frameid, stamp_msec/1000)) return (_fx,_fy,_cx,_cy) diff_low 30 diff_high 500 fx 2.265142e+02 fy 2.278584e+02 cx 1.637246e+02 # cx cy 1.233738e+02 # cy (fx,fy,cx,cy) get_lenscoeff() def cal_volume(d_bk, d_bg): img_h, img_w d_bk.shape[0], d_bk.shape[1] d_bk d_bk.astype(np.float32) # cvt to mm d_bg d_bg.astype(np.float32) diff (d_bg d_bk).astype(np.int16) diff1 diff.copy() diff1 np.where(diff1 < diff_low, 0, diff1) diff1 np.where(diff1 > diff_high, 0, diff1) diff1 (np.where(diff1 > 0, 1, 0)*255).astype(np.uint8) # plt.imshow(diff1) # print(d_bk.shape) (240, 320) output np.zeros((img_h, img_w, 3), np.uint8) num_labels, labels, stats, centroids cv2.connectedComponentsWithStats( diff1, connectivity 8) # print('num_labels ',num_labels) # 连通域的信息：对应各个轮廓的x、y、width、height和面积 # print('stats ',stats) res list() max_stats list() for i in range(5): max_label 1+np.argmax(stats[1:, 4]) # print('stats[max_label] ', stats[max_label]) if i > 0 and stats[max_label][4] < 700: break max_stat stats[max_label] max_stats.append(max_stat) stats[max_label][4] 0 mask (labels max_label) # (np.random.rand(3)*255).astype(np.uint8) output[:, :, :][mask] [200, 0, 0] # plt.imshow(output) # kernel cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3)) # eroded cv2.erode(output, kernel) # dilated cv2.dilate(output, kernel) kernel cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5)) # output dilated output cv2.morphologyEx(output, cv2.MORPH_OPEN, kernel) output cv2.morphologyEx(output, cv2.MORPH_CLOSE, kernel) volumes [] # points [] # areas [] for yp in range(img_h): for xp in range(img_w): if mask[yp, xp]: x1, y1, z1 depth2xyz( xp, yp, d_bk[yp, xp], fx, fy, cx, cy, depth_scale 1) x0, y0, z0 depth2xyz( xp, yp, d_bg[yp, xp], fx, fy, cx, cy, depth_scale 1) x xp 1 if x < 0: x 0 y yp xl, yl, zl depth2xyz( x, y, d_bk[y, x], fx, fy, cx, cy, depth_scale 1) x xp+1 if x > img_w: x img_w 1 y yp xr, yr, zr depth2xyz( x, y, d_bk[y, x], fx, fy, cx, cy, depth_scale 1) x xp y yp 1 if y < 0: y 0 xt, yt, zt depth2xyz( x, y, d_bk[y, x], fx, fy, cx, cy, depth_scale 1) x xp y yp+1 if y > img_h: y img_h 1 xb, yb, zb depth2xyz( x, y, d_bk[y, x], fx, fy, cx, cy, depth_scale 1) area_a polygon_area( [[xt, yt], [xl, yl], [xb, yb], [xr, yr]])/2 dz z0 z1 dx z1/fx dy z1/fy area_b dx*dy*2/2 area (area_a+area_b)/2 # avg get better acc volume area*dz # areas.append(area) volumes.append(volume) # points.append((x1, y1, dz)) # areas np.array(areas) volumes np.array(volumes) # points np.array(points) res.append(\"{}:{} cm3\".format(i, int(np.sum(volumes)/1000))) # print(res) img_pil Image.fromarray(output) draw ImageDraw.Draw(img_pil) for i in range(len(max_stats)): max_stat max_stats[i] draw.rectangle([(max_stat[0], max_stat[1]), (max_stat[0] + max_stat[2], max_stat[1] + max_stat[3])], outline \"red\") draw.text((max_stat[0], max_stat[1]), res[i], fill (255, 255, 255)) output np.array(img_pil) return output def frame_config_decode(frame_config): ''' @frame_config bytes @return fields, tuple (trigger_mode, deep_mode, deep_shift, ir_mode, status_mode, status_mask, rgb_mode, rgb_res, expose_time) ''' return struct.unpack(\"<BBBBBBBBi\", frame_config) def frame_config_encode(trigger_mode 1, deep_mode 1, deep_shift 255, ir_mode 1, status_mode 2, status_mask 7, rgb_mode 1, rgb_res 0, expose_time 0): return struct.pack(\"<BBBBBBBBi\", trigger_mode, deep_mode, deep_shift, ir_mode, status_mode, status_mask, rgb_mode, rgb_res, expose_time) def frame_payload_decode(frame_data: bytes, with_config: tuple): deep_data_size, rgb_data_size struct.unpack(\"<ii\", frame_data[:8]) frame_payload frame_data[8:] # 0:16bit 1:8bit, resolution: 320*240 deepth_size (320*240*2) >> with_config[1] deepth_img struct.unpack(\"<%us\" % deepth_size, frame_payload[:deepth_size])[ 0] if 0 ! deepth_size else None frame_payload frame_payload[deepth_size:] # 0:16bit 1:8bit, resolution: 320*240 ir_size (320*240*2) >> with_config[3] ir_img struct.unpack(\"<%us\" % ir_size, frame_payload[:ir_size])[ 0] if 0 ! ir_size else None frame_payload frame_payload[ir_size:] status_size (320*240//8) * (16 if 0 with_config[4] else 2 if 1 with_config[4] else 8 if 2 with_config[4] else 1) status_img struct.unpack(\"<%us\" % status_size, frame_payload[:status_size])[ 0] if 0 ! status_size else None frame_payload frame_payload[status_size:] assert(deep_data_size deepth_size+ir_size+status_size) rgb_size len(frame_payload) assert(rgb_data_size rgb_size) rgb_img struct.unpack(\"<%us\" % rgb_size, frame_payload[:rgb_size])[ 0] if 0 ! rgb_size else None if (not rgb_img is None) and (1 with_config[6]): jpeg cv2.imdecode(np.frombuffer( rgb_img, 'uint8', rgb_size), cv2.IMREAD_COLOR) if not jpeg is None: rgb cv2.cvtColor(jpeg, cv2.COLOR_BGR2RGB) rgb_img rgb.tobytes() else: rgb_img None return (deepth_img, ir_img, status_img, rgb_img) def post_encode_config(config frame_config_encode(), host HOST, port PORT): r requests.post('http://{}:{}/set_cfg'.format(host, port), config) if(r.status_code requests.codes.ok): return True return False def get_frame_from_http(host HOST, port PORT): r requests.get('http://{}:{}/getdeep'.format(host, port)) if(r.status_code requests.codes.ok): # print('Get deep image') deepimg r.content # print('Length {}'.format(len(deepimg))) (frameid, stamp_msec) struct.unpack('<QQ', deepimg[0:8+8]) # print((frameid, stamp_msec/1000)) return deepimg def show_frame(fig, frame_data: bytes): config frame_config_decode(frame_data[16:16+12]) frame_bytes frame_payload_decode(frame_data[16+12:], config) depth np.frombuffer(frame_bytes[0], 'uint16' if 0 config[1] else 'uint8').reshape( 240, 320) if frame_bytes[0] else None # ir np.frombuffer(frame_bytes[1], 'uint16' if 0 config[3] else 'uint8').reshape( # 240, 320) if frame_bytes[1] else None # status np.frombuffer(frame_bytes[2], 'uint16' if 0 config[4] else 'uint8').reshape( # 240, 320) if frame_bytes[2] else None rgb np.frombuffer(frame_bytes[3], 'uint8').reshape( (480, 640, 3)) if frame_bytes[3] else None ax1 fig.add_subplot(122) if not depth is None: # center_dis depth[240//2, 320//2] # if 0 config[1]: # print(\"%f mm\" % (center_dis/4)) # else: # print(\"%f mm\" % ((center_dis/5.1) ** 2)) # depth depth.copy() # l,r 200,5000 # depth_f ((depth.astype('float64') l) * (65535 / (r l))) # depth_f[np.where(depth_f < 0)] 0 # depth_f[np.where(depth_f > 65535)] 65535 # depth depth_f.astype(depth.dtype) # depth[240//2, 320//2 5:320//2+5] 0x00 # depth[240//2 5:240//2+5, 320//2] 0x00 if not UPDATE_BG[1] is None: ax1.imshow(cal_volume(depth, UPDATE_BG[1])) else: ax1.imshow(depth) if UPDATE_BG[0]: UPDATE_BG[1] depth # ax2 fig.add_subplot(222) # if not ir is None: # ax2.imshow(ir, cmap 'gray') # ax3 fig.add_subplot(223) # if not status is None: # ax3.imshow(status) ax4 fig.add_subplot(121) if not rgb is None: ax4.imshow(rgb) UPDATE_BG [False, None] if post_encode_config(frame_config_encode(1, 0, 255, 0, 2, 7, 1, 0, 0)): # 打开交互模式 def on_key_press(event): if event.key ' ': UPDATE_BG[0] True elif event.key 'c': UPDATE_BG[1] None plt.ion() figsize (12, 12) fig plt.figure('2D frame', figsize figsize) fig.canvas.mpl_connect('key_press_event', on_key_press) print(\"按下空格键更新背景图，按下c键清空背景图\") while True: p get_frame_from_http() show_frame(fig, p) if UPDATE_BG[0]: UPDATE_BG[0] False print(\"update bg success!\") # 停顿时间 plt.pause(0.001) # 清除当前画布 fig.clf() plt.ioff() ```"},"/hardware/zh/maixsense/maixsense-a010/maixsense-a010.html":{"title":"MaixSense-A010","content":"# MaixSense A010 时间 负责人 更新内容 : : : : : : 2022.09.10 lyx 初次编写文档 2022.11.12 lyx 补充细节 ## 产品概述 ![ms_small](./assets/ms_s.jpg) **MaixSense A010** 是 **SIPEED** 推出由 **BL702** + 炬佑 **100x100 TOF** 所组成的 **3D** 传感器模组，最大支持 **100x100** 的分辨率和 **8** 位精度并自带 **240×135** 像素的 **LCD** 屏可实时预览 **colormap** 后的深度图。 ### 资料汇总 硬件资料：[点击查看下载](https://dl.sipeed.com/shareURL/MaixSense/MaixSense_A010) Github：[点击查看](https://github.com/sipeed/MaixSense_ROS) ## 产品开箱指南 ### 准备工作 **MaixSense A010** 采用串口协议对外提供接口以及传输数据。 我们提供的物理接口有 type c（虚拟串口）及 1.0mm 4pin 母座（UART）都能获取深度图数据用于集成. **产品接线说明** 通过 type c 接口连接 PC 端后，可以识别到 `/dev/ttyUSBx（Linux）`或 `COMx（Windows)`. ![ms_pinb](./assets/ms_pinb.jpg) 还可通过 usb2ttl 模组按照硬件引脚图（设备屏幕正面朝下）连接 4pin 母座。 <html> <img src \"./assets/ms_pin.jpg\" width 48%> <img src \"./asstes/../assets/ms_pinc.jpg\" width 48%> </html> <table> <tr> <td>MS A010</td> <td>TX</td> <td>RX</td> <td>GND</td> <td>5V</td> </tr> <tr> <td>usb2ttl 模块</td> <td>RX</td> <td>TX</td> <td>GND</td> <td>5V</td> </tr> </table> ### 上电互动预览 **按键功能**：左侧为“下一个”右侧为“切换”. **屏幕显示**：屏幕中心的 **+** 字是测距点，右上方会实时显示 **xx cm** 代表测距的距离。如镜头前近处有大面积物体时屏幕右上会显示 **“block!”**而其他情况为 **“open!”**. 将设备接入电源后，可在设备上自带 LCD 屏实时预览 color map 后的深度伪彩图。 ![ms_lcd](./assets/ms_lcd.jpg) ### PC 互动预览 在 PC 端上预览修改配置前需要先安装上位机软件 COMTOOL. **COMTOOL/Windows 系统**：[点击下载](https://dl.sipeed.com/shareURL/MaixSense/MaixSense_A010/software_pack/comtool) **COMTOOL/Linux 系统**：[需用户自行编译/点击跳转](https://github.com/sipeed/MetaSense ComTool) >注意：Win 7 及以下系统需装驱动，可自行前往 FTDI 官网下载。 打开 COMTOOL 软件后选择 `Graph` 界面，如果软件上方无 `Graph` 的话可在右上角 **+** 号处添加 `Graph`，创建后若居中部分为白无图，则**双击**左下角 `MaixSenseLite` 即可打开界面显示端口。 ![ms_comtool](./assets/ms_comtool.jpg) 在左侧 `Port` 选择小的端口和对应波特率（任意选择高波特率），点击 `open` 后再勾选下方 `USB` 即可接收大量数据,左下角处会显示 **Connected**. ![ms_comtool_two](./assets/ms_comtoolt.jpg) 设定 `Header` 为 `\\x00\\xFF` 即可解析正确的图像数据并观察到深度图，可以直观感受二维平面图像上的深度。 ![ms_comtoolh](./assets/ms_comtoolh.jpg) ### 互动配置说明 COMTOOL 上位机的配置控件说明 **Header**：设置识别包头 **RawCMD**：用户可以手动发送指令（USB 和 UART 串口行为相同） **ISP**：启动停止 **LCD**：显示自带屏的开启关闭 **USB**：串口传输深度图开启关闭 **UART**：串口传输深度图开启关闭 **ANTIMMI**：自动抗多机干扰开启关闭（易受干扰，关闭的效果都要更好些） **Binn**：可下拉设置 BINNING，Baud 设置 UART 波特率 **X、Y**：设置坐标：D 左侧多选框开启后显示出该摄像头的距离。 **Unit**：设置量化单位（16位量化到8位，比例缩小，设置太小的话会只能看清很近处的影像） **FPS**：设置出图帧率（不宜过高，根据对接设备的性能合理设置即可，减小帧率可以减少传输数据量） **Ev**：曝光间隙控制（最左代表 AE，其他是固定曝光时间） ## 案例：远近中物体实拍 设备自带 **LCD** 屏上电后可实时观察到远近中物体的深度值差异。 物体不同的放置位置形成距离的差异，设备捕捉到差异后转化为深度值并因距离的远近显示冷暖色调。 ![ms_](./assets/ms_carton.jpg) ## 案例：检测人流 实时高精度，大分辨率的监测人流量走动的情况并且快速统计出数据。 ![ms_people](./assets/ms people.jpg) >例程源码暂时还未开源，待整理公开。 ## 案例：键盘灯跟随 实现超酷炫的键盘灯跟随，设备实时跟踪手部的位置变化，再根据手部的位置映射键盘灯。 **键盘灯相关代码支持**：[点击查看](https://dl.sipeed.com/shareURL/others/maixsense_example) ![ma_lamp](./assets/ms_lamp.jpg) ## 案例：接入 MCU 因 **MaixSense A010** 拥有强大的兼容性，可基于串口协议外接 **K210 Maix bit** 这样的 **AIOT** 开发板或树莓派之类的 **Linux** 开发板来进行二次开发，为了方便用户的使用我们开放接入例程。 .. details::点击查看 K210 Maix Bit 介绍 Maix Bit 是 sipeed Maix 中产品线的一员，基于嘉楠堪智科技的边缘智能计算芯片 K210 设计的一款 AIOT 开发板。以 K210 作为核心单元，功能非常很强大，芯片内置 64 位双核处理器，拥有 8M 的片上 SRAM，在Al机器视觉、听觉性能方便表现突出，内置多种硬件加速单元(KPU、FPU，FFT等)，总算力最高可达 1TOPS，可以方便地实现各类应用场景的机器视觉/听觉算法,也可以进行语音方向扫描和语音数据输出的前置处理工作。 ![bit](./../../../../soft/maixduino/assets/BiT.png) **Maix Bit 购买传送门**：[点击查看](https://item.taobao.com/item.htm?spm a230r.1.14.11.681570a1yq4sJD&id 586580351110&ns 1&abbucket 10&mt ) **Maix Bit 资料传送门**：[更多详细资料](https://wiki.sipeed.com/hardware/zh/maix/maixpy_develop_kit_board/maix_bit.html) **Maix Bit 源码传送门**：[点击查看](./maixsense a010/../code.html#tof_mainpy) <! **MaixSense A010 外接 Maix Bit 例程**：[点击查看](http://wiki.sipeed.com/hardware/zh/maixsense/maixsense a010/mcu.html) > ![ms_mcu](./assets/ms_mcu.jpg) ## 二次开发：串口协议 可参考上方的案例：**MS A010 外接 K210 bit** **MaixSense A010 串口协议传送门**：[点击查看](http://wiki.sipeed.com/hardware/zh/maixsense/maixsense a010/at_command.html) ## 二次开发：接入 ROS ### 接入 ROS1 **1. 准备工作** 运行 ROS 前我们要准备适用的环境：`Linux` 系统。 可使用虚拟机 `virtual box` 或者 `vmware`：[点击获取](https://www.vmware.com/cn/products/workstation player/workstation player evaluation.html) 也可以自行安装双系统，安装方法请自行搜索或参考右侧：[双系统安装教程](https://neucrack.com/p/330) **2. 安装运行** ROS 接入包：[点击前往下载](https://dl.sipeed.com/shareURL/MaixSense/MaixSense_A010/software_pack/SDK) ```bash #解压缩 sipeed_tof_ms_a010.zip，并进入目录 cd ros1 source /opt/ros/*/setup.sh catkin_make source devel/setup.sh rosrun sipeed_tof_ms_a010 a010_publisher _device: \"/dev/ttyUSB0\" #之后终端会持续刷新显示[sipeed_tof]: Publishing，即正常工作 ``` ![ros_adb](./assets/ros_adb.jpg) **3. 可自行在 RQT 查看帧率** ![ms_rosone](./assets/ms_rosone.jpg) **4. RVIZ2 预览** 打开 `rviz2` 后，在界面左下角的 `Add` >`By topic` >`PointCloud2或/depth` >`Image 添加` >`Display/Global Options/Fixed Frame` 需要修改成 `tof`，才能正常显示点云，根据添加的内容，左侧会显示 `Image` 而中间则显示点云。 ![ms_rviz](./assets/ms_rviz.jpg) ### 接入 ROS2 **1. 准备工作** 运行 ROS 前我们要准备适用的环境：`Linux` 系统。 可使用虚拟机 `virtual box` 或者 `vmware`：[点击获取](https://www.vmware.com/cn/products/workstation player/workstation player evaluation.html) 也可以自行安装双系统，安装方法请自行搜索或参考右侧：[双系统安装教程](https://neucrack.com/p/330) > 如果环境同时安装了 ROS1，使用 ROS2 的话需要选额外择正确的版本。 ```bash ls /opt/ros ros@ros virtual machine:~/Desktop$ ls /opt/ros noetic rolling ``` **2. 安装运行** 我们提供了 ROS2 的接入功能包，用户需要在运行 ROS2 的系统上编译安装。 ROS 接入包：[点击前往下载](https://dl.sipeed.com/shareURL/MaixSense/MaixSense_A010/software_pack/SDK) ```bash #解压缩sipeed_tof_ms_a010.zip，并进入目录 cd ros2 source /opt/ros/*/setup.sh colcon build #（如提示缺少colcon时需要sudo apt install python3 colcon ros） source install/setup.sh ros2 run sipeed_tof_ms_a010 publisher ros args p device: \"/dev/ttyUSB0\" #之后终端会持续刷新显示[sipeed_tof]: Publishing，即正常工作 ``` **3. RQT 查看帧率** ![ms_rqt](asstes/../asstes/../assets/ms_rqt.jpg) **4. RVIZ2 预览** 打开 `rviz2` 后，在界面左下角的 `Add` >`By topic` >`PointCloud2或/depth` >`Image 添加` >`Display/Global Options/Fixed Frame` 需要修改成 `tof`，才能正常显示点云，根据添加的内容，左侧会显示 `Image` 而中间则显示点云。 ![ms_ros](assets/ms_ros.jpg)"},"/hardware/zh/maixsense/maixsense-a010/mcu.html":{"title":"MS-A010 接入 MCU（Maix Bit）","content":"# MS A010 接入 MCU（Maix Bit） 此文详细说明一下 MaixSense a010 接入 K210 Bit 例程，用户可基于此篇快速进行二次开发。 [Maix Bit 购买链接指路](https://item.taobao.com/item.htm?spm a230r.1.14.11.681570a1yq4sJD&id 586580351110&ns 1&abbucket 10&mt ) []() ![ms_mscu](./assets/ms_mcu.jpg) ## 概述 MS A010 拥有强大的兼容性，可基于串口协议外接 Maix I Bit 这样的单片机开发板或树莓派之类的 linux 开发板来进行二次开发。 MAIX I BIT 开发板是 Sipeed Maix 中产品线的一员，基于嘉楠堪智科技的边缘智能计算芯片 K210 (RISC V 架构 64位双核) 设计的一款 AIOT 开发板。 ## 准备工作 首先，我们肯定要各自拥有一个 MS A010 模组和 Bit 开发板 如果没有的话，接入例程就此停步。 接下来 准备 4pin 端子线以及 USB type c 线一条。 ### 接线教程 接线需要了解 A010 的接口的引脚信息，"},"/hardware/zh/maixsense/maixsense-a010/at_command.html":{"title":"MaixSense-A010 二次开发手册","content":"# MaixSense A010 二次开发手册 ## AT 指令表 AT                                                                                                                                                                                                                                             +ISP<br>Image Signal Processor :0: turn ISP off<br> 1: turn ISP on                                                                                                                                                                             +BINN<br>full binning           1: output 100x100 pixel frame<br> 2: output 50x50 pixel frame<br> 4: output 25x25 pixel frame<br>                                                                                                             +DISP<br>display mux           0: all off<br> 1: lcd display on<br> 2: usb display on<br> 3: lcd and usb display on<br> 4: uart display on<br> 5: lcd and uart display on<br> 6: usb and uart display on<br> 7: lcd, usb and uart display on +BAUD<br>uart baudrate         0: 9600<br> 1: 57600<br> 2: 115200<br> 3: 230400<br> 4: 460800<br> 5: 921600<br> 6: 1000000<br> 7: 2000000<br> 8: 3000000                                                                                     +UNIT<br>quantization unit     0: auto<br> 1 10: quantizated by unit(mm)                                                                                                                                                                     +FPS<br>frame per second       1 19: set frame per second                                                                                                                                                                                     +Save<br>save config           : save current configuration                                 句法： 输入执行注释 AT+ISP? \\r返回当前ISP状态 AT+ISP ? \\r返回所有支持的ISP状态 AT+ISP < MODE >\\r选择ISP状态 参数： < MODE > 含义 0 \"STOP ISP\" 立即关闭模组ISP，停止IR发射器 1 \"LAUNCH ISP\" 计划启动模组ISP，实际出图需等待1～2秒 ### BINN指令 句法： 输入 执行 注释 AT+BINN? \\r 返回当前BINN状态 AT+BINN ? \\r 返回所有支持的BINN状态 AT+BINN < MODE > \\r 选择BINN状态 参数： < MODE > 含义 1 \"1x1 BINN\" 1x1相当于无binning，实际出图分辨率为100x100。 2 \"2x2 BINN\" 2×2binning，4个像素点合并成1个，实际出图分辨率为50×50计划启动模组ISP，实际出图需等待1～2秒。 4 \"4x4 BINN\" 4×4binning，16个像素点合并成1个，实际出图分辨率为25×25。 ### DISP指令 请按需开启，避免资源过度占用 句法： 输入 执行 注释 AT+DISP? \\r 返回当前DISP状态 AT+DISP ? \\r 返回所有支持的DISP状态 AT+DISP < MODE > \\r 选择DISP状态 参数： < MODE > 含义 0 all off 1 lcd display on 2 usb display on 3 lcd and usb display on 4 uart display on 5 lcd and uart display on 6 usb and uart display on 7 lcd, usb and uart display on ### BAUD指令 句法： 输入 执行 注释 AT+BAUD? \\r 返回当前BAUD状态 AT+BAUD ? \\r 返回所有支持的BAUD状态 AT+BAUD < MODE > \\r 选择BAUD状态 参数： < MODE > 含义 0 9600 1 57600 2 115200 3 230400 4 460800 5 921600 6 1000000 7 2000000 8 3000000 ### UNIT指令 句法： 输入 执行 注释 AT+UNIT? \\r 返回当前UNIT值 AT+UNIT ? \\r 返回所有支持的UNIT值 AT+UNIT < UINT > \\r 选择UNIT值 参数： < UINT > 含义 0 \"DEFAULT UNIT\" 采用默认量化策略，因tof特性导致成像近处精度优于远距离处，故放大近距离处差异，采用5.1*sqrt(x)将16bit的原数据量化为8bit 1...9 \"QUANTIZE UNIT\" 代表以x mm为单位进行量化，取值越小细节越多，同时可视距离越短，请合理设置 ### FPS指令 句法： 输入 执行 注释 AT+FPS? \\r 返回当前FPS值 AT+FPS ? \\r 返回所有支持的FPS值 AT+FPS <FPS> \\r 选择FPS值 参数： < FPS > 含义 1...19 \"frame per second\" tof出图帧率，越大越流畅 ### SAVE指令 句法： 输入 执行 注释 AT+SAVE \\r 固化TOF摄像头当前配置，事后需要复位 多机和 AE 指令建议加入 ### ANTIMMI指令 句法： 输入 执行 注释 AT+ANTIMMI? \\r 返回当前ANTIMMI状态 AT+ANTIMMI ? \\r 返回所有支持的ANTIMMI状态 AT+ANTIMMI < MODE > \\r 选择ANTIMMI状态 参数： < MODE > 含义 1 disable anti mmi 0 auto anti mmi 1 41 manual anti mmi usb display on ### 图像数据包说明 上电默认启动ISP并在显示屏显示图像，同时输出图像数据到uart和usb 图像数据封装成包（未稳定）： 1. 包头2字节：0X00、0XFF 2. 包长度2字节：当前包剩余数据的字节数 3. 其他内容16字节：包括包序号、包长度、分辨率等等 4. 图像帧 5. 校验1字节：之前所有字节的“和”低八位 6. 包尾1字节：0XDD"},"/hardware/zh/maixsense/index.html":{"title":"MaixSense 系列","content":" title: MaixSense 系列 ## MaixSense 是什么? MaixSense 系列产品搭载 TOF 深度摄像头，目前有 MaixSense A010 和 MaixSense A075V 两款产品。 MS A010 是一款由 BL702 + 炬佑 100x100 TOF 模组所组成的极致性价比的 TOF 3D 传感器模组，最大支持 100x100 的分辨率和 8 位精度，并且带有 240×135 的 LCD 显示屏可实时预览 color map 后的深度图。 而 MS A075V 是一款具有 RGB 功能的 3D TOF 摄像机模组，该模组可以实现 Linux 免驱的即插即用，实现实时彩色 3D 显示。 <img src \"./assets/meta.jpg\" alt \"summary\" width 100%> 购买方式：[淘宝链接](https://item.taobao.com/item.htm?id 684566484141) <p style \"white space:nowrap\">MaixSense A010</p> <p style \"white space:nowrap\">MaixSense A075V</p> : : : ![me small](./assets/me_small.jpg) ![me big](./assets/me_big.jpg) 接口 1.25mm 串口连接器 \\*1<br>Type C USB2.0 \\*1 1.25mm 串口连接器 \\*1 <br>Type C USB2.0 \\*1 分辨率 TOF：100x100@30fps RGB：1600x1200@30fps<br>TOF：320x240@60fps 视场角 RGB：无<br>TOF：70°(H) * 60°(V) RGB：120°<br>TOF：55°(H)*72°(H) <p style \"white space:nowrap\">TOF 像素尺寸</p> 15um 激光发射器 40nm VCSEL 940nm,3W 测量范围 0.2 2.5m 0.15 1.5m 测量精度 &lt; 1%/cm &lt; 1%/cm ## MaixSense 能做什么？ ### 案例：远中近物体实拍 高精度的映射物品摆放距离的差异，点云图可直观感受到更真实的可视化。 <html> <img src \"./maixsense a010/assets/ms_cloud.jpg\" width 48%> <img src \"./maixsense a075v/assets/mt_cloud.jpg\" width 48%> </html> ### 案例：人流统计 可实时监控人流，进行高精度、大分辨率的统计。 <html> <img src \"./assets/me_p.jpg\" width 48%> <img src \"./assets/me_pt.jpg\" width 48%> </html> ### 案例：小车避障 可搭载于小车移动并判断画面是否有障碍物，模组自带 LCD 屏幕精准显示距离并做出反应规避障碍物。 ![me_car](./assets/me_car.gif) ### 案例：键盘灯跟随 实现超酷炫的键盘灯跟随，实时跟踪手部的位置，再根据手部的位置映射键盘灯。 ![ms_lamp](./maixsense a010/assets/ms_lamp.jpg) ### 案例：体积测量 通过 SDK 获取到的模组内参数后，计算粗略点云并累加总体积，达到体积测量的效果。 ![mt_volume](./maixsense a075v/assets/mt_volumbs.jpg) ### 案例：外接 MCU MS A010 拥有强大的兼容性，基于串口协议的数据传输。 可外接 K210 bit 这样的单片机开发板或树莓派之类的 linux 开发板来进行二次开发。 ![ms_mcu](./maixsense a010/assets/ms_mcu.jpg) ### 案例：接入 ROS1 + ROS2 双支持 ROS 系统，开放 ROS1+ROS2 接入功能包，可快速获得深度数据及深度图。 <html> <img src \"./assets/me_ross.jpg\" height 250 width 49%> <img src \"./assets/me_rosb.jpg\" width 49% height 250> </html> ## 快速了解 TOF 技术 1. TOF: 是一种距离测量的方法，通过测量发射器和反射器之间的超声波/微波/光等信号的“飞行时间”来计算两者之间的距离。 可以实现TOF测距的是TOF传感器。 最常用的是红外线或激光测距。 2. 物体之间的距离存在差异。 该模块通过捕获的深度值的差异来显示冷色和暖色。冷暖色随着距离的映射而变化，距离越近色调呈暖调（橘红）而越远色调呈冷调（蓝色）。 <html> <img src \"./assets/tof_two.jpg\" height 250 width 49%> <img src \"./assets/tof.jpg\" width 49% height 250> </html> ## 更多 关于 MS 010 更详细的资料获取：[点击跳转](https://wiki.sipeed.com/hardware/zh/maixsense/maixsense a010/maixsense a010.html) 关于 MS 075 更详细的资料获取：[点击跳转](https://wiki.sipeed.com/hardware/zh/maixsense/maixsense a075v/maixsense a075v.html)"},"/hardware/zh/index.html":{"title":"Sipeed 开源产品速览","content":" title: Sipeed 开源产品速览 keywords: Sipeed, Hardware, 矽速, 硬件资料, 文档, 资料下载, 深度学习, 人工智能, K210 desc: 矽速科技的开源软硬件 WIKI 资料站 ## 总览 [Maix Zero](https://wiki.sipeed.com/hardware/zh/index.html#Maix Zero) 以 MCU 为主控的 AIOT 开发板 [Maix I](https://wiki.sipeed.com/hardware/zh/index.html#Maix I) 以 MCU 为主控的 AI 开发板 [Maix II](https://wiki.sipeed.com/hardware/zh/index.html#Maix II 系列)：Linux AI 开发板，小巧便携且实用 [Maix III](https://wiki.sipeed.com/hardware/zh/index.html#Maix III)： Linux AI 开发板，超强算力超大内存多种玩法 [LicheePI](https://wiki.sipeed.com/hardware/zh/index.html#LicheePi 系列)： Linux 开发板 [Tang](https://wiki.sipeed.com/hardware/zh/index.html#Tang FPGA 系列)：FPGA 开发板 [MaixSense](https://wiki.sipeed.com/hardware/zh/index.html#Maixsense 系列)：3D TOF 模组 [SLogic](https://wiki.sipeed.com/hardware/zh/index.html#SLogic 系列): 多功能逻辑分析仪 [Longon](https://wiki.sipeed.com/hardware/zh/index.html#Longon 系列)：MCU 开发板 [MaixFace](https://wiki.sipeed.com/hardware/zh/index.html#Maixface 模组)：商业项目板卡 [其他外设](https://wiki.sipeed.com/hardware/zh/index.html#外设模组) ## Maix Zero 项目 M0S M0P M0sense : : : : 主控 BL616 BL618 BL702 核心 RV32GCP@320MHz RV32@320MHz RV32@144MHz RAM 480KB 480KB 132KB 储存 内置 4MB Flash 内置 8MB Flash 内置 192KB ROM, 512KB Flash 无线 · Wifi<br>· 蓝牙<br>· Zigbee · Wifi<br>· 蓝牙<br>· Zigbee 蓝牙 模型平台 [MaixHub](https://www.maixhub.com) [MaixHub](https://www.maixhub.com) [MaixHub](https://www.maixhub.com) 尺寸 11(L)x10(W)mm 25.5(L) x 18(W) mm 详情页 [点我](./maixzero/m0s/m0s.html) [点我](./maixzero/m0p/m0p.html) [点我](./maixzero/sense/maix_zero_sense.html) 外观图 <img src \"./maixzero/m0s/assets/m0s/m0s_pin_map.png\" alt \"m0sense\" width \"230\"> <img src \"./maixzero/m0p/assets/m0p/m0p_module_outlook.png\" alt \"m0p_module_outlook\" width \"230\"> <img src \"./maixzero/sense/assets/m0sense_1.png\" alt \"m0sense\" width \"230\"> ## Maix I 项目 M1/M1w M1n M1s : : : : 主控 K210 K210 BL808 核心 RV64@400MHz \\* 2 RV64@400MHz \\* 2 RV64GCV@480MHz<br>RV32GCP@320MHz<br>RV32EMC@160MHz RAM 8MB 8MB 64MB 无线 M1w 支持 Wifi · Wifi<br>· 蓝牙<br>· Zigbee 封装样式 邮票孔 金手指 邮票孔 模型平台 [MaixHub](https://www.maixhub.com) [MaixHub](https://www.maixhub.com) [MaixHub](https://www.maixhub.com) 尺寸 25.4(L)x25.4(W)mm 25.0(L)x22.0(W)mm 31.0(L)x18.0(W)mm 详情页 [点我](./maix/core_module.html) [点我](./maix/M1n.html) [点我](./maix/m1s/m1s_module.html) ### Maix I S 这是一款以博流 808 为主控所制作的 AIOT 模组与核心板 [M1s](./maix/m1s/m1s_module.html) [M1s Dock](./maix/m1s/m1s_dock.html) 图片 <a href \"https://wiki.sipeed.com/m1s\"><img src \"https://gd4.alicdn.com/imgextra/i4/2200606237318/O1CN011g9yY323vhCXEyiKU_!!2200606237318.jpg\" style \"transform:rotate(270deg);\" alt \"M1s_module\" width \"80%\"></a> <a href \"https://wiki.sipeed.com/m1s#dock\"><img src \"https://gd1.alicdn.com/imgextra/i1/2200606237318/O1CN01gE4a1E23vhCV77ggE_!!2200606237318.jpg\" style \"transform:rotate(270deg);\" alt \"M1s_Dock\" width \"80%\"></a> ### Maix I 这是 2019 年以 K210 为核心所制作的一系列 AIOT 开发板。 <table role \"table\" class \"center_table\"> <tbody> <tr> <th scope \"col\"></th> <th scope \"col\">Maix Bit</th> <th scope \"col\">Maix Dock</th> <th scope \"col\">Maix Duino</th> <th scope \"col\">Maix nano</th> </tr> <tr> <td style \"white space:nowrap\">图片</td> <td> <a href \"./maix/maixpy_develop_kit_board/maix_bit.html\" target \"_blank\"><img src \"./maix/assets/dk_board/maix_bit/Bit.png\" ></a> </td> <td><a href \"./maix/maixpy_develop_kit_board/Maix_dock.html\" target \"_blank\"><img src \"./maix/assets/dk_board/maix_dock/Dan_Dock.png\" ></a></td> <td><a href \"./maix/maixpy_develop_kit_board/maix_duino.html\" target \"_blank\"><img src \"./maix/assets/dk_board/maix_duino/maixduino_0.png\" ></a></td> <td><a href \"./maix/maixpy_develop_kit_board/maix_nano.html\"><img src \"./maix/assets/dk_board/maix_nano/maix_nano.jpg\" alt \"Maxi nano\"></a></td> </tr> <tr> <th scope \"col\"></th> <th scope \"col\">Maix Cube</th> <th scope \"col\">Maix Amigo</th> <th scope \"col\">Maix HAT</th> <th scope \"col\">Maix Go</th> </tr> <tr> <td style \"white space:nowrap\">图片</td> <td><a href \"./maix/maixpy_develop_kit_board/maix_cube.html\" target \"_blank\"><img src \"./maix/assets/dk_board/maix_cube/maix_cube.png\" ></a></td> <td><a href \"./maix/maixpy_develop_kit_board/maix_Amigo.html\" target \"_blank\"><img src \"./maix/assets/dk_board/maxi_amigo/maix_amigo_0.png\" ></a></td> <td><a href \"./maix/maixpy_develop_kit_board/maix_hat.html\"><img src \"./../../soft/maixpy/assets/hardware/grove_ai_hat/grove_ai_hat1.png\" alt \"Maix HAT\"></a></td> <td><a href \"./maix/maixpy_develop_kit_board/maix_go.html\" target \"_blank\"><img src \"./maix/assets/dk_board/maix_go/Go.jpg\" ></a></td> </tr> </tbody> </table> ### 产品支持 Maix 系列产品可以在多种场景实现客户不同方面的需要，在 AIoT 上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。商业合作可以联系 <support@sipeed.com>。 ## Maix II 系列 项目 MaixII Dock MaixII Sense MaixII S : : : : 主控 V831 R329 V833 核心 Cortex A7@800MHz Cortex A53\\*2@1.5GHz Cortex A7@1.2GHz RAM 64MB 256MB 默认 128MB 无线 Wifi · Wifi<br>· 蓝牙 · Wifi 外观图 <img src \"https://gd3.alicdn.com/imgextra/i3/2200606237318/O1CN01dT63dq23vhAOtdtm7_!!2200606237318.png_400x400.jpg\" style \"transform:rotate(0deg);\" alt \"MaixII Dock\"> <img src \"https://gd3.alicdn.com/imgextra/i3/2200606237318/O1CN01AJdLYs23vh6b40oy2_!!2200606237318.png_400x400.jpg\" style \"transform:rotate(0deg);\" alt \"MaixII Sense\"> <img src \"https://gd2.alicdn.com/imgextra/i2/2200606237318/O1CN01C4iTYi23vh6muQApg_!!2200606237318.png_400x400.jpg\" style \"transform:rotate(0deg);\" alt \"MaixII S\"> 模型平台 [MaixHub](https://www.maixhub.com) 详情页 [点我](http://wiki.sipeed.com/m2dock) [点我](./maixii/m2a/maixsense.html) [点我](./maixii/M2S/V833.html) 备注 <strong>推荐产品</strong>，高性价比能跑 Linux 的 SOC，同时支持硬件 AI 加速（0.2Tops 算力），目前软件支持最容易入门，提供 C SDK 和 Python SDK， 以及在线模型训练服务(<a href \"https://maixhub.com\" target \"_blank\">MaixHub</a>) 有提供硬件 AI 加速，0.25Tops 算力。 仅支持商业 ## Maix III 目前 Maix III axpi 是最新款的 AI 开发板，拥有高算力、大内存、多种接口，支持超多算子。强烈推荐。 项目 MaixIII axpi : : 主控 Ax620a 核心 Cortex A7\\*4@1.0GHz NPU 14.4Tops@int4，3.6Tops@int8 ISP 4K@30fps RAM 2GB LPDDR4X 3733Mhz 摄像头输入 默认单摄, 最高支持 3 摄:<br>1 个 MIPI4 LANE+2 个 MIPI2 LANE 屏幕输出 支持最高 4 LANE MIPI DSI 屏幕 网络接口 支持 千兆以太网（ETH） 和 2.4GHZ WI FI 板载天线 USB 接口 1xUSB2.0HS 支持 OTG 或 HOST 功能，<br>1xUSB UART 系统串口 外观图 <img src \"https://gd2.alicdn.com/imgextra/i2/2200606237318/O1CN01AY6Mu123vhBaHWr6H_!!2200606237318.jpg_400x400.jpg\" style \"transform:rotate(0deg);\" alt \"MaixIII Axpi\" width \"40%\"> 模型平台 [MaixHub](https://www.maixhub.com) 更多内容请前往[详情页](./maixIII/ax pi/axpi.html)查看 ## LicheePi 系列 类别 Lichee RV Lichee Zero Plus Lichee Zero Lichee nano : : : : : SOC Allwinner D1 Allwinner S3 Allwinner V3s Allwinner F1c100s CPU 架构 玄铁 C906 Cortex™ A7 Cortex™ A7 ARM 926EJS 运行频率 1GHz 1.2GHz 1.2GHz(max) 600MHz(max) RAM 512MB DDR3 128Mbyte DDR3 64MB DRAM 32MB DDR FLASH 可选 SD nand 可选 SD Nand、<br>SPI Nor Flash<br>或者 eMMC 预留<br>SOP8 SPI Flash<br>焊盘 板载 16MB NOR FLASH TF 连接器 有 有 有 有 LicheePI 是为了能让用户获得优廉的 linux 设备，实战 linux 底层相关的内容的产品。 <table> <thead> <tr> <th style \"text align:center\">Lichee Zero</th> <th style \"text align:center\">Lichee Nano</th> </tr> </thead> <tbody> <tr> <td style \"text align:center\"><a href \"./lichee/Zero/Zero.html\"><img src \"./lichee/assets/Zero/Zero_1.png\" alt \"Lichee Zero\"></a></td> <td style \"text align:center\"><a href \"./lichee/Nano/Nano.html\" ><img src \"./lichee/assets/Nano/Nano_2.png\" alt \"Lichee Nano\"></a></td> </tr> </tbody> <thead> <tr> <th style \"text align:center\">Lichee Zero Plus</th> <th style \"text align:center\">Lichee RV</th> </tr> </thead> <tbody> <tr> <td style \"text align:center\"><a href \"./lichee/ZeroPlus/ZeroPlus.html\"><img src \"./lichee/assets/Zero Plus/Plus_1.jpg\" alt \"Tang Nano 4K\"></a></td> <td style \"text align:center\"><a href \"./lichee/RV/RV.html\"><img src \"./lichee/assets/RV/D1 4.png\" alt \"Lichee RV\"></a></td> </tr> </tbody> </table> ## Tang FPGA 系列 Tang FPGA 目前分为 Tang Nano 和 Tang Primer 两个系列。 Tang Nano 是尽可能小体积的核心板 Tang Primer 是多引脚多拓展性的开发板。 ### Tang Nano 项目 <p style \"white space:nowrap\">Tang Nano 20K</p> <p style \"white space:nowrap\">Tang Nano 9K</p> <p style \"white space:nowrap\">Tang Nano 4K</p> <p style \"white space:nowrap\">Tang Nano 1K</p> : : : : 逻辑单元(LUT4) 20736 8640 4608 1152 寄存器（FF） 15552 6480 3456 864 S SRAM (bits) 41472 17280 B SRAM (bits) 828K x 46 468K x 26 180K x 10 72K x 4 用户闪存 (bits) 608K 256K 96K 锁相环 (PLL) 2 2 2 1 RAM 32bits SDR SDRAM 16 bits PSRAM 8bits HyperRam RAM 容量 64Mb 64M 64Mb 板载 Flash 64Mbits NOR Flash 32Mbits NOR Flash 32Mbits NOR Flash 预留焊盘 硬核处理器 Cortex M3 <table> <thead> <tr> <th style \"text align:center\">Tang Nano 20K</th> <th style \"text align:center\">Tang Nano 9K</th> </tr> </thead> <tbody> <tr> <td style \"text align:center\"><a href \"./tang/tang nano 20k/nano 20k.html\"><img src \"./../assets/Tang/nano_20k/tang_nano_20k_3920_top.png\" alt \"Tang Nano 20K\"></a></td> <td style \"text align:center\"><a href \"./tang/Tang Nano 9K/Nano 9K.html\"><img src \"./../assets/Tang/Nano 9K/9K.png\" alt \"Tang Nano 9K\"></a></td> </tr> </tbody> <thead> <tr> <th style \"text align:center\">Tang Nano 4K</th> <th style \"text align:center\">Tang Nano 1K</th> </tr> </thead> <tbody> <tr> <td style \"text align:center\"><a href \"./tang/Tang Nano 4K/Nano 4K.html\"><img src \"./../assets/Tang/Nano_4K/Nano_4K.png\" alt \"Tang Nano 4K\"></a></td> <td style \"text align:center\"><a href \"./tang/Tang Nano 1K/Nano 1k.html\"><img src \"./../assets/Tang/Nano 1K/1K.png\" alt \"Tang Nano 1K\"></a></td> </tr> </tbody> </table> ### Tang Primer 项目 <p style \"white space:nowrap\">Tang Primer 20K</p> : : 逻辑单元(LUT4) 20736 寄存器（FF） 15552 S SRAM (bits) 41472 B SRAM (bits) 828K x 46 锁相环 (PLL) 4 板载内存 16bits DDR3 RAM 板载内存容量 128MB 板载 Flash 32Mbits NOR Flash 核心板照片 <img src \"./../assets/Tang/primer_20k/primer_20k.png\" alt \"Tang Primer 20K（核心板）\"> 底板数量 2 详情页 <a href \"./tang/tang primer 20k/primer 20k.html\"> 点我 </a> ### 售罄产品 Tang Nano Tang Primer : : : : [![Tang Nano](./../assets/Tang/Nano/Tang_Nano.jpg)](./tang/Tang Nano/Nano.html) [![Tang Primer](./../assets/Tang/permier/Tang_permier.jpg)](./tang/Tang primer/Tang primer.html) ## MaixSense 系列 基于 TOF 技术的深度相机 Maixsense a010 MaixSense a075V 图片 ![me_small](./maixsense/assets/me_small.jpg) ![me_big](./maixsense/assets/me_big.jpg) 接口 1.25mm 串口连接器 \\*1<br>Type C USB2.0 \\*1 1.25mm 串口连接器 \\*1 <br>Type C USB2.0 \\*1 分辨率 TOF：100x100@30fps RGB：1600x1200@30fps<br>TOF：320x240@60fps 视场角 RGB：无<br>TOF：70°(H) \\* 60°(V) RGB：120°<br>TOF：55°(H)\\*72°(H) <p style \"white space:nowrap\">TOF 像素尺寸</p> 15um 激光发射器 40nm VCSEL 940nm,3W 测量范围 0.2 2.5m 0.15 1.5m 测量精度 &lt; 1%/cm &lt; 1%/cm ## SLogic 系列 SLogic 全称为 Sipeed Logic Analyzer，是逻辑分析仪。 Lite8 Combo8 采样芯片 BL616 BL616 通讯方式 USB2.0 HS USB2.0 HS 采样率@通道数 160M@2Channel<br>80M@4Channel<br>40M@8Channel 160M@2Channel<br>80M@4Channel<br>40M@8Channel 信号输入范围 0～3.6V 0～3.6V 高低电平识别范围 VIH: >2V<br>VIL: <0.8V VIH: >2V<br>VIL: <0.8V CKLink 功能 支持 DapLink 功能 支持 串口功能 支持四串口功能，每个串口最大20MBps ## Longon 系列 MCU 开发板 <img src \"./longan/Nano/assets/longan_nano.jpg\" alt \"longan_nano\" width \"40%\"> 详情页：[点我](./longan/Nano/assets/index.html) ## MaixFace 模组 商业合作模组，无个人支持 前往首页商业方案板块查看对应设备 ## 外设模组 前往首页外设模组板块查阅对应设备"},"/hardware/zh/logic_analyzer/index.html":{"title":"SLogic series","content":" title: SLogic series keywords: LogicAnalyzer, debugger, link, RISCV, tool update: date: 2023 03 09 version: v0.1 author: wonder content: Create file SLogic is Sipeed Logic Analyzer."},"/hardware/zh/maixzero/sense/maix_zero_sense.html":{"title":"M0sense 开发板","content":" title: M0sense 开发板 keywords: BL702 ,开发板 update: date: 2022 11 08 version: v0.1 author: wonder content: 初次编写文档 ## 概述 Sipeed M0sense 是基于[博流智能科技](http://www.bouffalolab.com/)的 BL702 芯片所设计的一款 AIOT 开发板，主控芯片为 Risc V 架构，支持低功耗蓝牙。板载一个 8P FPC 接口来连接 LCD 屏幕，额外配备了 1 个麦克风、1 个 RGB LED 和一颗六轴传感器芯片，引出了一路 USB 2.0 FS 到 Type C 座子。 购买链接：[淘宝](https://item.taobao.com/item.htm?id 693997918701) <img src \"./assets/m0sense_1.png\" alt \"m0sense_1.png\" > ## 视频 M1s Dock 和 M0Sense 总览； M0Sense 在 3:15 处开始，之前的为 M1s Dock 宣传视频. <iframe src \"//player.bilibili.com/player.html?aid 559937139&bvid BV1De4y117sP&cid 887814913&page 1&t 197\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\" > </iframe> ## 特点 主芯片 BL702 RISC V 144MHz 支持蓝牙规范 5.0/ 蓝牙低功耗 BLE 板载显示屏接口（可选配 0.68 寸 80x160 显示屏） 板载 1 个模拟麦克风、1 个 RGB LED、1 个 IMU 引出一路 USB 2.0 FS 到 USB Type C 接口 ## 参数 <table> <thead> <tr> <th colspan \"2\" > M0sense 开发板 </th> </tr> </thead> <tbody> <tr> <td rowspan \"6\" style \"white space:nowrap\">主控 BL702 处理器</td> </tr> <tr> <td>32 bits RISC V with FPU (Max Freq 144MHz)</td> </tr> <tr> <td>132KB RAM，192KB ROM, 512KB Flash</td> </tr> <tr> <td> · 2 个 32 位通用定时器 <br> · 8 个 DMA 通道 <br> · 1 个 SPI 主/从机 <br> · 2 个 UART <br> · 1 个 I2C 主机 <br> · 1 个 I2S 主/从机 <br> · 5 个 PWM 通道 <br> · 12 位通用 ADC <br> · 10 位通用 DAC <br> </td> </tr> <tr> <td>无线：<br> · 支持 2.4Ghz 蓝牙规范 V5.0<br> · 蓝牙低功耗 1Mbps 和 2Mbps </td> </tr> <tr> <td> USB 2.0 FS 引出到 USB Type C 接口用来下载固件 </td> </tr> <tr> <td rowspan \"6\" style \"white space:nowrap\"> 板载部件 </td> </tr> <tr> <td>显示屏接口（可选配 0.96 寸 80x160 显示屏）</td> </tr> <tr> <td>板载 1 个模拟麦克风</td> </tr> <tr> <td>1 个 RGB LED</td> </tr> <tr> <td>1 个 6 轴 IMU（QMI8658A）</td> </tr> <tr> <td>陶瓷天线</td> </tr> <tr> <td rowspan \"5\" style \"white space:nowrap\"> 其他说明 </td> </tr> <tr> <td> 3D 模型文件下载：<a href \"https://dl.sipeed.com/shareURL/Maix Zero/M0sense/5_3D_file\">点击跳转</a> </td> </tr> <tr> <td>外部供电需求 TYPE C 接口：5V±10% 0.5A</td> </tr> <tr> <td>温升: &lt;30K</td> </tr> <tr> <td>工作温度范围: 10℃ ~ 65℃</td> </tr> </tbody> </table> ## 尺寸 <img src \"./assets/m0sense_size.png\" alt \"m0sense_size\" width 55%> ## 引脚 <img src \"./assets/m0sense_pinmap.png\" alt \"m0sense_pinmap\" width 75%> ## 对比 <table> <thead> <tr> <th>项目</th> <th>Arduino Nano 33 BLE SENSE</th> <th>Sipeed M0sense</th> </tr> </thead> <body> <tr> <td> MCU </td> <td>nRF52840 (Cortex M4)</td> <td>BL702 (RV32)</td> </tr> <tr> <td>Freq</td> <td>64MHz</td> <td>144MHz</td> </tr> <tr> <td>SRAM</td> <td>256KB</td> <td>132KB</td> </tr> <tr> <td>蓝牙</td> <td>支持</td> <td>支持</td> </tr> <tr> <td>IIC/UART/SPI</td> <td>有</td> <td>有</td> </tr> <tr> <td>LED</td> <td>单色</td> <td>RGB 三色</td> </tr> <tr> <td>MIC</td> <td>有</td> <td>有</td> </tr> <tr> <td>IMU</td> <td>有</td> <td>有</td> </tr> <tr> <td>其他传感器</td> <td>APDS9960，LPS22HB，HTS221</td> <td></td> </tr> <tr> <td>LCD</td> <td></td> <td>可选 0.96 寸屏幕</td> </tr> <tr> <td>USB</td> <td>有</td> <td>有</td> </tr> <tr> <td>尺寸</td> <td>45mm x 18mm</td> <td>23mm x 18mm</td> </tr> <tr> <td>模型平台</td> <td>TFLite Micro + edge impulse</td> <td>TinyMaix + MaixHub</td> </tr> <tr> <td>价格</td> <td>$40</td> <td>$4</td> </tr> </body> </table> ## 软件描述 <table> <thead> <tr> <th colspan \"2\" > M0sense </th> </tr> </thead> <tbody> <tr> <td>OS</td> <td>FreeRTOS</td> </tr> <tr> <td>开发方式</td> <td>· 原生 C SDK<br>· MaixHAL C 模块<br>· PikaPython </td> </tr> <tr> <td>固件下载</td> <td>· USB虚拟串口下载<br>· USB虚拟磁盘拖拽更新</td> </tr> <tr> <td>AI 推理框架</td> <td>TinyMaix 推理框架</td> </tr> <tr> <td>AI 模型下载</td> <td>· <a href \"https://maixhub.com/\">MaixHub</a> 下载。支持 关键词唤醒，手势识别 等模型</td> </tr> <tr> <td>Sipeed 参考示例</td> <td>· https://github.com/sipeed/M0sense_BL702_example</td> </tr> </tbody> </table> ## 补充资料 [板卡规格书](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/1_Specification) [板卡原理图](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/2_Schematic) [板卡点位图](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/3_Bit_number_map) [板卡尺寸图](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/4_Dimensional_drawing) [3D 模型文件](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/5_3D_file) [博流官方文档](https://dev.bouffalolab.com/home/) [BL702 数据手册](https://gitee.com/wonderfullook/bl_docs/tree/main/BL702_DS/zh_CN) (gitee) [BL702 参考手册](https://gitee.com/wonderfullook/bl_docs/tree/main/BL702_RM/zh_CN) (gitee) [例程](https://github.com/sipeed/M0sense_BL702_example) (Github) [Bouffalolab SDK](https://github.com/bouffalolab/bouffalo_sdk)(Github) 交流 QQ 群：`816177882` 。[点我加群](https://jq.qq.com/?_wv 1027&k CSnLIADN) 论坛：[bbs.sipeed.com](https://bbs.sipeed.com/) ## 注意事项 <table> <tr> <th>项目</th> <th>注意事项</th> </tr> <tr> <td>静电防护</td> <td>请避免静电打到 PCBA 上；接触 PCBA 之前请把手的静电释放掉</td> </tr> <tr> <td>容忍电压</td> <td> 每个 GPIO 的工作电压已经在原理图中标注出来，请不要让 GPIO 的实际工作的电压超过额定值，否则会引起 PCBA 的永久性损坏 </td> </tr> <tr> <td>FPC 座子</td> <td>在连接 FPC 软排线的时候，谲确保排线无偏侈地完整地插入到排线中</td> </tr> <tr> <td>插拔</td> <td>请完全断电后才进行插拔操作</td> </tr> <tr> <td>避免短路</td> <td>请在上电过程中，避免任何液体和金属触碰到 PCBA 上的元件的焊盘，否则会导致路，烧毁 PCBA</td> </tr> </table> ## 联系 M0sense 可以在多种场景实现客户不同方面的需要，技术支持和商业合作请联系使用邮箱 [support@sipeed.com](support@sipeed.com)"},"/hardware/zh/maixzero/sense/start.html":{"title":"M0sense 上手使用","content":" title: M0sense 上手使用 keywords: M0sense update: date: 2023 02 03 version: v0.2 author: wonder content: 增加早期固件说明 date: 2022 11 28 version: v0.1 author: wonder content: 初次编辑 > 因为固件不同，m0sense 可能显示不出 U 盘，需要自己根据 [烧录 bin 文件](#烧录 bin 文件) 篇章的内容烧录后才能显示 U 盘。 ## 初见 > 因为固件不同，可能不会有频谱图显示。 通电后板子上的 led 亮起，且屏幕显示出周围环境音的频谱图。 <img src \"./assets/start/m0sense_start.jpg\" alt \"m0sense_start\" width \"45%\"> <img src \"./assets/start/m0sense_start_screen.jpg\" alt \"m0sense_start_screen\" width \"45%\"> ## U 盘烧录 对于 M0sense 我们提供了使用虚拟 U 盘拖拽烧录固件的方式。 > 因为固件不同，m0sense 可能显示不出 U 盘，需要自己根据 [烧录 bin 文件](#烧录 bin 文件) 篇章的内容烧录后才能显示 U 盘。 按住板子上的 BOOT 键后按下 RESET 键，就会在电脑上显示一个 U 盘了。 ![m0sense_udisk](./assets/start/m0sense_udisk.jpg) 直接将想要烧录的固件拖进 U 盘，成功烧录后 U 盘会自动弹出且板子会自动复位来重新加载新固件。 ![m0sense_drag_burn](./assets/start/m0sense_drag_burn.gif) 这边提供了几个 Demo 固件 [点我跳转](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/7_Example_demos)，可以直接拖拽到 U 盘查看烧录结果，其对应的源码均可在 [github](https://github.com/sipeed/M0sense_BL702_example) 上面获取。 > 源码镜像地址： https://gitee.com/sipeed/M0sense_BL702_example 下面是这几个 demo 固件的说明与效果展示 ### hello_world.uf2 [点我下载](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/7_Example_demos/hello_world) 通过 U 盘烧录方式将它烧录进板子后，可以通过串口软件打开板子串口，可以看到板子打印出的 `Hello,World` ![m0sense_hello_world](./assets/start/m0sense_hello_world.gif) ### blink_baremetal.uf2 [点我下载](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/7_Example_demos/blink_baremetal) 拖拽到 U 盘烧录完后，断电重新连接一下板子，LED 开始闪灯。打开串口后会显示灯的状态。 打开串口软件 ![m0sense_blink_baremetal_uart](./assets/start/m0sense_blink_baremetal_uart.gif) LED 闪灯 ![m0sense_blink_baremetal_led](./assets/start/m0sense_blink_baremetal_led.gif) ### blink_rtos.uf2 [点我下载](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/7_Example_demos/blink_rtos) 这个 demo 效果与上面的一样，只是是基于 RTOS 实现的，上面那个 demo 是裸机程序。 使用串口软件打开串口后才开始闪灯，关闭串口后灯的颜色会保持不变。 打开串口软件 ![m0sense_blink_baremetal_uart](./assets/start/m0sense_blink_baremetal_uart.gif) LED 闪灯 ![m0sense_blink_baremetal_led](./assets/start/m0sense_blink_baremetal_led.gif) ### lcd_flush.uf2 [点我下载](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/7_Example_demos/lcd_flush) 烧录进板子后，板子配套的 lcd 背景色变化，打开串口会显示当前屏幕颜色的数值。 ![m0sense_lcd_flush](./assets/start/m0sense_lcd_flush.gif) ![m0sense_lcd_flush_uart](./assets/start/m0sense_lcd_flush_uart.gif) ### imu.uf2 [点我下载](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/7_Example_demos/imu) 烧录进板子后，从串口可以看到板子上面 6 轴 IMU (惯性传感器)的数据。 ![m0sense_imu_uart](./assets/start/m0sense_imu_uart.gif) ### single_button_control.uf2 [点我下载](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/7_Example_demos/single_button_control) 烧录到板子中后，按下 BOOT 键，LED 会切换颜色，串口会打印当前 LED IO 状态。 具体逻辑可以查看[源码](https://gitee.com/Sipeed/M0sense_BL702_example/blob/main/m0sense_apps/rtos_demos/single_button_control/main.c)。 ![single_button_control](./assets/start/single_button_control.gif) ![single_button_control_uart](./assets/start/single_button_control_uart.gif) ### audio_recording.uf2 [点我下载](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/7_Example_demos/audio_recording) 烧录进板子后，串口会持续打印麦克风所获得的周围环境音的 16bit pcm 格式数据。 ![audio_recording](./assets/start/audio_recording.gif) ## SDK 环境搭建 M0sense 要求在 Linux 环境下进行编译。 ### 获取例程仓库 ```bash git clone https://gitee.com/Sipeed/M0sense_BL702_example.git ``` 最终结构树如下 ```bash sipeed@DESKTOP:~$ tree L 1 M0sense_BL702_example/ M0sense_BL702_example/ ├── LICENSE # 许可证文件 ├── README.md # 仓库说明 ├── bl_mcu_sdk # SDK 文件 ├── build.sh # 编译脚本 ├── m0sense_apps # 例程源码 ├── misc # 其他应用 └── uf2_demos # 例程文件 ``` ### 在例程目录下，获得 SDK 仓库 仓库很大，400M 以上。 ```bash cd M0sense_BL702_example git clone https://gitee.com/bouffalolab/bl_mcu_sdk ``` 最终得到的结构树应如下(截取部分)： ```bash sipeed@DESKTOP:~$ tree L 2 M0sense_BL702_example/ M0sense_BL702_example/ ├── LICENSE # 许可证文件 ├── README.md # 仓库说明 ├── bl_mcu_sdk # SDK 文件 │ ├── README_zh.md # SDK 中文说明 │ ├── ReleaseNotes # SDK 发布说明 │ ├── bsp │ ├── cmake │ ├── components │ ├── docs │ ├── drivers │ ├── examples │ ├── project.build │ ├── tools │ └── utils ├── build.sh # 编译脚本 ├── m0sense_apps # 例程源码 ├── misc # 其他应用 └── uf2_demos # 例程文件 ``` ### 在例程目录下，获取编译工具链 ```bash git clone https://gitee.com/bouffalolab/toolchain_gcc_sifive_linux ``` 最终得到的结构树应如下(截取部分)： ```bash sipeed@DESKTOP:~$ tree L 2 M0sense_BL702_example/ M0sense_BL702_example/ ├── LICENSE # 许可证文件 ├── README.md # 仓库说明 ├── bl_mcu_sdk # SDK 文件 │ ├── README_zh.md # SDK 中文说明 │ ├── ReleaseNotes # SDK 发布说明 │ ... ├── build.sh # 编译脚本 ├── m0sense_apps # 例程源码 ├── misc # 其他应用 ├── toolchain_gcc_sifive_linux # 编译工具链 │ ├── bin # 编译链可执行文件路径 │ ├── lib # 动态库文件 │ ... └── uf2_demos # 例程文件 ``` ### 在例程目录下，打补丁 首先确定是在 `M0sense_BL702_example` 目录下。 打补丁前需要先设置一下用户名和邮箱, 随便设置一个 ```bash cd bl_mcu_sdk git config user.email \"m0sense@sipeed.com\" git config user.name \"tinymaix\" ``` 设置完后可以打补丁了。 ```bash cd .. ./build.sh patch ``` 出现 `Apply patch for you!` 说明成功打补丁了，可以接着下面的操作了。 ![m0sense_patch](./assets/start/m0sense_patch.jpg) ### 配置编译工具链路径 以后每次开始编译都需要执行一次这个来配置下编译工具链路径。 首先需要知道 `M0sense_BL702_example` 的路径。 ```bash sipeed@DESKTOP:~$ pwd /home/lee/M0sense_BL702_example ``` 我们复制上面执行 `pwd` 后的结果（每个人的会不一样）然后在后面加上 `/toolchain_gcc_sifive_linux/bin`，然后执行下面的命令，就配置完路径了 ```bash PATH $PATH:/home/lee/M0sense_BL702_example/toolchain_gcc_sifive_linux/bin ``` 根据每个人电脑不同执行完上述命令后可以使用下面的命令 `riscv64 unknown elf gcc v` 来看所配置的工具链是不是正确了。 配置成功了的结果和下面类似。 ```bash sipeed@DESKTOP:~$ riscv64 unknown elf gcc v Using built in specs. COLLECT_GCC riscv64 unknown elf gcc COLLECT_LTO_WRAPPER /home/lee/M0sense_BL702_example/toolchain_gcc_sifive_linux/bin/../libexec/gcc/riscv64 unknown elf/10.2.0/lto wrapper Target: riscv64 unknown elf ``` 没有成功的话会提示没找到 `riscv64 unknown elf gcc`，自己再重新配置一下 ![m0sense_toolchain_notfound](./assets/start/m0sense_toolchain_notfound.jpg) ### 编译 demo 首次编译 demo 前，需要在自己的电脑上编译一下固件转换工具来为了直接 U 盘拖拽烧录。 确定自己是在 `M0sense_BL702_example` 目录下执行下面的命令。 ```bash sudo apt install gcc # 安装适用于自己电脑的 gcc gcc I libs/uf2_format misc/utils/uf2_conv.c o uf2_convert # 编译出固件转换工具 ``` 然后就可以编译 demo 了 ```bash ./build.sh m0sense_apps/blink/blink_baremetal ``` 最终生成的 U 盘烧录的 uf2 文件在 uf2_demos 目录下，bin 文件之类的在 bl_mcu_sdk/out 文件夹下。 ## SDK 编译注意事项 1. 第一次搭建环境最好自己编译一份 uf2 文件转换工具 2. 每次新开终端编译记得配置一下 [编译工具链路径](#配置编译工具链路径) 3. SDK 编译失败时确定自己是按照 [编译 demo](#编译 demo) 里面所说的使用 `./build.sh m0sense_apps/blink/blink_baremetal` 命令来执行编译的，而不是 `./build.sh m0sense_apps/blink/blink_baremetal/` （注意结尾处的 `/` ）命令 ## 烧录 bin 文件 有时候可能由于某些原因需要烧录 bin 文件，这里写一下烧录方法。 给 M0sense 烧录需要用到博流官方烧录工具，前往 https://dev.bouffalolab.com/download 下载名称为 `Bouffalo Lab Dev Cube` 的文件。解压后就得到了用来烧录板子的应用程序。 ![bouffalo_cube](./../../maix/m1s/other/assets/start/bouffalo_cube.png) 解压后的文件夹中主要关注 `BLDevCube`、 `BLDevCube macos` 和 `BLDevCube ubuntu` 三个文件，用于在不同系统启动这个烧录工具。 ![application](./../../maix/m1s/other/assets/start/application.png) 然后使用镊子或其他金属短接上板子上的 3.3V 引脚和 boot 引脚，然后在给板子通电，这样板子进入烧录模式了。可以在电脑设备管理器中看到出现了一个串口设备。 短接引脚 设备管理器中的串口设备 ![boot_mode](./assets/start/boot_mode.jpg) ![serial_device](./assets/start/serial_device.jpg) 接着打开 `BLDevCube` 烧录软件（根据自己系统选择），选择 `BL702` 芯片，在打开的软件界面选择 MCU 模式，选择想要烧录进去的固件。默认的固件可以在这里下载到: [Click me](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/7_Example_demos/default_firmware) <table> <tr> <td><img src \"./../../maix/m1s/other/assets/start/select_bl702.png\" alt \"select_bl702\" style \"transform:rotate(0deg);\"></td> <td><img src \"./../../maix/m1s/other/assets/start/mcu_mode.png\" alt \"mcu_mode\" style \"transform:rotate(0deg);\" width \"70%\"></td> </tr> </table> 点击 `Refresh`，选择唯一的串口（如果看到的不是唯一串口，重新短接 boot 引脚和 3.3v 引脚后再上电使 M0sense 进入下载模式），设置波特率 2000000， 点击下载烧录。 ![burn_bl702](./assets/start/burn_bl702.png) 烧录结束后，重新插拔一次 USB 来重新启动 bl702 以应用新的固件。 ![finish_burn_702](./assets/start/finish_burn_702.png) ## 补充说明 板子上有 BOOT 按键和 BOOT 引脚这两处 BOOT 丝印说明。 <img src \"./assets/start/m0sense_boot_key.jpg\" width \"40%\" alt \"m0sense_boot_key\"> <img src \"./assets/start/m0sense_boot_silkprint.jpg\" width \"40%\" alt \"m0sense_boot_silkprint\"> 上面可以看出来两个有 BOOT 说明，在原理图中分别如下： ![boot_description](./assets/start/boot_description.png) 从 [原理图](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/2_Schematic) 可以看到。两个按键分别连接到了 GPIO_2 和 AU_CHIP，根据芯片参考手册可以知道 `AU_CHIP` 引脚是芯片的复位引脚，因此对应着 Reset 按键， 所以另一个按键为自定义的软件 Boot 引脚，需要搭配[固件](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/7_Example_demos/default_firmware)才能通过 U 盘烧录方式来快速烧录。 上面标识的原理图中， Boot_Strap 为芯片的硬件 BOOT 引脚，上电前将他拉高就可以进入完整固件烧录模式 （需要配合官方烧录工具来烧录固件）。 U 盘烧录模式是基于软件实现的一种特殊的烧录方式，串口烧录方式是芯片最原始的烧录方式。"},"/hardware/zh/maixzero/m0p/m0p.html":{"title":"M0P 模组","content":" title: M0P 模组 keywords: M0P ,模组, bl618, BL618 update: date: 2023 03 09 version: v0.1 author: wonder content: 初次编写文档 ## 模组概述 Sipeed M0P 模组是基于[博流智能科技](http://www.bouffalolab.com/)的 BL618 芯片所设计的一款 AIOT 模组，支持 WIFI6、蓝牙 5.2 等无线协议，邮票孔的让它能快速应用在多种 AIOT 场合。 购买链接：[淘宝](https://item.taobao.com/item.htm?id 710359411812) <img src \"./assets/m0p/m0p_module_outlook.png\" alt \"m0p_module_outlook\" width 15%> ## 模组特点 主芯片 BL618 RV32 320MHz RISC V 支持 2.4G WIFI6（IEEE 802.11 b/g/n/ax） 支持蓝牙 5.x 双模（BT+BLE） 支持 Zigbee / IEEE 802.15.4 支持 USB 2.0 HS OTG（480Mhz） 支持IPEX一代天线座子和 PCB 板载天线 板载 SPI FLASH（可选容量） 邮票孔引出所有 IO ## 模组参数 <table> <thead> <tr> <th colspan \"3\"> M0P 模组 </th> </tr> </thead> <tbody> <tr> <td rowspan \"18\" style \"white space:nowrap\">主控 BL618 处理器</td> </tr> <tr> <td colspan \"2\">RISC V CPUs：RV32 320MHz</td> </tr> <tr> <td colspan \"2\">SRAM: 480KB + 4MB </td> </tr> <tr> <td rowspan \"15\"> 支持接口 </td> </tr> <tr> <td>DVP Camera</td> </tr> <tr> <td>Display（QSPI、DBI）</td> </tr> <tr> <td>USB2.0 HS OTG(High Speed 480Mhz)</td> </tr> <tr> <td>SPI</td> </tr> <tr> <td>UART * 2</td> </tr> <tr> <td>IIC * 2</td> </tr> <tr> <td>IIS</td> </tr> <tr> <td>10bit GPDAC</td> </tr> <tr> <td>12~16bit GPADC</td> </tr> <tr> <td>ACOMP</td> </tr> <tr> <td>PWM</td> </tr> <tr> <td>SDIO2.0</td> </tr> <tr> <td>Audio Codec</td> </tr> <tr> <td>无线：<br>· 支持Wi Fi 802.11 b/g/n/ax（WiFi6）<br>· 支持蓝牙 5.x 双模(BT+BLE)<br>· 支持Wi Fi / 蓝牙/Zigbee 共存</td> </tr> <tr> <td rowspan \"3\" style \"white space:nowrap\"> 板载部件 </td> </tr> <tr> <td colspan \"2\">板载 SPI FLASH： 8MByte</td> </tr> <tr> <td colspan \"2\">支持 IPEX 一代天线座子和 PCB 板载天线</td> </tr> </tbody> <tr> <td rowspan \"5\" style \"white space:nowrap\"> 其他说明 </td> </tr> <tr> <td colspan \"2\"> 尺寸：25.5mm (L) x 18mm (W) </td> </tr> <tr> <td colspan \"2\"> KICAD 格式封装文件下载：<a href \"https://dl.sipeed.com/shareURL/Maix Zero/M0P/M0P/4_Package\">点击跳转</a> </td> </tr> <tr> <td colspan \"2\">温升: &lt;30K</td> </tr> <tr> <td colspan \"2\">工作温度范围: 10℃ ~ 65℃</td> </tr> </table> ## 尺寸大小 <img src \"./assets/m0p/m0p_size.png\" alt \"m0p_size\" width 35%> ## 引脚分布 前往原理图查看：[点我](https://dl.sipeed.com/shareURL/Maix Zero/M0P/M0P/2_Schematic) ## 软件描述 <table> <thead> <tr> <th colspan \"2\" > M0P 模组 </th> </tr> </thead> <tbody> <tr> <td>OS</td> <td> 支持FreeRTOS</td> </tr> <tr> <td>开发方式</td> <td>· 原生C SDK<br>· MaixHAL C 模块<br>· PikaPython </td> </tr> <tr> <td> SDK </td> <td><a href \"https://github.com/bouffalolab/bouffalo_sdk\"> github </a></td> </tr> <tr> <td>Examples</td> <td><a href \"https://github.com/sipeed/M0P_BL618_examples\"> github </a></td> </tr> </tbody> </table> ## 模组资料 [模组规格书](https://dl.sipeed.com/shareURL/Maix Zero/M0P/M0P/1_datasheet) [模组原理图](https://dl.sipeed.com/shareURL/Maix Zero/M0P/M0P/2_Schematic) [模组封装库](https://dl.sipeed.com/shareURL/Maix Zero/M0P/M0P/4_Package) [模组尺寸图](https://dl.sipeed.com/shareURL/Maix Zero/M0P/M0P/3_Dimensional_drawing) [博流官方文档](https://dev.bouffalolab.com/home/) [BL618 数据手册](https://gitee.com/wonderfullook/bl_docs/tree/main/BL616_DS/zh_CN) (gitee) [BL618 参考手册](https://gitee.com/wonderfullook/bl_docs/tree/main/BL616_RM/zh_CN) (gitee) [Sipeed Examples](https://github.com/sipeed/M0P_BL618_examples)（github） [Bouffalolab SDK](https://github.com/bouffalolab/bouffalo_sdk) (github) 交流 QQ 群：`816177882` 。[点我加群](https://jq.qq.com/?_wv 1027&k 4lroNFnI) 论坛：[bbs.sipeed.com](https://bbs.sipeed.com/) ## 注意事项 <table> <tr> <th>项目</th> <th>注意事项</th> </tr> <tr> <td>静电防护</td> <td>· 请注意避免静电打到 PCBA 上；接触 PCBA 之前请把手的静电释放掉<br>· 在底板设计时，必须要从 ESD 防护角度进行设计（串电阻、加 ESD 二极管等）</td> </tr> <tr> <td>容忍电压</td> <td> 所有 GPIO 都是 3.3V 电平，请不要让 GPIO 的实际工作的电压超过额定值，否则会引起 PCBA 的永久性损坏 </td> </tr> <tr> <td>避免短路</td> <td>请在上电过程中，避免任何液体和金属触碰到 PCBA 上的元件的焊盘，否则会导致短路，烧毁 PCBA</td> </tr> <tr> <td>BOOT 模式选择</td> <td> 在启动时，芯片判定 BOOT 引脚的电平，选择两个启动选项之一<br> · BOOT 低电平：从 FLASH 加载固件<br> · BOOT 高电平：进入 USB 下载模式 </td> </tr> </table> ## 联系方式 M0P 模组可以在多种场景实现客户不同方面的需要，技术支持和商业合作请联系使用邮箱 [support@sipeed.com](support@sipeed.com)"},"/hardware/zh/maixzero/m0p/m0p_dock.html":{"title":"M0P Dock","content":" title: M0P Dock keywords: M0P ,Dock, bl618, BL618 update: date: 2023 03 09 version: v0.1 author: wonder content: 初次编写文档 ## 板卡概述 Sipeed M0P Dock 是使用 [Sipeed M0P](https://wiki.sipeed.com//hardware/zh/maixzero/m0p/m0p.html) 模组设计的开发板，主控是 [博流智能科技](http://www.bouffalolab.com/) 的 BL618 芯片，支持 Wifi6 和蓝牙 5.2 无线协议，默认最高主频 320MHz，支持 USB2.0 HS。板卡上有 DVP 接口来连接摄像头，有 FPC 座子来连接屏幕，有 TF 卡槽来扩展存储，还有一颗 WMM7027ATSN1 MEMS 麦克风用于自定义功能，板卡上还有电池充电管理电路，支持使用锂电池供电。 购买链接：[淘宝](https://item.taobao.com/item.htm?id 710359411812) <img src \"./assets/m0p_dock/m0p_dock_outlook.png\" alt \"m0p_dock_outlook\" width 15%> ## 板卡特点 主芯片 BL618 RV32 320MHz RISC V 支持 2.4G WIFI6（IEEE 802.11 b/g/n/ax） 支持蓝牙 5.x 双模（BT+BLE）和 Zigbee / IEEE 802.15.4 USB 2.0 Type C（480Mhz）（可用作下载固件和USB转串口） DVP 摄像头连接器 SPI 屏幕连接器（可以连接3.92寸320x320方形电容触摸屏） 4.2V 锂电池充电电路 1 个 TF 卡连接器（SDIO接口） 1 个模拟麦克风、2 个 ADC 按键和 1 个状态指示灯 ## 板卡参数 <table> <tbody> <tr> <th colspan \"3\" style \"white space:nowrap\"> M0P Dock 参数 </td> </tr> <tr> <td rowspan \"18\" style \"white space:nowrap\"> M0P 模组 </td> </tr> <tr> <td colspan \"2\"> RISC V CPUs：RV32 320MHz </td> </tr> <tr> <td colspan \"2\"> SRAM: 480KB + 4MB </td> </tr> <tr> <td rowspan \"15\"> 支持接口 </td> </tr> <tr> <td>DVP Camera</td> </tr> <tr> <td>Display（QSPI、DBI）</td> </tr> <tr> <td>USB2.0 HS OTG(High Speed 480Mhz)</td> </tr> <tr> <td>SPI</td> </tr> <tr> <td>UART * 2</td> </tr> <tr> <td>IIC * 2</td> </tr> <tr> <td>IIS</td> </tr> <tr> <td>10bit GPDAC</td> </tr> <tr> <td>12~16bit GPADC</td> </tr> <tr> <td>ACOMP</td> </tr> <tr> <td>PWM</td> </tr> <tr> <td>SDIO2.0</td> </tr> <tr> <td>Audio Codec</td> </tr> <tr> <td> 无线：<br>· 支持Wi Fi 802.11 b/g/n/ax（WiFi6）<br>· 支持蓝牙 5.x 双模(BT+BLE)<br>· 支持Wi Fi / 蓝牙/ Zigbee 共存<br>（更详细的特性请查看芯片 <a href \"https://gitee.com/wonderfullook/bl_docs/tree/main/BL616_DS/zh_CN\"> datasheet</a>）</td> </tr> </td> </tr> <tr> <td colspan \"1\" rowspan \"11\" style \"white space:nowrap\"> 板载部件 </td> </tr> <tr> <td colspan \"2\">USB2.0 Type C 母座连接器: <br> 可用作USB通信、下载固件和USB转串口</td> </tr> <tr> <td colspan \"2\">DVP 摄像头连接器：<br> 通用接口，可以连接 GC0328 摄像头模组</td> </tr> <tr> <td colspan \"2\">SPI 屏幕连接器：<br>可以连接 3.92 寸 320x320 方形电容触摸屏</td> </tr> <tr> <td colspan \"2\">SPI FLASH（默认8MByte）</td> </tr> <tr> <td colspan \"2\">1 个 TF 卡连接器（SDIO接口）</td> </tr> <tr> <td colspan \"2\">1 个模拟麦克风：WMM7027ATSN1（全指向，灵敏度 38dB，信噪比 59dB ）</td> </tr> <tr> <td colspan \"2\">2 个 ADC 按键（在板子两侧）</td> </tr> <tr> <td colspan \"2\">1 个电源指示灯和 1 个状态指示灯</td> </tr> <tr> <td colspan \"2\">两侧排针引出所有 IO（出厂已经焊接好排针）</td> </tr> <tr> <td colspan \"2\">4.2V 锂电池充电电路：<br>· USB 给整板供电，整板给电池供电，电池与整板主电源之间有二极管防倒灌<br>· 电池电压低于 3.3V 时 BL618 芯片会被强制处于复位状态<br>· 只支持最大电压是 4.2V 的可充电锂电池，不支持最大电压小于 4.2V 的可充电锂电池及不可充电的电池</td> </tr> </tbody> </tbody> </table> ## 引脚分布 ![m0p_dock_pinmap](./assets/m0p_dock/m0p_dock_pinmap.png) ## 产品对比 M0P Dock ESP32 S3 DevKitC MCU 单核320Mhz RISC V 双核240Mhz SRAM 480KB + 4MB 512KB + 2MB(optional) ROM √ √ SPI Nor Flash 8MB(optional) 8MB(optional) WIFI IEEE 802.11 b/g/n/ax (WiFi6) IEEE 802.11 b/g/n BLE √ √ I2C/UART/SPI √ √ Microphone 模拟麦克风 × LCD 支持 3.92 英寸电容触摸屏 × Camera DVP camera × USB USB 2.0 High speed OTG（480Mbps） USB 2.0 Full speed OTG（12Mbps） 固件下载方式 USB USB ## 软件描述 <table> <thead> <tr> <th colspan \"2\" > M0P 模组 </th> </tr> </thead> <tbody> <tr> <td>OS</td> <td> 支持FreeRTOS</td> </tr> <tr> <td>开发方式</td> <td>· 原生C SDK<br>· MaixHAL C 模块<br>· PikaPython </td> </tr> <tr> <td> SDK </td> <td><a href \"https://github.com/bouffalolab/bouffalo_sdk\"> github </a></td> </tr> <tr> <td>Examples</td> <td><a href \"https://github.com/sipeed/M0P_BL618_examples\"> github </a></td> </tr> </tbody> </table> ## 板卡资料 [板卡规格书](https://dl.sipeed.com/shareURL/Maix Zero/M0P/M0P%20Dock/1_datasheet) [板卡原理图](https://dl.sipeed.com/shareURL/Maix Zero/M0P/M0P%20Dock/2_Schematic) [板卡尺寸图](https://dl.sipeed.com/shareURL/Maix Zero/M0P/M0P%20Dock/4_Dimensional_drawing) [板卡位号图](https://dl.sipeed.com/shareURL/Maix Zero/M0P/M0P%20Dock/3_Bit_number_map) [3D 模型文件](https://dl.sipeed.com/shareURL/Maix Zero/M0P/M0P%20Dock/5_3D_File) [博流官方文档](https://dev.bouffalolab.com/home/) [BL618 数据手册](https://gitee.com/wonderfullook/bl_docs/tree/main/BL616_DS/zh_CN) (gitee) [BL618 参考手册](https://gitee.com/wonderfullook/bl_docs/tree/main/BL616_RM/zh_CN) (gitee) [Sipeed Examples](https://github.com/sipeed/M0P_BL618_examples)（github） [Bouffalolab SDK](https://github.com/bouffalolab/bouffalo_sdk) (github) 交流 QQ 群：`816177882` 。[点我加群](https://jq.qq.com/?_wv 1027&k 4lroNFnI) 论坛：[bbs.sipeed.com](https://bbs.sipeed.com/) ## 注意事项 <table> <tr> <th>项目</th> <th>注意事项</th> </tr> <tr> <td>静电防护</td> <td>· 请注意避免静电打到 PCBA 上；接触 PCBA 之前请把手的静电释放掉 </td> </tr> <tr> <td>容忍电压</td> <td> 所有 GPIO 都是 3.3V 电平，请不要让 GPIO 的实际工作的电压超过额定值，否则会引起 PCBA 的永久性损坏 </td> </tr> <tr> <td>避免短路</td> <td>请在上电过程中，避免任何液体和金属触碰到 PCBA 上的元件的焊盘，否则会导致短路，烧毁 PCBA</td> </tr> <tr> <td>FPC 座子</td> <td>在连接 FPC 软排线的时候，请确保排线无偏移地完整地插入到排线中</td> </tr> <tr> <td>BOOT 模式选择</td> <td> 在启动时，芯片判定 BOOT 引脚的电平，选择两个启动选项之一<br> · BOOT 低电平：从 FLASH 加载固件<br> · BOOT 高电平：进入 USB 下载模式 </td> </tr> </table> ## 联系方式 M0P Dock 开发板可以在多种场景实现客户不同方面的需要，技术支持和商业合作请联系使用邮箱 [support@sipeed.com](support@sipeed.com)"},"/hardware/zh/maixzero/m0s/m0s.html":{"title":"M0S 模块","content":" title: M0S 模块 keywords: M0S, 模块, BL616, wifi6 update: date: 2023 01 13 version: v0.1 author: wonder content: 初次编写文档 ## 模块概述 Sipeed M0S 模块是基于[博流智能科技](http://www.bouffalolab.com/)的 BL616 芯片所设计的一款适用于超低功耗应用 IOT 模块，支持 Wifi6、蓝牙 5.2 和 zigbee 等无线协议，默认最高主频 320MHz，模块极小的封装体积和芯片多种低功耗模式和多种唤醒源满足不同的低功耗场景。 购买链接：[淘宝](https://item.taobao.com/item.htm?id 697403593463) <img src \"./assets/m0s/m0s_module_outlook.png\" alt \"m0s_module_outlook\" width 35%> ## 模块特点 无线三模一体： WiFi6 / 蓝牙 5.2 / Zigbee 高主频：默认最高 320MHz 低功耗：WiFi6 低功耗特性 DSP 加速：支持 RISC V P 扩展指令集，可在 TinyMaix 推理框架中获得近一倍加速 高速 USB：支持 USB2.0 HS OTG， 高达 480Mbps 丰富外设接口：支持 RGB LCD，DVP Camera，以太网 RMII，SDIO 等 小体积：10mmx11mm 面积上集成了陶瓷天线，并全引脚引出 ## 模块参数 <table> <thead> <tr> <th colspan \"2\" > M0S 模块 </th> </tr> </thead> <tbody> <tr> <td rowspan \"5\" style \"white space:nowrap\">主控 BL616 处理器</td> </tr> <tr> <td>RISC V CPU：默认 RV32GCP@320MHz </td> </tr> <tr> <td>内置 480KB SRAM + 4MB Flash</td> </tr> <tr> <td>无线：<br> 支持 Wi Fi6<br> 支持 Bluetooth 5.2 Dual mode(BT+BLE)<br> 支持 Zigbee </td> </tr> <tr> <td>USB 2.0 HS OTG</td> </tr> <tr> <td rowspan \"2\" style \"white space:nowrap\"> 板载部件 </td> </tr> <tr> <td>陶瓷天线</td> </tr> </tbody> <tr> <td rowspan \"4\" style \"white space:nowrap\"> 其他说明 </td> </tr> <tr> <td> 尺寸：10mm (W) x 11mm (H) </td> </tr> <tr> <td> 封装库文件 (KiCAD)：<a href \"https://dl.sipeed.com/shareURL/Maix Zero/M0S/M0S/4_Package\">点击跳转</a> </td> </tr> <tr> <td> 3D 模型文件下载：<a href \"https://dl.sipeed.com/shareURL/Maix Zero/M0S/M0S/3_3D_file\">点击跳转</a> </td> </tr> </tbody> </table> ## 引脚分布 ![m0s_pin_map](./assets/m0s/m0s_pin_map.png) ## 产品对比 型号 M0S 模块 ESP32 S3 N4 模块 : : : : 主控 BL616(RV32GCP) ESP32 S3 (LX7) 频率 320MHz 240MHz SRAM 480KB 520KB Flash 4MByte 4MByte Wifi WiFi6 WiFi4 蓝牙 BT5.2 BT5 USB USB2.0 HS OTG 480Mbps USB2.0 FS OTG 12Mbps IIC/UART/SPI 有 有 DVP Camera Yes Yes 尺寸 10mm x 11mm 18mm x 25.5mm 模型平台 TinyMaix + MaixHub ## 配套底板 <table> <thead> <tr> <th colspan \"2\" > M0S Dock </th> </tr> </thead> <tbody> <tr> <td> 核心 x 1 </td> <td> M0S 模块 </td> </tr> <tr> <td> 按键 x 1 </td> <td> 按住按键后给板子通电来烧录板卡 </td> </tr> <tr> <td> LED x 3 </td> <td> 一个电源 LED，两个用户自定义 LED </td> </tr> <tr> <td> TypeC 接口 x 1 </td> <td> 用来下载固件或实现其他 USB 功能 </td> </tr> <tr> <td> 外接 IO x 10 </td> <td> 八个引出到排针<br> 两个位于 TypeC 接口旁边 </td> </tr> <tr> <td> 原理图 </td> <td> <a href \"https://dl.sipeed.com/shareURL/Maix Zero/M0S/M0S_Dock/2_Schematic\"> 点我 </a></td> </tr> </tbody> </table> <img src \"./assets/m0s/m0s_dock_top.png\" width \"45%\"> <img src \"./assets/m0s/m0s_dock_bottom.png\" width \"45%\"> ## 软件描述 <table> <thead> <tr> <th colspan \"2\" > M0S 模块 </th> </tr> </thead> <tbody> <tr> <td>OS</td> <td>· 完备支持FreeRTOS </td> </tr> <tr> <td>开发方式</td> <td>· 原生C SDK<br>· MaixHAL C 模块<br>· PikaPython </td> </tr> <tr> <td>固件下载</td> <td>· 串口下载<br>· USB 下载</td> </tr> <tr> <td>AI 推理框架</td> <td>· TinyMaix 推理框架</td> </tr> <tr> <td>AI 模型下载</td> <td>· <a href \"https://maixhub.com/\"> MaixHub </td> </tr> <tr> <td>Sipeed 参考示例</td> <td>· https://github.com/sipeed/M0S_BL616_example</td> </tr> </tbody> </table> ## 相关资料 [M0S 规格书](https://dl.sipeed.com/shareURL/Maix Zero/M0S/M0S/1_Specification) [M0S 原理图](https://dl.sipeed.com/shareURL/Maix Zero/M0S/M0S/2_Schematic) [M0S 封装库](https://dl.sipeed.com/shareURL/Maix Zero/M0S/M0S/4_Package) [3D 模型文件](https://dl.sipeed.com/shareURL/Maix Zero/M0S/M0S/3_3D_file) [博流官方文档](https://dev.bouffalolab.com/home/) [BL616 数据手册](https://gitee.com/wonderfullook/bl_docs/tree/main/BL616_DS/zh_CN) (gitee) [BL616 参考手册](https://gitee.com/wonderfullook/bl_docs/tree/main/BL616_RM/zh_CN) (gitee) [M0S Dock 规格书](https://dl.sipeed.com/shareURL/Maix Zero/M0S/M0S_Dock/1_Specification) [M0S Dock 原理图](https://dl.sipeed.com/shareURL/Maix Zero/M0S/M0S_Dock/2_Schematic) [Sipeed Examples](https://github.com/sipeed/M0s_BL616_example)（github） [Bouffalolab SDK](https://github.com/bouffalolab/bouffalo_sdk) (github) SDK 使用指南: https://bl mcu sdk.readthedocs.io/zh_CN/latest/index.html 交流 QQ 群：`816177882` 。[点我加群](https://jq.qq.com/?_wv 1027&k CSnLIADN) 论坛：[bbs.sipeed.com](https://bbs.sipeed.com/) ## 注意事项 <table> <tr> <th>项目</th> <th>注意事项</th> </tr> <tr> <td>静电防护</td> <td>请避免静电打到 PCBA 上；接触 PCBA 之前请把手的静电释放掉</td> </tr> <tr> <td>容忍电压</td> <td>请不要让 GPIO 的实际工作的电压超过额定值，否则会引起 PCBA 的永久性损坏 </td> </tr> <tr> <td>插拔</td> <td>请完全断电后才进行插拔操作</td> </tr> <tr> <td>避免短路</td> <td>请在上电过程中，避免任何液体和金属触碰到 PCBA 上的元件的焊盘，否则会导致路，烧毁 PCBA</td> </tr> </table> ## 联系方式 M0S 模块可以在多种场景实现客户不同方面的需要，技术支持和商业合作请联系使用邮箱 [support@sipeed.com](support@sipeed.com)"},"/hardware/zh/maixzero/m0s/start.html":{"title":"M0S Dock","content":" title: M0S Dock keywords: M0S, 模块, BL616, wifi6 update: date: 2023 01 15 version: v0.1 author: wonder content: 初次编写文档 我们可以将 M0S Dock 当成小型开发板使用，这里以点灯教程来示范相关 SDK 的使用方法。 > M0S Dock 应当在 Linux 环境下进行开发，下面的操作均为在 ubuntu 中完成 ## 软件准备 ### 编译固件所需要的系统软件 ```bash sudo apt get install cmake git ``` ### 烧录固件所需要的软件 前往 https://dev.bouffalolab.com/download 下载名称为 `Bouffalo Lab Dev Cube` 的文件。解压后就得到了用来烧录板子的应用程序。 ![bouffalo_cube](./../../maix/m1s/other/assets/start/bouffalo_cube.png) 解压后的文件夹中主要关注 `BLDevCube`、 `BLDevCube macos` 和 `BLDevCube ubuntu` 三个文件，用于在不同系统启动这个图形化烧录工具。 ![application](./../../maix/m1s/other/assets/start/application.png) ## SDK 获取 ``` ```"},"/hardware/zh/tang/Tang-Nano-1K/examples/LCD.html":{"title":"RGB LCD 示例","content":" title: RGB LCD 示例 > 编辑于2022年3月30日 ## 先介绍时序 RGB LCD 显示协议和 VGA 类似，通信都有专用的行同步、场同步信号线。它们的主要区别是前者传输用的是数字信号，后者传输走的是模拟信号。 下面就介绍 VGA 的时序 ![](./../../assets/examples/lcd_pjt_1.png) 上图分别是 VGA 在数据传输中的行同步、场同步时序 从时序图中可以看出，不论是显示一行数据还是一列数据，都需要一个对应的同步(sync)信号，数据的传输在两个同步信号的脉冲之间完成 每一行的数据包括显示前沿(back porch)、有效数据(active video)、显示后沿(front porch)三个阶段 其中的有效数据就是我们常说的分辨率，而显示前后沿的参数需要参考具体的分辨率与帧数进行设置，相关参数可以参考典型参数，链接在此： http://www.tinyvga.com/vga timing 这块5寸屏幕的控制时序略有不同，相关参数的设置可以查看[规格书](https://dl.sipeed.com/fileList/TANG/Nano%209K/6_Chip_Manual/CN/LCD_Datasheet/5.0inch_LCD_Datashet%20RGB.pdf) 其他尺寸的屏幕相关规格书均可以在这里下载 [点我](https://dl.sipeed.com/shareURL/TANG/Nano%209K/6_Chip_Manual/CN/LCD_Datasheet) 下面为这块 LCD 时序相关的截图 ![](./../../assets/examples/lcd_pjt_2.png) ![](./../../assets/examples/lcd_pjt_3.png) 上面一张图是时序中的参数表，下面的图是时序图 从时序图中看出，这块屏幕可以不用设置前后沿，可以只设置消影(blanking)时间，通过实际的程序证明，两种方式都是可以的 ## 新建工程 新建工程方法参考[自建点灯文章(点我)](./led/self_create.html) ## 生成屏幕时钟 这里需要用到高云半导体官方的IP核 ### pll 板载的晶振时钟为 27MHz ，但是我们的屏幕要求 33.3MHZ 的时钟，所以我们需要使用相应的ip核来生成需要的时钟 这里需要使用到 `IP Core Generate` ，位置在 Tools > IP Core Generate ![](./../assets/Gowin_IP_rpll.png) 双击 `rpll` ，在弹出窗口 language 选择 Verilog ，CLKIN 为 27MHz ，CLKOUT 为 33.00MHz。 ![](./../assets/lcd_rpll.png) 点击ok后提示是否需要添加到当前工程，此时应当选择确定 ![](./led/assets/add_ip_file_in_project.png) 接着会出现一个例化的tmp文件，用来例化所设置的ip。比如下图中例子 ![](./../../Tang Nano/examples/led/assets/ip_examples.png) ## 屏幕驱动代码 **首先新建一个额外的verilog文件来保存下面要编写的代码** ### 端口定义 首先需要先定义出驱动屏幕所需要的端口 ```verilog module VGAMod ( input CLK, input nRST, input PixelClk, output LCD_DE, output LCD_HSYNC, output LCD_VSYNC, \toutput [4:0] LCD_B, \toutput [5:0] LCD_G, \toutput [4:0] LCD_R ); ``` 本例程使用RGB565作为驱动方式； ### 时序常量 接着定义出时序图上所要求的常量 ```verilog localparam V_BackPorch 16'd6; //0 or 45 localparam V_Pluse \t 16'd5; localparam HightPixel 16'd480; localparam V_FrontPorch 16'd62; //45 or 0 localparam H_BackPorch 16'd182; \t localparam H_Pluse \t 16'd1; localparam WidthPixel 16'd800; localparam H_FrontPorch 16'd210; localparam PixelForHS WidthPixel + H_BackPorch + H_FrontPorch; \t localparam LineForVS HightPixel + V_BackPorch + V_FrontPorch; ``` 首先是设置时序相关的参数：前沿、后沿、有效像素 关于显示前沿、后沿，前面也说了，可以合并为一个消影时间，就是可以把其中一个设置为0，另一个设置为消影时间。反正前后沿的时间加起来符合表中的时间要求就可以 ### 计数变量 定义一些变量能够容易编写程序 ```verilog reg [15:0] LineCount; reg [15:0] PixelCount; reg\t[9:0] Data_R; reg\t[9:0] Data_G; reg\t[9:0] Data_B; ``` ### 同步信号 这段代码产生同步信号，需要注意的是，这块屏幕的同步信号是负极性使能 ```verilog always @( posedge PixelClk or negedge nRST )begin if( !nRST ) begin LineCount < 16'b0; PixelCount < 16'b0; end else if( PixelCount PixelForHS ) begin PixelCount < 16'b0; LineCount < LineCount + 1'b1; end else if( LineCount LineForVS ) begin LineCount < 16'b0; PixelCount < 16'b0; end else PixelCount < PixelCount + 1'b1; end always @( posedge PixelClk or negedge nRST )begin if( !nRST ) begin \t\t\tData_R < 9'b0; \t\t\tData_G < 9'b0; \t\t\tData_B < 9'b0; end else begin \t\t\tend \tend //注意这里HSYNC和VSYNC负极性 assign LCD_HSYNC (( PixelCount > H_Pluse)&&( PixelCount < (PixelForHS H_FrontPorch))) ? 1'b0 : 1'b1; assign LCD_VSYNC ((( LineCount > V_Pluse )&&( LineCount < (LineForVS 0) )) ) ? 1'b0 : 1'b1; ``` ### 使能信号 这段代码设置 LCD 使能图像显示，这块屏幕需要控制一个管脚用作显示开关，实际这个信号就是传输图像有效的那 800*480 的数据时置 1 ```verilog assign LCD_DE ( ( PixelCount > H_BackPorch )&& ( PixelCount < PixelForHS H_FrontPorch ) && ( LineCount > V_BackPorch ) && ( LineCount < LineForVS V_FrontPorch 1 )) ? 1'b1 : 1'b0; //这里不减一，会抖动 ``` ### 测试彩条 这段代码用来产生 LCD 的测试数据，产生彩条显示 ```verilog localparam Colorbar_width WidthPixel / 16; assign LCD_R ( PixelCount < ( H_BackPorch + Colorbar_width * 0 )) ? 5'b00000 : ( PixelCount < ( H_BackPorch + Colorbar_width * 1 )) ? 5'b00001 : ( PixelCount < ( H_BackPorch + Colorbar_width * 2 )) ? 5'b00010 : ( PixelCount < ( H_BackPorch + Colorbar_width * 3 )) ? 5'b00100 : ( PixelCount < ( H_BackPorch + Colorbar_width * 4 )) ? 5'b01000 : ( PixelCount < ( H_BackPorch + Colorbar_width * 5 )) ? 5'b10000 : 5'b00000; assign LCD_G ( PixelCount < ( H_BackPorch + Colorbar_width * 6 )) ? 6'b000001: ( PixelCount < ( H_BackPorch + Colorbar_width * 7 )) ? 6'b000010: ( PixelCount < ( H_BackPorch + Colorbar_width * 8 )) ? 6'b000100: ( PixelCount < ( H_BackPorch + Colorbar_width * 9 )) ? 6'b001000: ( PixelCount < ( H_BackPorch + Colorbar_width * 10 )) ? 6'b010000: ( PixelCount < ( H_BackPorch + Colorbar_width * 11 )) ? 6'b100000: 6'b000000; assign LCD_B ( PixelCount < ( H_BackPorch + Colorbar_width * 12 )) ? 5'b00001 : ( PixelCount < ( H_BackPorch + Colorbar_width * 13 )) ? 5'b00010 : ( PixelCount < ( H_BackPorch + Colorbar_width * 14 )) ? 5'b00100 : ( PixelCount < ( H_BackPorch + Colorbar_width * 15 )) ? 5'b01000 : ( PixelCount < ( H_BackPorch + Colorbar_width * 16 )) ? 5'b10000 : 5'b00000; ``` **当然在最后的驱动文件最后别忘记换行加上 endmodule** 到这里驱动模块的编写已经完成了。 ## 在顶层模块中例化 **这里也是要新建文件的** ```verilog module TOP //设置顶层模块 ( \tinput\t\t\tnRST, input XTAL_IN, \toutput\t\t\tLCD_CLK, \toutput\t\t\tLCD_HYNC, \toutput\t\t\tLCD_SYNC, \toutput\t\t\tLCD_DEN, \toutput\t[4:0]\tLCD_R, \toutput\t[5:0]\tLCD_G, \toutput\t[4:0]\tLCD_B ); // 罗列需要的端口 \twire\t\tCLK_SYS;\t \twire\t\tCLK_PIX; //例化pll Gowin_rPLL chip_pll( .clkout(CLK_SYS), //output clkout //200M .clkoutd(CLK_PIX), //output clkoutd //33.00M .clkin(XTAL_IN) //input clkin );\t \tVGAMod\tVGAMod_inst //例化vga驱动 \t( \t\t.CLK\t\t(\tCLK_SYS ), \t\t.nRST\t\t(\tnRST\t\t), \t\t.PixelClk\t(\tCLK_PIX\t\t), \t\t.LCD_DE\t\t(\tLCD_DEN\t \t), \t\t.LCD_HSYNC\t(\tLCD_HYNC \t), \t.LCD_VSYNC\t(\tLCD_SYNC \t), \t\t.LCD_B\t\t(\tLCD_B\t\t), \t\t.LCD_G\t\t(\tLCD_G\t\t), \t\t.LCD_R\t\t(\tLCD_R\t\t) \t); \tassign\t\tLCD_CLK\t\t \tCLK_PIX; endmodule ``` ## 综合、约束、布局布线 ### 综合 完成上面步骤后转到“Process”界面下，对编辑好的代码进行综合，即运行“Synthesize” ![](./../../Tang Nano 9K/nano_9k/nano_9k_synthsize.png) 运行的结果如下图出现 ![](./../../Tang Nano/assets/LED.png) 且下方结果栏不出现任何从报错，说明前面编辑的代码无误，如果有错，根据错误提示进行改正即可。 ### 约束 此处仅管脚约束 对应的管脚约束如下表格； 关于管脚约束可以参考[自建点灯文章(点我)](./led/self_create.html)里面的约束方法 如果感觉麻烦的话也可以直接复制准备好的[文件(点我)](./lcd_constrains.html)，将页面里的内容复制到工程目录里 .cst 文件中（如果没有.cst 文件那么自己新建一个）**物理管脚约束文件** 即可。 PORT PIN PORT PIN : : : : : : : : LED_B 10 LED_G 11 LED_R 9 LCD_B[4] 24 LCD_B[3] 23 LCD_B[2] 22 LCD_B[1] 20 LCD_B[0] 19 LCD_G[5] 18 LCD_G[4] 17 LCD_G[3] 16 LCD_G[2] 15 LCD_G[1] 27 LCD_G[0] 28 LCD_R[4] 29 LCD_R[3] 30 LCD_R[2] 31 LCD_R[1] 34 LCD_R[0] 35 LCD_DEN 21 LCD_SYNC 32 LCD_HYNC 33 LCD_CLK 8 XTAL_IN 47 nRST 44 ### 布局布线 管脚约束之后需要在设置里面开启引脚复用才能完成布局布线。 具体位置在 软件顶部菜单栏 Project > Configuration > Place&Route > Dual Purpose Pin ![](./led/assets/enable_io_mux.png) 设置完上面的之后。 就可以开始布局布线(Place&Route)了。 完成后就可以给开发板验证代码内容了。 ## 烧录 布局布线结束后生成比特流，就可以烧录开发板了。 ## 结束 上面差不多叙述了所需要的代码。 整个工程可以参考 [这里](https://github.com/sipeed/TangNano 1K examples/tree/main/example_lcd/) <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano-1K/examples/led/github_sourcecode.html":{"title":"使用github例程","content":" title: 使用github例程 首先获得仓库文件 https://github.com/sipeed/TangNano 1K examples 打开 TangNano 1K examples\\example_led\\led_prj 目录下的 led_prj.gprj 文件 在process界面直接双击 Place&Route ![](./assets/github_nano1K_place&route.png) 然后是进行连接板子，烧录固件。在Process界面双击`Program Device` 后打开烧录工具 ![](./assets/Open_Programmer_nano_1k.png) 接下来选择sram烧录即可验证程序。 ![](./assets/Success_led_nano_1k.png) <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano-1K/examples/led/self_create.html":{"title":"点灯LED RGB","content":" title: 点灯LED RGB > 编辑于2022年4月13日 ## 新建项目 新建工程：File >NEW >FPGA Design Project >OK ![](./../../../Tang Nano/assets/LED 1.png) 弹出的选项框选择存储路径和工程名称（路径和文件名称要求是英文路径） ![](./../../../Tang Nano/assets/LED 2.png) 选择对应的型号： ![Tang_nano_1k_device_choose](./../../assets/Nano_1K_device_choose.png) ## 编写代码 新建工程之后接下来进行代码编辑，在Design工作栏内新建“Verilog File”,如下图所示： ![](./../../../Tang Nano/assets/LED 5.png) 为文件命名（要求写英文名，不然后续综合很容易报错）； 一般来说文件名称应该和文件内容模块名称相同 ![](./../../../Tang Nano/assets/LED 6.png) 双击文件，可以在右侧的编辑框中进行代码的编写。 ![](./../../../Tang Nano/assets/LED 7.png) 以流水灯为例，将下方的“LED例程代码”粘贴到自己的文件中，也可以自己编写自己的代码。 ```verilog module led ( input sys_clk, // clk input input sys_rst_n, // reset input output reg [2:0] led // 110 B, 101 G,001 R ); reg [23:0] counter; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) counter < 24'd0; else if (counter < 24'd1349_9999) // 0.5s delay counter < counter + 1'b1; else counter < 24'd0; end always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) led < 3'b110; else if (counter 24'd1349_9999) // 0.5s delay led[2:0] < {led[1:0],led[2]}; else led < led; end endmodule ``` ## 综合、约束、布局布线 ### 综合 保存编辑的代码后转到“Process”界面下，对编辑好的代码进行综合，即双击“Synthesize” ![](./../../../Tang Nano 9K/nano_9k/nano_9k_synthsize.png) 运行之后如没有报错而且 Synthesize 变成下图里的图标 ![](./../../../Tang Nano/assets/LED.png) 说明前面编辑的代码无误；如果有错，根据错误提示进行改正即可。 ### 约束 此处未涉及时钟约束 想让 Fpga 实现代码的功能，必须将代码中涉及的 端口 绑定到 Fpga 实际的引脚上。 如下图，在左边的工作区点击 process，然后双击 FloorPlanner ![](./../../assets/examples/led_pjt_2.png) 在工程中第一次点击，可能会提示创建文件，点击确定即可 ![](./../../../Tang Nano/assets/LED 9.png) nano 1k的rgb led电路图如下所示 ![](./../../assets/Nano_1K_RGB_pins.png \"nano 1k rgb pins\") 对于交互式管脚约束有下图中的两种方法 将对应的端口拖拽到芯片引脚上 在IO约束中输入端口对应的引脚编号 因此在打开的界面中按照序号的顺序来进行相应的操作（两种方式选择一种即可） ![](./../../assets/RGB_LED_Constrains.png) 关于 FloorPlanner 更多的相关说明，可以参考 [SUG935 1.3_Gowin设计物理约束用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG935 1.3_Gowin%E8%AE%BE%E8%AE%A1%E7%89%A9%E7%90%86%E7%BA%A6%E6%9D%9F%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf)。里面的内容都很有用 **完成约束后记得保存~** ### 布局布线 到“Process”下运行“Place&Route”，即运行管脚布局布线，运行结果如下图所示： ![](./../../assets/RGB_LED_Place&Route.png) 如果没有成功运行，那自己修修。 ## 烧录 成功完成上面步骤后就已经生成高云半导体的比特流文件了，可以进行下面的步骤来将文件烧录到板子了。 接下来是连接板子，烧录固件。在Process界面双击`Program Device` 后打开烧录工具 ![](./../../assets/Open_Programmer.png) 可以从下面的图中选择烧录模式；再此以烧录到SRAM作为示例 ![](./../../../Tang Nano/examples/led/assets/tang nano programmer config.png) 接下来选择运行即可验证程序。有固化需求的自行选择下载到flash即可。 点灯验证到此结束。 <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano-1K/examples/led/lcd_constrains.html":{"title":"","content":" title: LCD 约束文件内容 ``` IO_LOC \"LED_B\" 10; IO_PORT \"LED_B\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LED_G\" 11; IO_PORT \"LED_G\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LED_R\" 9; IO_PORT \"LED_R\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[4]\" 24; IO_PORT \"LCD_B[4]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[3]\" 23; IO_PORT \"LCD_B[3]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[2]\" 22; IO_PORT \"LCD_B[2]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[1]\" 20; IO_PORT \"LCD_B[1]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[0]\" 19; IO_PORT \"LCD_B[0]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[5]\" 18; IO_PORT \"LCD_G[5]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[4]\" 17; IO_PORT \"LCD_G[4]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[3]\" 16; IO_PORT \"LCD_G[3]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[2]\" 15; IO_PORT \"LCD_G[2]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[1]\" 27; IO_PORT \"LCD_G[1]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[0]\" 28; IO_PORT \"LCD_G[0]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[4]\" 29; IO_PORT \"LCD_R[4]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[3]\" 30; IO_PORT \"LCD_R[3]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[2]\" 31; IO_PORT \"LCD_R[2]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[1]\" 34; IO_PORT \"LCD_R[1]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[0]\" 35; IO_PORT \"LCD_R[0]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_DEN\" 21; IO_PORT \"LCD_DEN\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_SYNC\" 32; IO_PORT \"LCD_SYNC\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_HYNC\" 33; IO_PORT \"LCD_HYNC\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_CLK\" 8; IO_PORT \"LCD_CLK\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"XTAL_IN\" 47; IO_PORT \"XTAL_IN\" IO_TYPE LVCMOS33 PULL_MODE UP; IO_LOC \"nRST\" 44; IO_PORT \"nRST\" IO_TYPE LVCMOS33 PULL_MODE UP; IO_LOC \"KEY\" 13; IO_PORT \"KEY\" IO_TYPE LVCMOS33 PULL_MODE UP; ```"},"/hardware/zh/tang/Tang-Nano-1K/examples/LED.html":{"title":"点灯","content":"# 点灯 > 编辑于2022年3月29日 ## 前言 此处提供两种方法点灯 对于文章中有什么疑问或者错误的地方欢迎到 [论坛](https://bbs.sipeed.com) 或 QQ群 提出 [使用github仓库](./led/github_sourcecode.html) [自己新建项目](./led/self_create.html) <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano-1K/examples/lcd_constrains.html":{"title":"LCD constrain file content","content":" title: LCD constrain file content <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">Previous page</a> </p> ```cst IO_LOC \"LCD_B[4]\" 24; IO_PORT \"LCD_B[4]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[3]\" 23; IO_PORT \"LCD_B[3]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[2]\" 22; IO_PORT \"LCD_B[2]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[1]\" 20; IO_PORT \"LCD_B[1]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[0]\" 19; IO_PORT \"LCD_B[0]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[5]\" 18; IO_PORT \"LCD_G[5]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[4]\" 17; IO_PORT \"LCD_G[4]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[3]\" 16; IO_PORT \"LCD_G[3]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[2]\" 15; IO_PORT \"LCD_G[2]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[1]\" 27; IO_PORT \"LCD_G[1]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[0]\" 28; IO_PORT \"LCD_G[0]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[4]\" 29; IO_PORT \"LCD_R[4]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[3]\" 30; IO_PORT \"LCD_R[3]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[2]\" 31; IO_PORT \"LCD_R[2]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[1]\" 34; IO_PORT \"LCD_R[1]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[0]\" 35; IO_PORT \"LCD_R[0]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_DEN\" 21; IO_PORT \"LCD_DEN\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_SYNC\" 32; IO_PORT \"LCD_SYNC\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_HYNC\" 33; IO_PORT \"LCD_HYNC\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_CLK\" 8; IO_PORT \"LCD_CLK\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"XTAL_IN\" 47; IO_PORT \"XTAL_IN\" IO_TYPE LVCMOS33 PULL_MODE UP; IO_LOC \"nRST\" 44; IO_PORT \"nRST\" IO_TYPE LVCMOS33 PULL_MODE UP; ``` <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano-1K/Tang-nano-1k.html":{"title":"Tang nano 1k 一些例程","content":" title: Tang nano 1k 一些例程 对于Programmer(下载程序)建议使用 https://dl.sipeed.com/shareURL/TANG/programmer 里面的文件。 下载后解压替换掉Gowin对应安装目录的Programmer文件夹即可。 不会替换的话可以在下载解压后的Programmer程序中手动添加对应下载文件来进行烧录。 [点灯例程](./examples/LED.html) [驱屏教程](./examples/LCD.html)"},"/hardware/zh/tang/Tang-Nano-1K/Nano-1k.html":{"title":"Tang Nano 1K","content":"# Tang Nano 1K ## 概述 Tang Nano 1K 是基于高云半导体的小蜜蜂系列 GW1NZ LV1 FPGA设计的简约型开发板。开发板设计小巧精致，将芯片的所有资源都引出，板载Type C、USB JTAG、有源晶振、RGB(可接LCD屏、VGA等外设)等，并把所有IO资源引出，方便开发者拓展使用，非常适用于小型数字逻辑的设计和实验。 ![Nano 1](./../Tang Nano/assets/1k 1.jpg) ![Nano 2](./../Tang Nano/assets/1k 2.jpg) ## 参数 Tang Nano 1K 开发板板载的 GW1NZ LV1 FPGA芯片功能非常强大，具有较丰富的逻辑资源，支持多种 I/O 电平标准，内嵌块状静态随机存储器、锁相环、Flash 等资源，是一款具有非易失性的 FPGA 产品;另外，板载 27MHz 有源晶振，为 FPGA 各种时序操作提供了更精准的频率。 项目 参数 : : : : 核心 GW1NZ LV1 FPGA 逻辑单元(LUT4) 1152 寄存器(FF) 864 Block SRAM(bits) 72K B SRAM块个数 4 用户闪存(bits) 64K 锁相环PLL 1 I/O Bank总数 2 最多用户I/O数 48 核电压 1.2V ### 引脚图 ![pin_map](./../Tang Nano/assets/1k pin.png) ## 资料 [规格书](https://dl.sipeed.com/shareURL/TANG/Nano%201K/1_Specification) [原理图](https://dl.sipeed.com/shareURL/TANG/Nano%201K/2_Schematic) [点位图](https://dl.sipeed.com/shareURL/TANG/Nano%201K/3_Bit_number_map) [尺寸图](https://dl.sipeed.com/shareURL/TANG/Nano%201K/4_Dimensional_drawing) [3D 文件](https://dl.sipeed.com/shareURL/TANG/Nano%201K/5_3D_file) [芯片手册](https://dl.sipeed.com/shareURL/TANG/Nano%201K/6_Chip_Manual) [相关例程](https://wiki.sipeed.com/hardware/zh/tang/Tang Nano Doc/examples.html) ## 补充 1. 如果有什么疑问，欢迎加群 `834585530`, 或者去[论坛](bbs.sipeed.com)发帖。 2. 下载 FPGA 是要求使用 [这里](https://dl.sipeed.com/shareURL/TANG/programmer) 的 Programmer 软件。不然有极大概率不能下载固件到板子。 3. 有问题的话先去 [常见问题](./../Tang Nano Doc/questions.html) 自查，通常来说使用 [这里](https://dl.sipeed.com/shareURL/TANG/programmer) 的 Programmer 软件能解决 99% 问题。"},"/hardware/zh/tang/Tang-Nano-Doc/index.html":{"title":"Tang Nano","content":"# Tang Nano ## 什么是 Tang Nano Tang Nano 是基于高云半导体小蜜蜂系列 GW1N 1 FPGA 的简约型开发板。 板载芯片为 GW1N LV1QN48C6/I5，搭载了 1152 LUT4 的逻辑资源，1 PLL 和 4 Block 合计 72Kbit SRAM，封装为 QFN48。开发板引出了所有 I/O 接口，适用于小型数字逻辑的设计和实验。 板载 64Mbits PSRAM，为 FPGA 提供了丰富的存储资源。 同时，该开发板具有 RGB接口，能够与 LCD屏、VGA转换器 等外设连接，非常适合于屏幕显示等类型的应用。 板子板载 24MHz 晶振和 USB转JTAG下载器，能够容易的连接电脑进行开发，而不需要外部的调试器和时钟输入。板载的 RGB LED 可用于指示和调试，同时 FPGA IOBANK 分组可调的IO电平使得开发板能够容易的对外部各种不同电平规范的器件接口。 **板载资源:** + GW1N 1 + 64Mbit QSPI PSRAM + RGB LED + RGB LCD 40P接口及驱动电路 + 24MHz晶振 + USB调试器，基于Type C通讯接口 ## 引脚定义 ![Nano 引脚](./../../assets/tang_nano_pinout_v1.0.0_w5676_h4000_large.png) ## 资源下载链接 + [高云半导体官方下载站](http://www.gowinsemi.com.cn/faq.aspx) + [dl 下载站](http://dl.sipeed.com/TANG/Nano) + [Tang nano 原理图](../assets/files/Tang NANO.pdf)"},"/hardware/zh/tang/Tang-Nano-Doc/SUMMARY.html":{"title":"Summary","content":" title: Summary Tang nano系列开发板是基于[高云半导体](http://www.gowinsemi.com.cn/)FPGA设计的开发板，多种型号刚好可以满足不同的需求： Tang nano 1K 用极低的价格来让用户带领用户踏入FPGA领域 Tang nano 4K 带有一个Cortex m3的硬核，几乎是用户可以购买到的最低价的异构开发板 Tang nano 9K 配有极其丰富数量的逻辑单元，可以让用户在上面运行软核 ## 横向对比 型号 Tang Nano 1K Tang Nano 4K Tang Nano 9K 图片 ![Generated](./../Tang Nano/assets/clip_image002.gif) ![Generated](./../Tang Nano/assets/clip_image004.gif) ![Generated](./../Tang Nano/assets/clip_image006.gif) 逻辑单元（LUT4） 1152 4608 8640 硬核处理器 无 Cortex M3 无 有源晶振 27Mhz 27Mhz 27Mhz 显示接口 常见RGB屏幕接口 HDMI HDMI<br> 常见RGB屏幕接口<br> SPI屏幕接口 摄像头 无 可选OV2640 无 外置SPI FLASH 仅预留焊盘 默认焊接<br>32Mbit SPI FLASH 默认焊接<br>32Mbit SPI FLASH TF卡座 无 无 有 下载器 板载USB JTAG下载器 板载USB JTAG下载器 板载USB JTAG下载器&<br>USB UART通信接口 ## 准备 [IDE安装](./get_started/install the ide.html)"},"/hardware/zh/tang/Tang-Nano-Doc/get_started/install-the-ide.html":{"title":"安装 IDE","content":" title: 安装 IDE keywords: Sipeed, Gowin, Tang, Nano, fpga, 矽速 update: date: 2022 09 19 version: none author: wonder content: 根据高云半导体下载链接新页面重新截图 去掉了替换 Programmer 相关操作说明 使用高云半导体的 FPGA 需要用到 GOWIN 这个软件，对应的软件文档链接： <http://www.gowinsemi.com.cn/down.aspx?FId n14:14:26> 根据自己系统选择安装对应版本的 IDE 对于 Linux 系统下载固件可以使用 Openfpgaloader，可以查看本页底部的 [Linux 下烧录](#burn in linux) 来进行烧录操作。 ## 安装软件 ### 下载软件 前往 http://www.gowinsemi.com.cn/faq.aspx 下载 IDE。 由于高云半导体的IDE在不断的更新中，下图为 2022 年 09 月 19 日截图 ![IDE](./assets/IDE 1.png) IDE 分为商业版和教育版： 商业版的 IDE 需要 license，需要向高云半导体官方自行申请。 教育版 IDE 不需要 license，直接点击下载就可以了。 教育版所支持的器件如下： ![educational_device](./assets/educational_device.png) 由于高云半导体的IDE在不断的更新中，上图为 2022 年 11 月 09 日截图 芯片全程 芯片系列 芯片型号 适用板卡 GW1NZ LV1QN48C6/I5 GW1NZ GW1NZ Nano 1K GW1NSR LV4CQN48PC6/I5 GW1NSR GW1NSR 4C Nano 4K GW1NR LV9QN88PC6/I5 GW1NR GW1NR 9C Nano 9K GW2AR LV18QN88PC8/I7 GW2AR GW2AR LV18 Nano 20K GW2A LV18PG256C8/I7 GW2A GW2A 18C Primer 20K 所以对于购买了 Tang Nano （板载 jtag 芯片为 CH552），目前需要使用商业版的 IDE 且需要自行向高云半导体官方申请 license。 ### 开始安装 #### Linux 系统 Linux 版本的解压后里面存在着一个 bin 文件夹，然后可执行文件 `gw_ide` 就在所解压路径的 /IDE/bin/ 文件夹中，用命令行来运行即可；运行软件失败的话记得改软件的可执行权限 `chmod + x`。 #### Windows 系统 下载相应的 IDE 之后所得到的是一个压缩包程序；对于 Windows 版本的解压后里面是一个可执行程序，双击安装继续下面的步骤就行。下面的所有安装步骤均为 Windows 平台： <div class \"imbox\"> <img src \"./assets/IDE 2.png\" width 45%> <img src \"./assets/IDE 3.png\" width 45%> </div> 下图的两个都需要安装上。其中的 Gowin 为 IDE 本体， 另一个 programmer 相关的是烧录软件。 因为我们的下载器与 IDE 附带安装的 Programmer 可能不太兼容，使用中有问题的话可以前往 <a href \"./../questions.html#下载失败\" target \"blank\">programmer 相关里的下载失败</a> 来查看对应方法。 <! 由于我们所提供下载器会与新版的 IDE 不太兼容，因此建议前往 <a href \"./../questions.html#下载失败\" target \"blank\">programmer 相关里的下载失败</a> 来查看对应方法。 > <img src \"./assets/IDE 4.png\" width 50%> 下图的安装路径个人按照自己需要设置 <img src \"./assets/IDE 5.png\" width 50%> 安装中... <img src \"./assets/IDE 6.png\" width 50%> 下面这一步不要更改任何东西，按照默认的点击`Finish`就行，紧接着就是安装相关的驱动 <img src \"./assets/IDE 7.png\" width 50%> 上面的`Finish`后会出现下面的内容，这是安装驱动的。 <html> <div class \"imbox\"> <img src \"./assets/IDE 8.png\" width 45%> <img src \"./assets/IDE 9.png\" width 45%> </div> </html> 这里需要选择接受协议才能继续安装 <html> <div class \"imbox\"> <img src \"./assets/IDE 10.png\" width 45%> <img src \"./assets/IDE 11.png\" width 45%> </div> </html> 点击完成后桌面上会出现下面的图标 ![IDE](./assets/IDE 12.png) 到这里我们就完成了软件的安装 ## 使用 IDE ### license 相关 教育版本的 IDE 直接运行即可；商业版的 IDE 需要自行前往 [点我](http://www.gowinsemi.com.cn/faq_view.aspx) 申请 license 后才能使用，其中申请license 时 MAC 最好填写本机的以太网网卡地址，避免以后可能因部分设置而导致 MAC 地址改变 license 验证失败。 ### 验证 license 打开高云半导体 IDE 的时候，在弹出的 license 管理中，选择自己本地 license 的文件，验证保存即可。 <img src \"./assets/IDE 13.png\" alt \"Broswer lic\" width 45%> <img src \"./assets/check.png\" alt \"Check lic\" width 45%> 然后就可以开始使用高云半导体 IDE 了。 ### Programmer <! 在烧录 FPGA 的时候可能因为安装 IDE 时所安装的 Programmer 软件不兼容我们所提供的下载器，因此对于 Windows 用户要求使用我们所提供的特定版本的 Programmer 软件，[点我](https://dl.sipeed.com/shareURL/TANG/programmer)跳转下载即可； > 如果下载固件失败的话，可以手动下载一下 Programmer 软件来试试 [跳转地址](https://dl.sipeed.com/shareURL/TANG/programmer) ![programmer_download](./assets/programmer_download.png) 对于 Linux 用户可以用 Openfpgaloader, 查看本页最底部的相关说明即可。 ## 拓展 获取 license 可能需要等待一段时间。在此期间可以看看高云半导体的官方文档。下面简单说明一下： 在 IDE 的安装路径下主要有如下内容：IDE 文件夹、Programmer 文件夹、uninst.exe； ![ide_folder](./assets/ide_folder.png) **IDE** 文件夹：这里主要说一下里面的 **doc** 文件夹，用户在安装完之后可以在这个文件夹里面看到高云提供的大多数文档高云半导体，主要内容如下图所示： ![IDE](./assets/doc folder.png) **Programmer** 文件夹：里面是烧录软件，也有相关的文档。 ![programmer](./assets/programmer folder.png) **uninst.exe**：卸载IDE <! ## 其他安装方法 下面是高云半导体官方所提供的 IDE 安装方法，有需要的话可以自行查阅 + [高云半导体软件简介和安装](http://cdn.gowinsemi.com.cn/%E9%AB%98%E4%BA%91%E8%BD%AF%E4%BB%B6%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%89%E8%A3%85.pdf) > ## Burn in linux [Linux系统下烧录方法](./flash_in_linux.html)"},"/hardware/zh/tang/Tang-Nano-Doc/get_started/flash_in_linux.html":{"title":"Linux 下烧录方法","content":" title: Linux 下烧录方法 keyeords: Linux, FPGA, Gowin 在Ubuntu系统下我们建议使用**openFPGALoader**烧写，其他发行版尚未验证。以下为具体步骤 ### 安装openFPGALoader 参考：https://trabucayre.github.io/openFPGALoader/guide/install.html 直接在linux命令行执行下面命令即可 ```bash # preprocess sudo apt get install libftdi1 2 libftdi1 dev libhidapi hidraw0 libhidapi dev libudev dev zlib1g dev cmake pkg config make g++ # compile git clone https://github.com/trabucayre/openFPGALoader.git cd openFPGALoader mkdir build cd build cmake ../ # add DBUILD_STATIC ON to build a static version # add DENABLE_UDEV OFF to disable udev support and d /dev/xxx # add DENABLE_CMSISDAP OFF to disable CMSIS DAP support cmake build . # or # make j$(nproc) # install sudo make install ``` ### 烧录方法 检测板卡 ```bash $ sudo ./openFPGALoader detect # 对于这行命令应当在你上一步执行make install的目录下执行 # 下面是正常执行后显示的log Jtag frequency : requested 6.00MHz > real 6.00MHz index 0: idcode 0x100481b manufacturer Gowin family GW1N model GW1N(R) 9C irlength 8 ``` 下载码流 ```bash $ sudo ./openFPGALoader b tangnano9k f ../../nano9k_lcd/impl/pnr/Tang_nano_9K_LCD.fs # 其中的 b 表示目标板型号，具体可以参考下面表格 # f 表示下载到 flash，不加的话会下载到 sram 中 # 最后的是需要烧录的文件，应该找到对应目录下的 .fs 文件 # 下面是成功执行后的log write to flash Jtag frequency : requested 6.00MHz > real 6.00MHz Parse file Parse ../../nano9k_lcd/impl/pnr/Tang_nano_9K_LCD.fs: Done DONE Jtag frequency : requested 2.50MHz > real 2.00MHz erase SRAM Done erase Flash Done write Flash: [ ] 100.00% Done CRC check: Success ``` 其中 b表示目标板型，可以使用以下取值： Board name FPGA Memory Flash tangnano GW1N 1 QFN48 OK Internal Flash tangnano1k GW1NZ 1 QFN48 OK Internal Flash tangnano4k GW1NSR 4C QFN48 OK Internal Flash/External Flash tangnano9k GW1NR 9C QFN88 OK Internal Flash/External Flash "},"/hardware/zh/tang/Tang-Nano-Doc/examples.html":{"title":"Tang Nano 系列例程","content":" title: Tang Nano 系列例程 tags: Tang Nano, example, guide keywords: Tang Nano，example update: date: 2023 01 09 author: wonder content: 添加 Tang Nano 9K Lushay Labs 跳转链接 ## 前言 基本上手使用和相关的历程 <! 对于Programmer(下载程序)建议使用 https://dl.sipeed.com/shareURL/TANG/programmer 里面的文件。 下载后解压替换掉Gowin对应安装目录的Programmer文件夹即可。 不会替换的话可以在下载解压后的Programmer程序中手动添加对应下载文件来进行烧录。 另外欢迎投稿或者提供例程，有什么例程想法的话也可以提出。 > ## Tang Nano > 板载下载器为CH552 Github: https://github.com/sipeed/Tang Nano examples [点灯例程](./../Tang Nano/examples/1_led.html) [驱屏教程](./../Tang Nano/examples/2_lcd.html) ## Tang Nano 1K Github: https://github.com/sipeed/TangNano 1K examples [点灯例程](./../Tang Nano 1K/examples/LED.html) [驱屏教程](./../Tang Nano 1K/examples/LCD.html) ## Tang Nano 4K Github: https://github.com/sipeed/TangNano 4K example [点灯例程](./../Tang Nano 4K/examples/LED.html) （快速上手） [按键标志点灯](https://github.com/sipeed/TangNano 4K example/tree/main/key_blink)(github) [HDMI显示工程](https://github.com/sipeed/TangNano 4K example/tree/main/hdmi_720p)(github) [HDMI 显示摄像头内容](https://github.com/sipeed/TangNano 4K example/tree/main/camera_hdmi)(github) 在Nano 4K上运行GBA的工程：https://github.com/Martoni/GbHdmi litex 在 4K 支持：https://github.com/litex hub/litex boards 其他： 使用 Cortex M3 点灯例程：[Github](https://github.com/verilog indeed/gowin_fpga_tutorials) (英文) ## Tang Nano 9K Github: https://github.com/sipeed/TangNano 9K example [点灯例程](./../Tang Nano 9K/examples/LED.html) [驱RGB屏教程](./../Tang Nano 9K/examples/LCD.html) [PicoRV 在9K上运行的示例](./../Tang Nano 9K/examples/picorv.html) [FPGA驱动1.14 SPI屏幕工程](./../Tang Nano 9K/examples/spi_lcd.html) HDMI 示例：参考 [PicoRV 在9K上运行的示例](./../Tang Nano 9K/examples/picorv.html) litex 在 9K 支持：https://github.com/litex hub/litex boards ## Tang Nano 20K Github: https://github.com/sipeed/TangNano 20K example ## 哔哩哔哩视频 > 感谢 [ZQ坐看云起时](https://space.bilibili.com/375786914/video) 友情制作 <table> <tr><td><a href \"https://www.bilibili.com/video/BV1Jv4y1Q7u6/\" target \"_blank_\">TANG NANO 9K 开发板应用《1: 云源IDE安装》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1MK411z7it/\" target \"_blank_\">TANG NANO 9K 开发板应用《2: 云源软件基本使用》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1HW4y1K7mT/\" target \"_blank_\">TANG NANO 9K 开发板应用《3: 新建FPGA工程》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV19d4y1h7CQ/\" target \"_blank_\">TANG NANO 9K 开发板应用《4：时钟分频器使用之IP调用法》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1YA411X7Tt/\" target \"_blank_\">TANG NANO 9K 开发板应用《5：时钟分频器使用之直接例化法》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1z24y1S7MX/\" target \"_blank_\">TANG NANO 9K 开发板应用《6：38译码器设计与测试》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV19Y411m7XN/\" target \"_blank_\">TANG NANO 9K 开发板应用《7：高云逻辑分析仪之配置篇》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1m24y1S7f2/\" target \"_blank_\">TANG NANO 9K 开发板应用《8：高云逻辑分析仪之使用篇》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1dR4y1U7pJ/\" target \"_blank_\">TANG NANO 9K 开发板应用《9：存储器BSRAM使用方法介绍》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1bv4y1i7Ez/\" target \"_blank_\">TANG NANO 9K 开发板应用《10：高云逻辑分析仪调试BSRAM》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1L24y1i7k8/\" target \"_blank_\">TANG NANO 9K 开发板应用《11：BSRAM设置初始化数据》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1y8411K7ey/\" target \"_blank_\">TANG NANO 9K 开发板应用《12：基于BSRAM的pROM使用》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1hK411y7a4/\" target \"_blank_\">TANG NANO 9K 开发板应用《13：输入时钟CLK信号捕获技巧》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1V8411w7rw/\" target \"_blank_\">TANG NANO 9K 开发板应用《14：基于ST7789芯片1.14寸LCD屏幕驱动》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1534y1f75w/\" target \"_blank_\">TANG NANO 9K 开发板应用《15：基于ST7789芯片LCD寄存器配置和显示》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1Ld4y1n7R4/\" target \"_blank_\">TANG NANO 9K 开发板应用《16: 1.14寸LCD图片显示实验》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1C84y1n7mb/\" target \"_blank_\">TANG NANO 9K 开发板应用《17: 1.14寸LCD图片滚动实验》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV11N411F7i1/\" target \"_blank_\">TANG NANO 9K 开发板应用《18：手搓简易标准SPI驱动及仿真》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1qs4y1V7D4/\" target \"_blank_\">TANG NANO 9K 开发板应用《19：SPI读flash P25Q32HS/W25Q32 芯片ID实验》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1ck4y1h7KZ/\" target \"_blank_\">TANG NANO 9K 开发板应用《20：SPI读写/擦除P25Q32HS/W25Q32实验》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1Nx4y1A7E7/\" target \"_blank_\">TANG NANO 9K 开发板应用《21：串口发送模块的实现》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1yL411S7T5/\" target \"_blank_\">TANG NANO 9K 开发板应用《22：串口接收模块的实现》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1xM411T7kv/\" target \"_blank_\">TANG NANO 9K 开发板应用《23：环形队列(FIFO)的实现》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1Xh4y1p7x7/\" target \"_blank_\">TANG NANO 9K 开发板应用《24：串口转SPI操作flash》</a></td></tr> </table> <table> <tr><td><a href \"https://www.bilibili.com/video/BV1iA411R7Zi/\" target \"_blank_\">iverilog + gtkwave 开源仿真工具《1：软件安装篇》</a></tr></td> <tr><td><a href \"https://www.bilibili.com/video/BV18y4y1R7eu/\" target \"_blank_\">iverilog + gtkwave 开源仿真工具《2：计数器仿真实验》</a></tr></td> </table> ## 其他上手说明 Tang Nano 9K 合作代理教程(英文)： <a href \"https://learn.lushaylabs.com/tang nano series/\"><img src \"./assets/lushaylab_logo.png\" alt \"lushaylab_logo\" width \"35%\"></a> 1. [Installation & Getting Started](https://learn.lushaylabs.com/getting setup with the tang nano 9k/) 2. [Debugging & UART](https://learn.lushaylabs.com/tang nano 9k debugging/) 3. [OLED 101](https://learn.lushaylabs.com/tang nano 9k graphics/) 4. [Creating a Text Engine](https://learn.lushaylabs.com/tang nano 9k creating a text engine/) 5. [Data Conversion & Visualization](https://learn.lushaylabs.com/tang nano 9k data visualization/) 6. [Reading from the External Flash](https://learn.lushaylabs.com/tang nano 9k reading the external flash/) 7. [Generating Random Numbers](https://learn.lushaylabs.com/tang nano 9k generating random/) 8. [Sharing Resources](https://learn.lushaylabs.com/tang nano 9k sharing resources/) 9. [I2C, ADC and Micro Procedures](https://learn.lushaylabs.com/i2c adc micro procedures/) 10. [Our First CPU](https://learn.lushaylabs.com/tang nano 9k first processor/) ## 结语 有问题可以在相关页面下面留言，或者加入 QQ 群讨论，常见问题已被收录。 QQ 群：834585530 常见问题: [点我](https://wiki.sipeed.com/hardware/zh/tang/Tang Nano Doc/questions.html)"},"/hardware/zh/tang/Tang-Nano-Doc/questions.html":{"title":"常见问题","content":" title: 常见问题 tags: Tang keywords: Programmer desc: update: date: 2023 05 18 version: v0.5 author: wonder content: 补充 programmer 相关的说明 <! date: 2022 06 29 version: v0.1 author: wonder content: 初次编写 date: 2022 09 23 version: v0.2 author: wonder content: 更新部分过期内容 date: 2022 10 19 version: v0.3 author: wonder content: 增加设置顶层相关说明 date: 2023 02 23 version: v0.4 author: wonder content: 补充 programmer 相关的说明 > 这里汇总一些常见问题。 ## Programmer 相关 首先确定设备管理器中有两个 `converter` 设备和一个 `COM` 设备，这说明设备正常连接到电脑并且电脑成功加载驱动了。 ![tang_bl702_device_convertor](./assets/qusetions/tang_bl702_device_convertor.png) > 下载器都有 串口 和 Jtag 功能，但是要注意的是在使用串口的时候， Jtag 功能是不能用的。解决串口占用这种情况，重新插拔一下板卡的 USB 数据线就好了。 ### 只有两个 `convertor` ![tang_bl702_device_convertor_no_com](./assets/qusetions/tang_bl702_device_convertor_no_com.png) 如果出现没有 `COM` 设备但是有两个 `converter` 设备，可以 `鼠标右键点击` `converter B` > `属性` > `高级` > `加载 VCP` ，然后点击 `OK` ，重新插拔一下 USB 数据线就行了。 ![tang_bl702_device_convertor_load_vcp](./assets/qusetions/tang_bl702_device_convertor_load_vcp.png) ### 没有 `convertor` 调试器连接电脑后，需要十多秒时间加载驱动。不想等待加载驱动的话可以手动下载驱动并安装驱动 [点我跳转到驱动下载页面](https://dl.sipeed.com/shareURL/TANG/programmer)。 ![no_convertor_install_driver](./assets/qusetions/no_convertor_install_driver.png) ### 下载频率 要注意下载频率应该为 `2.5M` 或者更低的数值。不然很可能导致下载极其缓慢或者下载失败等问题。 <details> <summary><font color \"#4F84FF\">点开查看操作步骤图片</font></summary> <img src \"./../assets/questions/cable.png\"> <p>点击下图中的 Frequency，设置频率小于或者等于 2.5MHz</p> <img src \"./../assets/questions/frequency.png\" > <p>接着再点击 Save 即可</p> </details> ### Error found <! 没有扫描到下载器或者驱动错误，要求使用 [这里](https://dl.sipeed.com/shareURL/TANG/programmer) 的压缩包文件。 下载后解压替换掉 Gowin IDE 对应安装目录的 Programmer 文件夹即可。 不会替换的话可以在下载解压后的 Programmer 程序中手动添加对应下载文件来进行烧录。 > <! 替换下载器软件后出现这个问题的话， > 确定设备管理器中的 `convertor` 和 `COM` 都存在时，可以先重启一下 programmer 软件。 ### Cabel open failed ![cable_open_failed](./assets/qusetions/cable_open_failed.png) 在板卡通电的时候需要 2~3s 时间来加载驱动，加载成功后电脑设备管理器中会显示出两个 converter 设备，这个时候就可以正常烧录了。 ![converter](./../assets/questions/converter.png) 这里的意思是没有找到下载器，可以尝试使用高云半导体所提供的最新的教育版的编程器 [点我跳转](http://www.gowinsemi.com.cn/faq.aspx) 来尝试解决老版本 Programmer 软件的 bug。 使用新版本下载器后出现这个问题的话，可以先重启一下 programmer 软件；依旧没找到的话可以看看本篇开头的 converter 相关的内容。 <! 可以尝试使用要求使用 [这里](https://dl.sipeed.com/shareURL/TANG/programmer) 的文件来解决无法正常烧录问题 > ![educational_edition_programmer](./../tang primer 20k/assets/start/educational_edition_programmer.png) <! 参考上一步 No Gowin devices found 的操作后，再 programmer 里面进行下面操作： 点击顶部菜单栏的 Edit >Cable Setting >Cable >Query，然后 Save 即可 <details> <summary><font color \"#4F84FF\">点开查看操作步骤图片</font></summary> <img src \"./../assets/questions/cable.png\"> <p>点击下图中的 Query</p> <img src \"./../assets/questions/click_query.png\" > <p>接着再点击 Save 即可</p> </details> > ### No Gowin devices found ![no_gowin_device_found](./assets/qusetions/no_gowin_device_found.png) 这里指的是没有扫描到高云设备，可以尝试使用高云半导体所提供的最新的教育版的编程器 [点我跳转](http://www.gowinsemi.com.cn/faq.aspx) 来尝试解决老版本 Programmer 软件的 bug。 ![educational_edition_programmer](./../tang primer 20k/assets/start/educational_edition_programmer.png) #### Nano 9K Nano 9K 在设计的时候将 JTAG_SEL 引脚连接到了 S2 按键上，根据高云手册可以知道 JTAGSEL_N 0 的时候，芯片的 Jtag 引脚可以正常使用。 ![jtag_sel_function](./assets/qusetions/jtag_sel_function.jpg) 在使用 Programmer 对 Nano 9K FPGA 板卡进行操作的时候按住 S2 按键就可以了。 #### Primer 20K 20K Dock 套件要注意拨动拨码开关使能核心板后，下载软件才可以通过底板识别到底板所插入的核心板。 使能核心板 未使能状态 补充说明 <img src \"./../tang primer 20k/assets/start/switch_1_on.png\" alt \"switch_1_on\" width 100%><img src \"./../tang primer 20k/assets/start/reset_led_on.png\" alt \"reset_led_on\" width 100%> 未使能核心板的话板子上的 0、1 号 LED 会一直亮着，且核心板不会正常启动。 单独使用 20K 核心板和 RV Debugger Plus 下载器来下载固件出现这个错误时，可能是接线错了，自己根据下面的表格检查一下线序，或者检查一下核心板的 8pin 接口有没有被怼歪（有一次连接失败，发现是引脚歪了然后连接不上下载器了；不要大力出奇迹）。 20K 核心板 JTAG 引脚定义可以在背部看到。 <table> <tr> <td>核心板</td> <td>5V0</td> <td>TMS</td> <td>TDO</td> <td>TCK</td> <td>TDI</td> <td>RX</td> <td>TX</td> <td>GND</td> </tr> <tr> <td>调试器</td> <td>5V0</td> <td>TMS</td> <td>TDO</td> <td>TCK</td> <td>TDI</td> <td>TX</td> <td>RX</td> <td>GND</td> </tr> </table> ![cable_connect](./../tang primer 20k/examples/assets/led_assets/cable_connect.png) 对于 20K 板卡来说可能是因为 JTAG 复用而导致主控芯片的 JTAG 引脚不再能被调试，[点我](./../tang primer 20k/primer 20k.html#dock 底板不工作)来查看相应解决办法 ### ID code mismatch ![id_code_mismatch](./assets/qusetions/id_code_mismatch.png) 这种情况是工程文件设置的芯片与实际下载芯片型号不一致而造成的。 重新设置工程中的芯片型号（比如工程设置、引脚约束、各个IP中的型号）。 板卡型号 芯片系列 芯片设备 封装 速度等级 Tang Nano GW1N GW1N 1 QFN48 C6/I5 Tang Nano 1K GW1NZ GW1NZ 1 QFN48 C6/I5 Tang Nano 4K GW1NSR GW1NSR 4C QFN48P C6/I5 或者 C7/I6 Tang Nano 9K GW1NR GW1NR 9C QFN88P C6/I5 Tang Primer 20K GW2A GW2A 18C PBGA256 C8/I7 <! <details> <summary><font color \"#4F84FF\">点开查看正确型号选择</font></summary> <p>Nano 9K 应当选择的型号</p> <img src \"./../Tang Nano 9K/nano_9k/Tang_nano_9k_Device_choose.png\" width 45%> <p>Primer 20K 应当选择的型号</p> <img src \"./assets/primer_20k_device_choose.png\" width 45%> </details> > <! 对于其他板子选择型号的时候与芯片丝印相对应就行。 > ### spi flash selected mismatch 以高云半导体小蜜蜂（芯片名称以 GW1N 开头的系列）家族芯片为主控的板卡芯片内部含有 FLASH，因此下载的时候将生成的固件烧录到芯片内部即可，将板载的 FLASH 芯片当作外设使用。 以高云半导体晨熙（芯片名称以 GW2A 开头的系列）家族芯片为主控的板卡芯片内部无有 FLASH，因此下载的时候将生成的固件烧录到外部 FLASH，对此在 Programmer 界面所进行的下载模式与 FLASH 选择如下： <table> <tr> <td rowspan \"2\"><img src \"./../tang primer 20k/examples/assets/led_assets/flash_mode.png\" alt \"flash_mode\"></td> <td style \"white space:nowrap\">操作（Operation）为 <br><code>exFlash Erase,Program thru GAO Bridge</code></td> </tr> <tr> <td>Flash 型号选择为 <code>Generic Flash</code></td> </tr> </table> ### 下载卡住、下载非常慢 不要选中带有 Verify 选项的。 ![never_choose_verify](./../assets/questions/never_choose_verify.png) 另外自己注意设置一下下载频率，一般设置为 2.5MHZ 不会有异常 <details> <summary><font color \"#4F84FF\">点开查看操作步骤图片</font></summary> <img src \"./../assets/questions/cable.png\"> <p>点击下图中的 Frequency</p> <img src \"./../assets/questions/frequency.png\" > <p>接着再点击 Save 即可</p> </details> ### 找不到下载文件 一般来说生成的下载文件（拓展后缀为.fs）在工程目录下的 impl/pnr 文件夹里面。 <details> <summary><font color \"#4F84FF\">点开查看相关图文说明</font></summary> <img src \"./../assets/questions/fs_path.png\"> <p> 在上图中可以看到这个下载文件的路径为 /fpga_project1/impl/pnr/fpga_project1.fs </p> <p></p> <p> 其中 fpga_project1 为工程目录，impl 为 IDE 生成的目录，然后所需要的文件位于 pnr 文件夹内</p> <p></p> <p> 然后那个拓展名为 .fs 的文件就是下载到 fpga 的固件</p> </details> ### Directory *** has null character. 文件路径有不支持的字符。 关掉 IDE 检查文件路径，要求路径只包含英文和下划线，检查路径是否有空格 重新打开工程，清除综合缓存后再重新重新综合。 ### 烧录结束后没反应 一般这种情况是没有选择正确的烧录文件。可以自己先对应着各个板子点灯文档里所选择的芯片型号来检查一下自己的工程，然后看看自己的代码是否有问题。对于 20K 板卡来说可能是因为 JTAG 复用而导致主控芯片的 JTAG 引脚不再能被调试，[点我](./../tang primer 20k/primer 20k.html#dock 底板不工作)来查看相应解决办法 ## IDE 使用相关 ### 查看IP文档 在 IDE 里面的 IP 界面点击想要查看的 IP 文档后点击对应的语言即可跳转到对应的说明 <details> <summary><font color \"#4F84FF\">点开查看相关说明</font></summary> <img src \"./../assets/ip reference.png\"> </details> ### 修改设置过的 IP 在 IDE 里面的 IP 界面点击上方器件选型旁边的文件夹后打开已生成 IP 编辑界面 <details> <summary><font color \"#4F84FF\">点开查看相关说明</font></summary> <img src \"./../assets/ip reconfigure.png\"> </details> ### 设置 TOP 层 对于含有多个模块的工程，成功例化后，在 IDE > Hierarchy 页面右键想要设置为顶层的模块，然后选择 `Set As Top Module` 将它设置为顶层模块了。 ![set_top_module](./assets/set_top_module.png) 如果在 Hierarchy 页面出现下下表左图现象，这表明代码里有逻辑错误，比如 语法错误、例化错误 等等，点击右上角的 `RTL Anakysis Error` ，就可以在弹出的对话框里看到错误的类型代码以及错误的位置，如下表右图所示。 <table> <tr> <td align \"center\">RTL Analysis Error</td> <td align \"center\">错误类型以及详情</td> </tr> <tr> <td><img src \"./assets/top_error.png\" alt \"top_module_error\" ></td> <td><img src \"./assets/error_detail.png\" alt \"error_detail\" ></td> </tr> </table> ### 使用 GAO GAO 是高云半导体在线逻辑分析仪（Gowin Analyzer Oscilloscope）。安装高云 IDE 之后就能在对应的安装相对路径下看到相关文档了 ![gao](./../assets/questions/gao.png) 使用高云半导体所提供的最新的教育版的编程器 [点我跳转](http://www.gowinsemi.com.cn/faq.aspx) 能够正常使用 GAO（因为 GAO 必须在 IDE 内才能打开，所以你需要自己替换掉安装时候的 Programmer 文件夹，并且确定替换后的路径与之前的相同）。 ![educational_edition_programmer](./../tang primer 20k/assets/start/educational_edition_programmer.png)"},"/hardware/zh/tang/tang-nano-20k/nano-20k.html":{"title":"Tang Nano 20K","content":" title: Tang Nano 20K keywords: FPGA, Tang, Nano, 20K update: date: 2023 02 27 version: v0.1 author: wonder content: 新建文档 ## 简介 Tang Nano 20K 是采用高云半导体 [GW2AR 18 QN88](http://www.gowinsemi.com.cn/prod_view.aspx?TypeId 10&FId t3:10:3&Id 167#GW2AR) 的一款核心板，芯片内部具有 20736 个逻辑查找表(LUT4) 和 15552 个寄存器(FF)，内部有两个 PLL，还带有多个 DSP 单元支持 18位 x 18位 的乘法运算来加速数字运算。板载 [BL616](https://bouffalolab.com/product/?type detail&id 21) 芯片来作为 FPGA JTAG 下载器和与 FPGA 通信的串口。板上默认使用 27MHz 晶振用于倍频出 HDMI 显示所需要的时钟，还额外搭载 MS5351 时钟发生芯片来随意生成多种所需要的时钟。 淘宝购买链接：[点我](https://item.taobao.com/item.htm?id 717932028073) ## 外观渲染图 <img src \"./assets/nano_20k/tang_nano_20k_3920_top.png\" width \"40%\"> <img src \"./assets/nano_20k/tang_nano_20k_3920_bot.png\" width \"40%\"> ## 详细参数 <table> <thead> \t<tr> \t\t<th style \"text align:center\">项目</th> \t\t<th style \"text align:center\">参数</th> \t\t<th style \"text align:center\">补充</th> \t</tr> </thead> <tbody> \t<tr> \t\t<td style \"text align:left\">FPGA 芯片</td> \t\t<td style \"text align:left\"><a href \"http://www.gowinsemi.com.cn/prod_view.aspx?TypeId 10&amp;FId t3:10:3&amp;Id 167#GW2AR\">GW2A LV18QN88C8I7</a> \t\t</td> \t\t<td style \"text align:left\"> \t\t\t<table> \t\t\t\t<tbody> \t\t\t\t\t<tr> \t\t\t\t\t<td>逻辑单元(LUT4)</td> \t\t\t\t\t<td>20736</td> \t\t\t\t</tr> \t\t\t\t<tr> \t\t\t\t\t<td>寄存器(FF)</td> \t\t\t\t\t<td>15552</td> \t\t\t\t</tr> \t\t\t\t<tr> \t\t\t\t\t<td>分布式静态随机存储器S SRAM(bits)</td> \t\t\t\t\t<td>41472</td> \t\t\t\t</tr> \t\t\t\t<tr> \t\t\t\t\t<td>块状静态随机存储器B SRAM(bits)</td> \t\t\t\t\t<td>828K</td> \t\t\t\t</tr> \t\t\t\t<tr> \t\t\t\t\t<td>块状静态随机存储器数目B SRAM(个)</td> \t\t\t\t\t<td>46</td> \t\t\t\t</tr> \t\t\t\t<tr> \t\t\t\t\t<td>32bits SDR SDRAM</td> \t\t\t\t\t<td>64M bits</td> \t\t\t\t</tr> \t\t\t\t<tr> \t\t\t\t\t<td>乘法器(18x18 Multiplier)</td> \t\t\t\t\t<td>48</td> \t\t\t\t</tr> \t\t\t\t<tr> \t\t\t\t\t<td>锁相环(PLLs)</td> \t\t\t\t\t<td>2</td> \t\t\t\t</tr> \t\t\t\t<tr> \t\t\t\t\t<td>I/O Bank 总数</td> \t\t\t\t\t<td>8</td> \t\t\t\t</tr> \t\t\t</tbody></table> \t\t</td> \t</tr> \t<tr> \t\t<td style \"text align:left\">板载下载器</td> \t\t<td style \"text align:left\">BL616</td> \t\t<td style \"text align:left\">· 给 FPGA 提供 JTAG 下载功能<br>· 提供 USB 转串口与 FPGA 通信<br>· 提供虚拟串口用于 FPGA 通过 SPI 通信<br>· 提供虚拟串口控制 MS5351 输出时钟</td> \t</tr> \t<tr> \t\t<td style \"text align:left\">时钟芯片</td> \t\t<td style \"text align:left\">MS5351</td> \t\t<td style \"text align:left\">给 FPGA 芯片提供额外的三路时钟</td> \t</tr> \t<tr> \t\t<td style \"text align:left\">显示接口</td> \t\t<td style \"text align:left\">· 40Pins RGB lcd 连接器<br>· HDMI 接口</td> \t\t<td style \"text align:left\"></td> \t</tr> \t<tr> \t\t<td style \"text align:left\"> 单色 LED </td> \t\t<td style \"text align:left\"> 6 个 </td> \t\t<td style \"text align:left\"> 共阳极连接 </td> \t</tr> \t<tr> \t\t<td style \"text align:left\"> RGB LED </td> \t\t<td style \"text align:left\"> 1 个 </td> \t\t<td style \"text align:left\"> 型号是 WS2812 </td> \t</tr> \t<tr> \t\t<td style \"text align:left\"> 用户按键 </td> \t\t<td style \"text align:left\"> 2 个 </td> \t\t<td style \"text align:left\"> 用于自定义逻辑功能 </td> \t</tr> \t<tr> \t\t<td style \"text align:left\"> TF 卡槽 </td> \t\t<td style \"text align:left\"> 1 个 </td> \t\t<td style \"text align:left\"> 推拉式 </td> \t</tr> \t<tr> \t\t<td style \"text align:left\"> 功率放大器 </td> \t\t<td style \"text align:left\"> 1 个 </td> \t\t<td style \"text align:left\"> 型号是 MAX98357A，用于播放音频 </td> \t</tr> \t<tr> \t\t<td style \"text align:left\"> 存储 </td> \t\t<td style \"text align:left\"> 64Mbits Flash </td> \t\t<td style \"text align:left\"> 下载方式参考底部相关问题 </td> \t</tr> \t<tr> \t\t<td style \"text align:left\"> 尺寸 </td> \t\t<td style \"text align:left\"> 22.55mm x 54.04mm </td> \t\t<td style \"text align:left\"> 精确尺寸可以参考 3D 文件 </td> \t</tr> </tbody> </table> ## 外设框图 ![tang_nano_20k_functionalannotation](./assets/nano_20k/tang_nano_20k_functionalannotation.jpg) 下面是更详细的外设框图 <img src \"./assets/nano_20k/tang_nano_20k_functionalannotation_top.png\" width \"40%\" alt \"tang_nano_20k_functionalannotation_top\"> <img src \"./assets/nano_20k/tang_nano_20k_functionalannotation_bot.png\" width \"40%\" alt \"tang_nano_20k_functionalannotation_bot\"> ## 引脚框图 ![tang_nano_20k_pinlabel](./assets/nano_20k/tang_nano_20k_pinlabel.png) ## FPGA Jtag 触点指示图 我们在 Tang Nano 20K 上引出了 Jtag 触点，方便想要使用额外下载器的用户。 > Tang Nano 20K 板卡上是带有下载器的，这个测试点只是给有额外需要的人准备的。 ![tang_nano_20k_testpointlannotation](./assets/nano_20k/tang_nano_20k_testpointlannotation.png) ## 硬件资料 [板卡规格书](https://dl.sipeed.com/shareURL/TANG/Nano_20K/1_Datasheet) [板卡原理图](https://dl.sipeed.com/shareURL/TANG/Nano_20K/2_Schematic) [PCB BOM](https://dl.sipeed.com/shareURL/TANG/Primer_20K/03_Bit_number_map) (根据自己板子的版本查看里面的 html 文件) [板卡尺寸图](https://dl.sipeed.com/shareURL/TANG/Nano_20K/4_Dimensional_drawing) [板卡 3D 模型](https://dl.sipeed.com/shareURL/TANG/Nano_20K/4_Dimensional_drawing) [部分芯片手册](https://dl.sipeed.com/shareURL/TANG/Nano_20K/6_Chip_manual) ## 上手使用 安装 IDE > 编写代码 > 烧录进板子 安装 IDE [点我](https://wiki.sipeed.com/hardware/zh/tang/Tang Nano Doc/get_started/install the ide.html) 开箱说明 [点我](https://wiki.sipeed.com/hardware/zh/tang/tang nano 20k/example/unbox.html) 点灯上手指南 [点我](https://wiki.sipeed.com/hardware/zh/tang/tang nano 20k/example/led.html) 更多例程代码 [github](https://github.com/sipeed/TangNano 20K example) ### 其他学习资源 在线免费教程：[Verilog 教程](https://www.runoob.com/w3cnote/verilog tutorial.html)（学习Verilog） 在线免费 FPGA 教程：[Verilog](https://www.asic world.com/verilog/index.html) （英文网站） Verilog 刷题网站：[HDLBits](https://hdlbits.01xz.net/wiki/Main_Page)（英文网站） 在线高云半导体可参考视频教程：[点击这里](http://www.gowinsemi.com.cn/video_complex.aspx?FId n15:15:26) ## 交流方式 **交流论坛: [bbs.sipeed.com](https://bbs.sipeed.com)** **QQ 交流群：[834585530](https://jq.qq.com/?_wv 1027&k wBb8XUan)** 直接本页下方留言 商业邮箱 : [support@sipeed.com](support@sipeed.com) ## 常见问题 ### 怎么让固件上电启动 Tang Nano 20K 使用外部 Flash 来存放固件，所以想要让固件存在板子上我们需要烧录到外部 Flash. ![nano_20k_flash_mode](./assets/led/nano_20k_flash_mode.png) ### 更多问题前往 [Tang 常见问题](https://wiki.sipeed.com/hardware/zh/tang/Tang Nano Doc/questions.html) 查看"},"/hardware/zh/tang/tang-nano-20k/example/unbox.html":{"title":"Tang Nano 20K 开箱","content":" title: Tang Nano 20K 开箱 keywords: FPGA, Tang, Nano, 20K update: date: 2023 05 22 version: v0.1 author: wonder content: 新建文档 Tang Nano 20K 主要有游戏套餐和普通开发板两种购买选项。 ## 初次通电 Tang Nano 20K 默认的固件内容是 [litex](https://github.com/litex hub) ，并且可以在 [github](https://github.com/sipeed/TangNano 20K example/tree/main/litex) 直接下载固件。 上电后可以看到板卡上的六颗 LED 以流水灯样式运行着。 ![unbox_nano_20k_led_water_flow](./../assets/unbox/unbox_nano_20k_led_water_flow.gif) 通电后 win10 和 win11 会自动加载驱动，然后在电脑的设备管理器中可以看到至少有一个串口设备，这时可以使用 [Mobaxterm](https://mobaxterm.mobatek.net/) 这类支持串口的软件来打开开发板上的串口。 ![unbox_device_manager_serial_port](./../assets/unbox/unbox_device_manager_serial_port.png) 设置波特率为 115200，然后打开开发板上的串口，就能进入默认 litex 固件的终端了。 ![unbox_uart_litex_terminal](./../assets/unbox/unbox_uart_litex_terminal.png) 使用 `Tab` 自动补全命令操作可以看到有一些指令能够让我们直接使用。 ![unbox_uart_litex_command_list](./../assets/unbox/unbox_uart_litex_command_list.png) 以最简单的 leds 为例，输入 `leds` 命令。 ![unbox_uart_litex_leds_command_help](./../assets/unbox/unbox_uart_litex_leds_command_help.png) 可以看到它要求 `leds` 命令后面加上一个 value . 下面是在串口终端中输入了 `leds 62` 后板子上 led 的变化。 ![unbox_uart_litex_leds_command_control](./../assets/unbox/unbox_uart_litex_leds_command_control.png) 可以看到板子上只有一颗 LED 亮起。 ![unbox_uart_litex_leds_command](./../assets/unbox/unbox_uart_litex_leds_command.jpg) 如果输入的数字过大的话，它会在串口提示将 led 状态设置成了 `0xffffffff`。 ![unbox_uart_litex_leds_max_value](./../assets/unbox/unbox_uart_litex_leds_max_value.png) ## 隐藏功能 上面的 litex 相关的终端操作都是在 FPGA 上运行的，Tang Nano 20K 除了 GW2AR 18C FPGA 外，还有一个板载的 BL616 芯片，可以进入它的终端来进行其他操作。 和前面一样，在 Mobaxterm 中打开串口之后，可以使用组合键 `Ctrl + x` 然后 `Ctrl + c`，最后按下回车来进入 BL616 芯片终端。 ![unbox_uart_bl616_terminal](./../assets/unbox/unbox_uart_bl616_terminal.png) 然后按下回车就到了终端了。支持 tab 补全命令。 ![unbox_uart_bl616_command_list](./../assets/unbox/unbox_uart_bl616_command_list.png) 这里主要需要关注 `pll_clk` 和 `choose` 这两个命令。 ### pll_clk Tang Nano 20K 板子上带有一颗 MS5351 精准时钟发生器，它由 BL616 终端的 `pll_clk` 命令来控制。 ![unbox_uart_bl616_pllclk_command](./../assets/unbox/unbox_uart_bl616_pllclk_command.png) MS5351 支持三路时钟输出，在原理图中可以看到以下对应关系： ![unbox_uart_bl616_ms351_clk_pin](./../assets/unbox/unbox_uart_bl616_ms351_clk_pin.png) 上图表示 CLK0 时钟连接到了 FPGA 的 PIN10 引脚，CLK1 时钟连接到了 FPGA 的 PIN11 引脚，CLK2 时钟连接到了 FPGA 的 PIN13 引脚. 配置 CLK1 输出 50M 时钟 `pll_clk O1 50M` <table> <tr> <td><img src \"./../assets/unbox/unbox_uart_bl616_ms351_set_o1_clk_50m.png\" alt \"unbox_uart_bl616_ms351_set_o1_clk_50m\"></td> <td> ① 输入命令后可以看到下面有一些 log <br> ② 再次输入 `pll_clk` 查看当前的配置 <br> ③ 可以看到 O1 目前是 50M 配置 <br> ④ 此处的 [EN] 表示 O1 正常工作，[DIS] 表示被禁用 </td> </tr> </table> 禁用 CLK1 `pll_clk O1` <table> <tr> <td><img src \"./../assets/unbox/unbox_uart_bl616_ms351_disable_o1_clk.png\" alt \"unbox_uart_bl616_ms351_disable_o1_clk\"></td> <td> ① 查看当前配置状态 <br> ② CLK1 正常工作状态 <br> ③ 执行禁用 CLK1 指令 <br> ④ CLK1 被禁用 </td> </tr> </table> 保存配置 `pll_clk s` ![unbox_uart_bl616_ms351_save](./../assets/unbox/unbox_uart_bl616_ms351_save.png) 设置 CLK2 输出 100M 时钟并且保存 `pll_clk O2 100M s` ![unbox_uart_bl616_ms351_clk2_100m](./../assets/unbox/unbox_uart_bl616_ms351_clk2_100m.jpg) ### choose `choose` 命令在 BL616 芯片中的作用是选择 BL616 与 FPGA 的通信方式。 ![unbox_uart_bl616_choose_list](./../assets/unbox/unbox_uart_bl616_choose_list.png) 打开串口时默认使用的是 `uart` 模式。在使用命令 `Ctrl + x`和 `Ctrl + c`，再敲下回车后， BL616 退出串口模式，回到终端模式。 `uart` 模式测试 在 BL616 终端执行 `choose uart` 命令，BL616 与 FPGA 进行串口通信。 ![unbox_uart_bl616_choose_uart](./../assets/unbox/unbox_uart_bl616_choose_uart.png) 输入完命令后终端会看起来卡住了一样，实际上这是因为 FPGA 没有向 BL616 发送串口消息。 默认的固件没有被清除的话，继续敲击回车就会重新回到 litex 终端了。 与前面的叙述一样，使用组合键 `Ctrl + x`和 `Ctrl + c`，再敲下回车后， BL616 退出串口模式，回到终端模式。 ![unbox_uart_bl616_quit_uart_mode](./../assets/unbox/unbox_uart_bl616_quit_uart_mode.png) `spi` 模式测试 SPI 模式时，BL616 作为 FPGA 的 SPI 从机，接收 FPGA 发送过来的数据。 ## 游戏机套装 Tang Nano 20K 可以加载/运行开源 FPGA NES 模拟器 [NESTang](https://github.com/nand2mario/nestang)，下面简述使用步骤。源码可以查看 [Tang Nano 20K nestang github example](https://github.com/sipeed/TangNano 20K example/tree/main/nestang) 或者 [NESTang](https://github.com/nand2mario/nestang)。 ### 硬件准备 一块 Tang Nano 20K 至少一个 Joystick 手柄和手柄转接板 一张 TF 卡与一个读卡器 一个面包板 (用来组合固定住板子) HDMI 显示器 ### 环境准备 Windows：[Gowin Programmer](http://www.gowinsemi.com.cn/faq.aspx) ， [balenaEtcher](https://etcher.balena.io/) 和 `python` Linux: [Openfpgaloader](https://github.com/trabucayre/openFPGALoader) 和 `python` Linux 烧录方法可以参考 [Tang Nano 20K nestang github example](https://github.com/sipeed/TangNano 20K example/tree/main/nestang)，下面主要基于 Windows 系统来说明使用步骤。 ### 烧录 FPGA 固件 使用 [Gowin Programmer](http://www.gowinsemi.com.cn/faq.aspx) 将 [这个固件](https://dl.sipeed.com/shareURL/TANG/Nano_20K/7_Nestang/firmware) 烧录到 FPGA 的 Flash 中。 ![unbox_burn_nestang_firmware_into_flash](./../assets/unbox/unbox_burn_nestang_firmware_into_flash.png) ### 制作游戏镜像 使用 [这些文件](https://dl.sipeed.com/shareURL/TANG/Nano_20K/7_Nestang/script)（都要下载），将想要运行的 NES 游戏 转换成能被 FPGA 识别的文件镜像。 使用下面的命令来将 `1.nes` `2.nes` `3.nes` 三个 NES 游戏转换成游戏镜像文件 (games.img)。 ```bash python nes2img.py o games.img 1.nes 2.nes 3.nes ``` > 提示 PIL 不存在时，手动通过 pip 安装一下。 在当前目录下就有生成的游戏镜像文件 games.img 了。 ### 烧录游戏镜像 在 Tang Nano 20K 上，需要使用 TF 卡来存储游戏，因此需要将游戏镜像文件烧录到 TF 卡。 这里使用 [balenaEtcher](https://etcher.balena.io/) 这个软件。 打开这个软件，选择 `Flash from file`, 选中之前生成的游戏镜像文件 `games.img` <img src \"./../assets/unbox/unbox_burn_nestang_game_image_select_file.png\" alt \"unbox_burn_nestang_game_image_select_file\" width \"48%\"> <img src \"./../assets/unbox/unbox_burn_nestang_game_image_choose_game_image.png\" alt \"unbox_burn_nestang_game_image_choose_game_image\" width \"48%\"> 会弹出一个警告，此时点击继续。 <img src \"./../assets/unbox/unbox_burn_nestang_game_warn_no_partition_table.png\" alt \"unbox_burn_nestang_game_warn_no_partition_table\" width \"48%\"> 接下来选择烧录的 TF 卡，不要选错了盘符。勾选 TF 卡后点击图中 ② 处来结束选择。 <img src \"./../assets/unbox/unbox_burn_nestang_game_change_tfcard_select.png\" alt \"unbox_burn_nestang_game_change_tfcard_select\" width \"48%\"> <img src \"./../assets/unbox/unbox_burn_nestang_game_select_tf_card.png\" alt \"unbox_burn_nestang_game_select_tf_card\" width \"48%\"> 点击烧录，提示烧录成功后就可以取出 TF 卡并且将 TF 卡插入到 FPGA 了。 <img src \"./../assets/unbox/unbox_burn_nestang_game_burn_game_image.png\" alt \"unbox_burn_nestang_game_burn_game_image\" width \"48%\"> <img src \"./../assets/unbox/unbox_burn_nestang_game_finish_burn_game_image.png\" alt \"unbox_burn_nestang_game_finish_burn_game_image\" width \"48%\"> ### 组装板子 插入 TF 卡到板子中 ![unbox_burn_nestang_game_tf_card_onsert](./../assets/unbox/unbox_burn_nestang_game_tf_card_onsert.jpg) 将板卡和手柄转接板都连接在面包板上 ![unbox_burn_nestang_game_breadboard_connecting](./../assets/unbox/unbox_burn_nestang_game_breadboard_connecting.jpg) 注意上图的红色直线，那表明了手柄转接板与 FPGA 应当对应的引脚 连接上手柄和 HDMI 线 ![unbox_burn_nestang_game_connect_hdmi_cable](./../assets/unbox/unbox_burn_nestang_game_connect_hdmi_cable.jpg) > 连接双手柄时，玩家 ① 使用的是上图中右侧的手柄 ### 开始游戏 给 Tang Nano 20K 通上电，然后会显示出游戏菜单，里面的游戏数量和名称都是根据制作游戏镜像文件时所使用的 NES 游戏文件和名称来生成的。 ![unbox_burn_nestang_power_game](./../assets/unbox/unbox_burn_nestang_power_game.jpg) 按下手柄上的 `②` 或者 `O` 来启动游戏 按下 FPGA 板子上的 `S1` 来重新进入游戏选单 ## 编程使用 手把手教上手点灯 > [点我](https://wiki.sipeed.com/hardware/zh/tang/tang nano 20k/example/led.html)"},"/hardware/zh/tang/tang-nano-20k/example/led.html":{"title":"Tang Nano 20K 点灯","content":" title: Tang Nano 20K 点灯 keywords: FPGA, Tang, Nano, 20K update: date: 2023 03 24 version: v0.1 author: wonder content: 新建文档 这里我们用点亮板子上的LED来作为例程来快速熟悉一下高云半导体 IDE 的使用流程 对于软件开发来说，输出 `hello world` 就是入门了。对于硬件相关的开发而言，点灯就是同款入门。 ## 安装 IDE 参考 [安装IDE](https://wiki.sipeed.com/hardware/zh/tang/Tang Nano Doc/get_started/install the ide.html) 来完成我们需要准备的软件环境。 对于 Linux 用户的话建议使用 [openfpgaLoader](https://wiki.sipeed.com/hardware/zh/tang/Tang Nano Doc/get_started/flash_in_linux.html) 这软件来烧录这款设备。 ## 新建工程 文件 > 新建 > FPGA Design > Project <div> <img src \"./../../tang primer 20k/examples/assets/led_assets/new_project.png\" width 58% alt \"new_project\"> <img src \"./../../tang primer 20k/examples/assets/led_assets/fpga_project.png\" width 35% alt \"fpga_project\"> </div> 设置工程名称，要求只用英文的下划线命名，存放路径中不要有中文字符或者空格等特殊符号。 ![project_path](./../../tang primer 20k/examples/assets/led_assets/project_path.png) 然后在下面的芯片型号中选择 GW2AR LV18QN88C8/I7，使用上面的筛选能够更快地选择到正确的型号。注意 Device 那一栏为 GW2A 18C ![device_choose](./../assets/led/nano_20k_device_device_choose.png) 然后点击确定后就可以进行最终项目预览了。确认无误后就完成工程创建了。 ## 编写代码 ### 新建文件 高云半导体 IDE 提供了三种新建文件的方法。在此我们直接使用快捷键 `Ctrl + N` 来新建文件，其他两种不在此讲述。 在弹出的窗口中选择 `Verilog File`，会 VHDL 的也可以选择下面的 `VHDL File`，这篇文章只用 Verilog 来做点灯示例。 <img src \"./../../tang primer 20k/examples/assets/led_assets/new_verilog_file.png\" width 50% alt \"new_verilog_file\"> 点击 OK 之后会提示让我们输入文件名称，此处以 `led` 为文件名做示范。 <img src \"./../../tang primer 20k/examples/assets/led_assets/file_name.png\" width 75% alt \"file_name\"> 到这里我们就完成文件的创建了，可以直接编写代码了。 ![nano_20k_created_file.png](./../assets/led/nano_20k_created_file.png.png) ### Verilog 简单说明 Verilog 是一种硬件描述语言，用来对数字电路进行抽象化描述。 Verilog 的基本设计单元是“模块”(module)。 一个模块是由两部分组成的：一部分描述接口，另一部分描述内部逻辑功能，即定义输入是如何影响输出的。 一个模块长成这样： ```v module module_name #(parameter) (port) ; function endmodule ``` 模块整体结构由 module 和 endmodule 组成，module 后面跟着的是模块的名称(module_name)，可传递变量参数(parameter)，端口及其方向的申明(port)，紧接着就是内部逻辑功能描述(function) ,最后用 endmodule 来表示这一个模块，描述完毕。 内部逻辑功能通常由 assign 和 always 块完成；其中 assign 语句描述逻辑功能，always 块常用于描述时序功能。 ### 阻塞赋值与非阻塞赋值 在时序逻辑描述中，赋值符号有 ` ` 和 `< ` 两种。注意 `< ` 在 if 判断语句中为小于或等于，不是赋值符号。 详细解释查看底部的 [阻塞赋值与非阻塞赋值区别](#阻塞赋值与非阻塞赋值区别) ### 代码思路 写代码前我们需要先想清楚代码目的：每隔 0.5S 灯闪一次。 对此所画的需求框图如下： ![block_method](./../../tang primer 20k/examples/assets/led_assets/block_method.png) 然后对于 0.5S 我们需要一个计数器来计时，LED 灯闪就是 IO 翻转 ![count_block](./../../tang primer 20k/examples/assets/led_assets/time_count.png) 把上面的思维框图具体到实际使用的话，就变成下面的样式了: ![clock_time_count](./../../tang primer 20k/examples/assets/led_assets/clock_time_count.png) 其中 Clock 为时钟源，用来给计时器提供准确的时间。 ### 代码描述 根据上文 Verilog 简单说明和所描述的框图，可以所要编写 Verilog 模块有 Clock 和 IO电平 两个端口； ```v module led( input Clock, output IO_voltage ); endmodule ``` 对于内部的计时模块，Primer 20K 核心板上的晶振为 27MHZ，因此我们每秒钟会有 27000000 个时钟上升沿，想要 0.5S 计数的话那么只需要计数 13500000 次上升沿就好。计数是从 0 开始的，数 13500000 的话就是从 0 数到 13499999。计数完后我们需要设置一个标志位，来通知 LED 的 IO 翻转一下电平。整体计数代码如下： ```v //parameter Clock_frequency 27_000_000; // 时钟频率为27Mhz parameter count_value 13_499_999; // 计时 0.5S 所需要的计数次数 reg [23:0] count_value_reg ; // 计数器 reg count_value_flag; // IO 电平翻转标志 always @(posedge Clock) begin if ( count_value_reg < count_value ) begin //没有计数到 0.5S count_value_reg < count_value_reg + 1'b1; // 继续计数 count_value_flag < 1'b0 ; // 不产生翻转标志 end else begin //计数到 0.5S 了 count_value_reg < 23'b0; // 清零计数器，为重新计数最准备 count_value_flag < 1'b1 ; // 产生翻转标志 end end ``` 对于 LED IO 电平翻转代码如下： ```v reg IO_voltage_reg 1'b0; // 声明 IO 电平状态用于达到计时时间后的翻转，并赋予一个低电平初始态 always @(posedge Clock) begin if ( count_value_flag ) // 电平翻转标志有效 IO_voltage_reg < ~IO_voltage_reg; // IO 电平翻转 else // 电平翻转标志无效 IO_voltage_reg < IO_voltage_reg; // IO 电平不变 end ``` 将上面的代码整合后就变成了下面的内容: ```v module led( input Clock, output IO_voltage ); /**********计时部分**********/ //parameter Clock_frequency 27_000_000; // 时钟频率为27Mhz parameter count_value 13_499_999; // 计时 0.5S 所需要的计数次数 reg [23:0] count_value_reg ; // 计数器 reg count_value_flag; // IO 电平翻转标志 always @(posedge Clock) begin if ( count_value_reg < count_value ) begin //没有计数到 0.5S count_value_reg < count_value_reg + 1'b1; // 继续计数 count_value_flag < 1'b0 ; // 不产生翻转标志 end else begin //计数到 0.5S 了 count_value_reg < 23'b0; // 清零计数器，为重新计数最准备 count_value_flag < 1'b1 ; // 产生翻转标志 end end reg IO_voltage_reg 1'b0; // 声明 IO 电平状态用于达到计时时间后的翻转，并赋予一个低电平初始态 /**********电平翻转部分**********/ always @(posedge Clock) begin if ( count_value_flag ) // 电平翻转标志有效 IO_voltage_reg < ~IO_voltage_reg; // IO 电平翻转 else // 电平翻转标志无效 IO_voltage_reg < IO_voltage_reg; // IO 电平不变 end /**********补充一行代码**********/ assign IO_voltage IO_voltage_reg; endmodule ``` 上面代码最后面补充了一行代码，是因为 IO_voltage 声明在了 port 位置，默认为 wire 型，想要将它与 reg 变量 IO_voltage_reg 连接起来，需要用到 assign 语句。 ## 综合，约束，布局布线 ### 综合 代码保存后，可以双击 IDE 内部的 Process > Synthesize 来进行代码综合，将 verilog 代码内容转换为综合网表。 ![synthesize](./../../tang primer 20k/examples/assets/led_assets/synthesize.png) 关于网表有兴趣的可以自己去查阅相关资料，此处不再额外说明。 ### 约束 综合完之后我们需要进行管脚约束，才能将所编写的模块端口与 FPGA 引脚相对应，并且实现模块的功能。 点击上图 Synthesize 上面的 FloorPlanner 来进行管脚约束。 ![floorplanner](./../../tang primer 20k/examples/assets/led_assets/floorplanner.png) 由于是首次创建，所以会弹出下面的对话框，点击 OK 后就弹出了图形化约束交互界面。 ![create_constrain_file](./../../tang primer 20k/examples/assets/led_assets/create_constrain_file.png) ![nano_20k_floorplanner_interface](./../assets/led/nano_20k_floorplanner_interface.png) 关于约束的方法可以查看 [SUG935 1.3_Gowin设计物理约束用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG935 1.3_Gowin%E8%AE%BE%E8%AE%A1%E7%89%A9%E7%90%86%E7%BA%A6%E6%9D%9F%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) 此处因个人喜所以仅使用下图中 IO Constranins 方法来约束引脚： ![floor_planner_ioconstrain](./../../tang primer 20k/examples/assets/led_assets/floor_planner_ioconstrain.png) 根据[核心板原理图](https://dl.sipeed.com/fileList/TANG/Primer_20K/02_Schematic/)，我们可以知道晶振所输入的引脚为 PIN04。 <img src \"./../assets/led/nano_20k_crystal_port.png\" alt \"nano_20k_crystal_port\" width 45%> 结合原理图上 LED 所连接的引脚，这里只对 LED0 进行操作 ![nano_20k_led_port](./../assets/led/nano_20k_led_port.png) 因此对于在 FloorPlanner 交互窗口下面的 IO Constranins 中将 PORT（端口）与 Location（引脚） 分别填入下面的值： ![nano_20k_io_constrain_value](./../assets/led/nano_20k_io_constrain_value.png) 输入完毕后快捷键 Ctrl + S 来保存一下引脚约束，然后接可以关闭 FloorPlanner 的交互图形界面了。 接着发现在工程项目里面多出来刚刚创建的 cst 文件了，里面的内容也比较好理解。 ![nano_20k_cst_content](./../assets/led/nano_20k_cst_content.png) ### 布局布线 完成约束后就要开始运行布局布线了，目的是为了把综合所生成的网表与我们自己定义的约束来通过 IDE 算出最优解然后将资源合理地分配在 FPGA 芯片上。 双击下图红框处的 Place&Route 就开始运行了。 ![nano_20k_place_route](./../assets/led/nano_20k_place_route.png)。 紧接着没有报错，全部通过。就可以开始进行烧录了。 ## 烧录固件 Tang Nano 20K 板卡上搭载了 BL616 芯片，用来烧录 FPGA 固件到板卡中。 在 [安装IDE](https://wiki.sipeed.com/hardware/zh/tang/Tang Nano Doc/get_started/install the ide.html) 的时候已经安装了驱动。因此我们将板子与电脑连接起来就行。 ![nano_20k_led_connect_debug](./../assets/led/nano_20k_led_connect_debug.png) ### 扫描设备 双击下图中的下载程序(Program Device) 来运行 Programmer 软件 ![open_programmer](./../../tang primer 20k/examples/assets/led_assets/open_programmer.png) 然后在打开的页面中点击一下 scan_device 来扫描到我们的设备。 ![nano_20k_scan_device](./../assets/led/nano_20k_scan_device.png) 点击 OK 后就可以接下来对 FPGA 进行操作了。 烧录相关的文档可以参考 [SUG502 1.3_Gowin_Programmer用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG502 1.3_Gowin_Programmer%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) ### 下载到 SRAM 一般来说这个模式是以用来快速验证所生成的固件是否满足自己目的的。 因为其烧录快的特性所以使用的较多，然是当然断电会丢失数据，所以如果想上电运行程序的话是不能选这个的。 点击 Operation 下面的功能框来打开设备设置界面，接着在 Operation 框中选择 SRAM Program 选项来设置为下载到 SRAM ，最后点击下面的那三个点点框来选择我们所生成的 .fs 下载固件。通常来说下载固件生成与工程文件目录下的 impl > pnr 目录下。 ![sram_mode](./../assets/led/nano_20K_sram_mode.png) 接着来点击红框处开始进行烧录 ![nano_20k_sram_download](./../assets/led/nano_20k_sram_download.png) 有问题的话可以前往 [常见问题](https://wiki.sipeed.com/hardware/zh/tang/Tang Nano Doc/questions.html) 自行排查。 到这里就下载完成了。 ### 下载到 Flash 上面说过下载到 SRAM 是为了快速验证，但是不能上电运行程序。 所以想要上电运行的话我们需要设置下载到 Flash。 和上面下载到 SRAM 的步骤几乎类似，先点开 Operation 下面的功能框来打开设备设置界面，接着在 Operation 框中选择 External Flash Mode 选项来设置为下载到外部 Flash ，最后点击下面的那三个点点框来选择我们所生成的 .fs 下载固件，通常来说下载固件生成与工程文件目录下的 impl > pnr 目录下。最后在下面的外部 Flash 选项中选择设备为 Generic Flash 。 ![nano_20k_flash_mode](./../assets/led/nano_20k_flash_mode.png) 接着来点击红框处开始进行烧录 ![nano_20k_flash_download](./../assets/led/nano_20k_flash_download.png) 然后我们的程序重新上电也能照样运行了。 ## 代码结果 如图所示，只有一个灯在闪。 ![nano_20k_led_blink](./../assets/led/nano_20k_led_blink.gif) ## 结语 到这里我们就已经完成了 FPGA 的 “Hello world” 了。以后的示例工程不会再叙述新建文件等操作了。 ## 阻塞赋值与非阻塞赋值区别 以下内容搬运自 `大猪蹄子` （有改动）： 编写一段简单的代码，对它进行简单的仿真： ```v module test( input CLK, input [3:0] A, output reg [3:0] B,C,D,E ); always@(posedge CLK) begin B < A; C < B; D A; E D; end endmodule ``` ![simulation_result](./../../tang primer 20k/examples/assets/led_assets/simulation_result.png) 根据仿真结果我们可以看出阻塞和非阻塞赋值的差别。这里对比 `B` `C` `D` `E` 四种结果。`< ` 叫做非阻塞赋值，同一个 `always` 中的 `< ` 会同时执行。这就造成了绿框内的情况：`B` 直接被赋予 `A` 的值同时 `C` 被赋予 `B` 的值。由于这两步是同时进行的，就导致 `C` 被赋予的值是 `B` 的旧值，也就造成了图中所示，`C` 的数据变化时钟要慢 `B` 一个时钟周期。再说阻塞赋值 ` `，也就是说同一个 `always` 中上一个 ` ` 语句执行完才会执行下一个 ` ` 语句。在这个代码中，上一个语句 `D` 已经被赋予了 `A` 的值，才执行把 `D` 的值赋给 `E`，所以 `D` 、`E` 的值在仿真中始终保持一致。 > 不过一般来说，不建议在时序逻辑中使用阻塞赋值 ` `。 也得出了额外两个结论： 第一，输入的数据不是完全有效，以时钟边沿时刻的输入数据为准。`posedge` 就是以上升沿执行，`negedge` 就是以下降沿执行。如果数据维持的时间小于一个时钟周期，就很有可能采集不到（如红框所示）。 第二、每次触发特定时钟边沿，对应的 `always` 块就会从头到尾执行一次代码（如绿框所示），而不是从中间某处执行。 ## 常见问题 前往 [Gowin 板卡常见问题查看](./../../Tang Nano Doc/questions.html)"},"/hardware/zh/tang/Tang-primer/Tang-primer.html":{"title":"Tang Primer","content":"# Tang Primer ## 介绍 Lichee Tang Primer是基于安路科技的EG4S20BG256 FPGA芯片设计的简约型开发板。开发板设计小巧精致，将芯片的所有资源都引出，板载Micro USB、USB JTAG、TF卡槽、DVP摄像头接口、RGB(可接LCD屏、VGA等外设)等，并把部分IO资源引出，非常方便开发者拓展使用，开放RISC V IP内核。 ![Tang_permier](./../../../assets/Tang/permier/Tang_permier_1.png) ## 管脚定义 ![Tang_permier_2](./../../../assets/Tang/permier/Tang_permier_2.png) ![Tang_permier_3](./../../../assets/Tang/permier/Tang_permier_3.png) ## 参数 项目 参数 FPGA芯片 EG4S20BG256 逻辑单元数量 23520 寄存器数量(FF) 19600 Total Configuration SRAM (bits) 4,988,928 EM SDR SDRAM 2M X 32bits 锁相环PLL 1 I/O Bank总数 1 最多用户I/O数 193 核电压 1.2V 板载FPC40P座 可接RGB LCD、VGA转接口、高速DAC等模块 板载FPC20P座 可接DVP摄像头、高速ADC模块 引出IO 标准2.54mm和半邮票孔接口，引出芯片大部分IO资源 板载IIC电阻触摸芯片屏控制器 NS2009 ## 产品技术支持 Tang Permier开发板可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务support@sipeed.com。 ## 资料 [烧录相关使用](/soft/Tang/zh/index_bak.md) [资料下载](https://dl.sipeed.com/shareURL/TANG/Primer)"},"/hardware/zh/tang/Tang-primer/index.html":{"title":"荔枝糖 全流程指南","content":"# 荔枝糖 全流程指南 荔枝糖，一款极致打磨的国产开源RISC V开发板。 荔枝糖萌生于国内芯片振荡之潮，历经三个月的生长与蜕变，终于在七月，登上开源的舞台。 荔枝糖不仅担起开源开发者们的期待，更志向于在国内推广RISC V架构相关的开发与教育，向世界介绍中国的一款优秀开发板。 ![](./../assets/material.png) 荔枝糖使用 安路科技(Anlogic Technologies) 的 EG4S20 作为核心单元, **20K逻辑单元(LUT4/LUT5混合架构)，约130KB SRAM，内置32bit位宽 64MBit SDRAM，丰富的LVDS引脚，内置12 bit 1MSPS ADC**，这为荔枝糖提供了无限的可能性： FPC40P座，可接 RGB LCD，VGA转接板，高速DAC模块 FPC24P座，可接DVP摄像头，高速ADC模块 I2C接口的电阻触摸屏控制器，配合RGB LCD使用 3路DCDC电源芯片，稳定高效的电源供应，Bank0 IO电平独立可调 FPGA 配置Flash，8Mbit 用户Flash，nor/nand可选 板载FPGA JTAG下载调试器 RGB LED 相邻插针LVDS等长引出，引出8路GCLK，全引出8路ADC。 双排插针间距900mil， **兼容面包板开发** 半孔引出额外 **40 IO**，整板引出 **130+ IO** 。 ![荔枝糖资源图](./../assets/E203_function.png) ![荔枝糖引脚图(旧板,底面丝印较小版本)](./../assets/E203_pin.png) ![ 荔枝派引脚图(新板,底面丝印较大版本)](./../assets/Lichee tang_NewIoMap.png) 您可能需要这些来进一步了解荔枝糖： EG4S20Datasheet [点我](https://dl.sipeed.com/shareURL/TANG/Primer/HDK/Datasheet/)里面的`EG4S20_DataSheet_V1.4.pdf` 荔枝糖原理图 [点我](https://dl.sipeed.com/shareURL/TANG/Primer/HDK)里面的`LicheeTang_RV(Schematic).pdf` 荔枝糖仍在不断地成长，对于外观、电路设计、文档内容甚至于荔枝糖的发展方向， 我们欢迎您到[荔枝糖 建议与讨论帖](https://bbs.sipeed.com/cate/30/seq/1) 提出您宝贵的建议。 同时欢迎各位加入荔枝派交流群 `834585530` 或者 [荔枝派Telegram电报群](https://t.me/sipeed)与众多开发者、爱好者即时交流。 另外，FPGA开发环境TD (Tang Dynasty) 可在如下网址下载： <! [https://eyun.baidu.com/s/3i6FbQzr](https://eyun.baidu.com/s/3i6FbQzr) > [https://dl.sipeed.com/shareURL/TANG/Primer/IDE](https://dl.sipeed.com/shareURL/TANG/Primer/IDE)"},"/hardware/zh/tang/Tang-primer/Tang-primer-summary.html":{"title":"Tang Primer","content":"# Tang Primer Tang Primer 系列 FPGA 是 Sipeed 使用国产 FPGA 芯片作为主控所设计的大容量板卡。 <table> <thead> <tr> <th>Tang primer 20K</th> <th>Tang primer </th> </tr> </thead> <tr> <td><a href \"./../tang primer 20k/primer 20k.html\"><img src \"./../tang primer 20k/assets/primer_20k.png\" width 320></a></td> <td><a href \"./Tang primer.html\"><img src \"./../../../assets/Tang/permier/Tang_permier.jpg\" width 320></a></td> </tr> </table>"},"/hardware/zh/tang/Tang-primer/fpga/ics/codec.html":{"title":"FPGA驱动CODEC","content":" title: FPGA驱动CODEC 待补充。。。"},"/hardware/zh/tang/Tang-primer/fpga/ics/dac908.html":{"title":"FPGA驱动DAC908","content":" title: FPGA驱动DAC908 待补充。。。"},"/hardware/zh/tang/Tang-primer/fpga/ics/adc9288.html":{"title":"FPGA驱动ADC9288","content":" title: FPGA驱动ADC9288 待补充。。。"},"/hardware/zh/tang/Tang-primer/fpga/ics/usb3300.html":{"title":"FPGA驱动USB3300","content":" title: FPGA驱动USB3300 待补充。。。"},"/hardware/zh/tang/Tang-primer/fpga/sdram.html":{"title":"FPGA驱动SDRAM","content":" title: FPGA驱动SDRAM 待补充。。。"},"/hardware/zh/tang/Tang-primer/fpga/display/av.html":{"title":"FPGA驱动AV显示器","content":" title: FPGA驱动AV显示器 待补充。。。"},"/hardware/zh/tang/Tang-primer/fpga/display/hdmi.html":{"title":"FPGA驱动HDMI","content":" title: FPGA驱动HDMI 待补充。。。"},"/hardware/zh/tang/Tang-primer/fpga/display/vga.html":{"title":"FPGA驱动VGA","content":" title: FPGA驱动VGA 待补充。。。"},"/hardware/zh/tang/Tang-primer/fpga/display/lcd.html":{"title":"FPGA驱动LCD","content":" title: FPGA驱动LCD 待补充。。。"},"/hardware/zh/tang/Tang-primer/fpga/dvp.html":{"title":"FPGA驱动DVP","content":" title: FPGA驱动DVP 待补充。。。"},"/hardware/zh/tang/Tang-primer/fpga/ics.html":{"title":"FPGA驱动其他IC","content":" title: FPGA驱动其他IC \\> maxdepth \\> : 2 \\> \\> ics/adc9288 ics/dac908 ics/codec ics/usb3300"},"/hardware/zh/tang/Tang-primer/fpga/led.html":{"title":"FPGA点灯","content":" title: FPGA点灯 ## 源码下载 请到 github 下载全部工程，地址为 [https://github.com/Lichee Pi/Tang_FPGA_Examples/](https://github.com/Lichee Pi/Tang_FPGA_Examples/) ## Verilog代码 ```v module led ( input wire CLK_IN, //时钟输入，24MHz input wire RST_N, //复位按键输入，低有效 output wire [2:0]RGB_LED //RGB led输出 ); parameter time1 24’d24_000_000;//晶振为24Mhz，这里表示计数一秒 reg [2:0]rledout; reg [23:0] count; reg [1:0]shift_cnt; initial begin count 24’b0; rledout 3’b1; shift_cnt 2’b0; end always @(posedge CLK_IN)begin if(RST_N 0)begin //复位按键按下就清空计数并清空输出 count < 24’b0; rledout < 3’b1; shift_cnt < 2’b0; end if(count time1) //计数时间到 begin count< 24’d0; //清空计数值 if(shift_cnt 2’b10)begin //移位3次 rledout < 3’b1; shift_cnt < 2’b0; end else begin rledout < {rledout[1:0],1’b0}; //led输出移位 shift_cnt < shift_cnt + 1’b1; end end else count < count + 1’b1; //计数累加 end assign RGB_LED rledout; endmodule ``` 上面的代码输入完且保存后，综合一下，接着自己对照板子原理图进行管脚约束。在生成比特流下载到fpga，可以看到板上的rgb led会移位闪烁。（emmm，闪烁效果太差，如果你有更好的可以发过来。(╯︵╰)"},"/hardware/zh/tang/Tang-primer/fpga/opencores.html":{"title":"FPGA 运行其他软核","content":" title: FPGA 运行其他软核 待补充。。。"},"/hardware/zh/tang/Tang-primer/fpga/display.html":{"title":"FPGA外接常用显示接口","content":" title: FPGA外接常用显示接口 \\> maxdepth \\> : 2 \\> \\> display/lcd display/vga display/av display/hdmi"},"/hardware/zh/tang/Tang-primer/get_started/install_TD_win.html":{"title":"Windows的开发环境安装","content":"# Windows的开发环境安装 > 修改于2022.04.22 ## 安装TD 想要进行FPGA开发需要安装TD，可以通过[下载站](https://dl.sipeed.com/shareURL/TANG)，下载TD安装包和license。 <! ，如果下载速度过慢，建议使用[百度网盘](https://eyun.baidu.com/s/3htTXfaG)进行下载 > 安装包 ：`TD_5.0.4_27252_Win7_64bit_NL.msi` License文件：`Anlogic_20230606.lic` 双击打开第一个文件进行安装，安装结束之后将 Anlogic_20230606.lic 修改成Anlogic.lic放到对应安装目录的TD5.0.27252\\license中 然后可以运行TD软件 ## 安装usb串口 将 Tang Primer 插入您的计算机并打开设备管理器以查看信息。 根据 Windows 版本不同，它可能被命名为 WinUsb Device 或 USB JTAG Cable。 确保 USB VID:PID 为 0547:1002 win7系统没有安装驱动时 ![no_driver](./../../assets/get_started/no_driver.png) win10系统没有安装驱动时 ![no_driver_win10](./../../assets/get_started/no_driver_win10.png) ### win7安装驱动 双击 WinUsb Device 选择更新驱动程序 ![update_drive1](./../../assets/get_started/update_driver1.png) ![update_drive2](./../../assets/get_started/update_driver2.png) 浏览文件夹，选择TD安装目录下的驱动目录。 单击确定开始安装 ![choosefolder](./../../assets/get_started/choosefolder.png) 安装成功，在设备管理器中可以看到 ![installsuccess](./../../assets/get_started/installsuccess.png) ### win10安装驱动 > 在安装驱动程序本身之前，请确保首先禁用驱动程序签名强制，否则 Windows 10 将不允许您安装来自 Anlogic 的未签名驱动程序 双击 WinUsb Device 选择更新驱动程序 ![update_drive1](./../../assets/get_started/update_driver1_win10.png) ![update_drive2](./../../assets/get_started/update_driver2_win10.png) 浏览文件夹，选择TD安装目录下的driver\\win8_10_64目录。 单击确定。 然后单击让我从计算机上的可用驱动程序列表中选择 ![choosefolder](./../../assets/get_started/choosefolder_win10.png) 单击Have Disk...，然后选择您在上一步中选择的目录，然后单击OK ![install_from_disk_win10](./../../assets/get_started/install_from_disk_win10.png) 安装成功，在设备管理器中可以看到 ![installsuccess](./../../assets/get_started/installsuccess.png) ## 验证安装 打开TD，点击下载,如图所示 ![](./../../assets/get_started/87078310026779781.jpg) 将 Tang Primer 插入您的计算机，然后点击下载对话框上的刷新按钮 ![](./../../assets/get_started/1823555291194601.jpg) 出现上图的信息，则表示安装且激活成功"},"/hardware/zh/tang/Tang-primer/get_started/E203.html":{"title":"搭建蜂鸟开发环境","content":"# 搭建蜂鸟开发环境 Note 现已经做好了 虚拟机镜像 链接：[https://dl.sipeed.com/shareURL/TANG/Primer/vmware](https://dl.sipeed.com/shareURL/TANG/Primer/vmware)，可直接使用 ## 下载交叉编译工具链 百度网盘链接为: [https://pan.baidu.com/s/1eUbBlVc](https://pan.baidu.com/s/1eUbBlVc) 由于这里提供的openocd不支持LicheeTang使用的flash型号，所以进行了一些修改; 请[下载](https://fdvad021asfd8q.oss cn hangzhou.aliyuncs.com/LicheeTang/get_started/openocd) 新的进行替换 ## 配置工作环境 1. 从github下载e200_opensource ```bash git clone https://github.com/SI RISCV/e200_opensource.git ``` 2. 将 sirv e203 lichee.tar.gz 解压至 e200_opensource/sirv e sdk/bsp/env 目录下 <! (https://fdvad021asfd8q.oss cn hangzhou.aliyuncs.com/LicheeTang/get_started/sirv e203 lichee.tar.gz) > 将下载好的交叉工具编译链以及 openocd 解压(记得使用新的openocd替换)，在 e200_opensource/sirv e sdk/work 目录下将其分别软连接到: ```sh . └── build ├── openocd │ └── prefix │ └── bin > /opt/riscv/gnu mcu eclipse/openocd/0.10.0 6 20180112 1448/bin/ └── riscv gnu toolchain └── riscv32 unknown elf └── prefix └── bin > /opt/riscv/gnu mcu eclipse/riscv none gcc/7.2.0 2 20180111 2230/bin/ ``` ## 蜂鸟的调试 我们使用ft2232d与openocd进行蜂鸟的调试，所以需要进行一些配置 将ft2232d插入电脑，执行lsusb，可看到一下信息 ```bash Bus 003 Device 019: ID 0403:6010 Future Technology Devices International, Ltd FT2232C Dual USB UART/FIFO IC ``` 新建 udev rules,使 ft2232d 能够被 plugde group 访问 vim /etc/udev/rules.d/45 ft2232.rules ATTR{idVendor} \"0403\", ATTR{idProduct} \"6010\", MODE \"660\", GROUP \"plugdev\" 查看该设备是否属于 plugdev ls l /dev/ttyUSB1 crw rw 1 root plugdev 188, 1 7月 11 09:13 /dev/ttyUSB1 将你自己的用户添加到 plugdev group 中 whoami sudo usermod –a –G plugdev your user name 确认你自己的用户是否属于 plugdev group groups ## 编译下载demo程序 编译下载demo程序，可参考文件夹下的demo_gpio.tar.gz在e200_opensource/sirv e sdk目录下执行 ```bash make software PROGRAM demo_gpio BOARD sirv e203 lichee #编译 ``` ```bash make upload PROGRAM demo_gpio BOARD sirv e203 lichee #上传 ``` ## 调试 打开两个terminal，一个运行openocd，另外一个运行gdb ```bash make run_openocd PROGRAM demo_gpio BOARD sirv e203 lichee #运行openocd ``` ```bash make run_gdb PROGRAM demo_gpio BOARD sirv e203 lichee #运行gdb ``` `Tip 可能写的不是很清楚，如果有任何疑问欢迎提出，或者参看胡大的《手把手教你设计CPU：RISC V处理器》（已经上市，请在京东、淘宝、当当上搜索 RISC V关键字）`"},"/hardware/zh/tang/Tang-primer/get_started/fpga_download.html":{"title":"FPGA码流烧录","content":"# FPGA码流烧录 <font size 5>**Attention!! 下载码流需要先保证驱动安装成功**</font> 1. 打开TD软件，选择 download ![](https://fdvad021asfd8q.oss cn hangzhou.aliyuncs.com/migrate/E203_TD_download.png) 2. 添加 bitstream文件，选择 [LicheeTangNewIoMap_BitStream.bit](https://fdvad021asfd8q.oss cn hangzhou.aliyuncs.com/LicheeTang/LicheeTangNewIoMap_BitStream.bit) 或其他码流文件 ![](https://fdvad021asfd8q.oss cn hangzhou.aliyuncs.com/migrate/E203_TD_add.png) 3. 如果 Mode 为 JTAG，断电后则丢失程序。为了上电自动启动，需要选择 PROGRAM FLASH 。（时间较长） 4. E203源码已开放，如果需要进行IO修改，或者功能修改，请使用源码自行进行修改。可以到 [Github](https://github.com/Lichee Pi/Tang_E203_Mini.git) 下载。 5. FPGA例程已上传，请到 [Tang_FPGA_Examples](https://github.com/Lichee Pi/Tang_FPGA_Examples.git) 下载。"},"/hardware/zh/tang/Tang-primer/get_started/install_Linux.html":{"title":"Linux的开发环境安装","content":"# Linux的开发环境安装 ## 安装TD 想要进行FPGA开发需要安装TD，可以通过[下载站](https://dl.sipeed.com/shareURL/TANG/Premier/IDE)，下载TD安装包和license。 <! 如果下载速度过慢的时候，建议使用[百度网盘](https://eyun.baidu.com/s/3i6FbQzr)进行下载 > 对应应下载的IDE名称为 `TD_5.0.3_28716_NL_Linux.zip` License文件：`Anlogic_20230606.lic` 双击打开第一个文件进行安装，安装结束之后将 Anlogic_20230606.lic 修改成Anlogic.lic放到对应安装目录的TD5.0.27252/license中 下载完程序后，打开终端并 cd 进入TD压缩包所在的目录。 ```bash cd <安装程序存档目录的路径 > ``` 在linux中 /opt 目录是为所有不属于默认安装的软件和附加包保留的。 在这里我们为 TD创建一个安装目录 ```bash sudo mkdir /opt/TD_DECEMBER2018 ``` 将 TD 解压到 /opt/TD_DECEMBER2018 目录中： ```bash sudo tar xvf TD_5.0.3_28716_NL_Linux.zip d /opt/TD_DECEMBER2018/ ``` ## 检查默认linux驱动 将 Tang Primer 连接上电脑，执行lsusb命令然后查看信息。确定 USB VID:PID 为 0547:1002，如下图中的显示 ![](./assets/USB_VID.jpg) ## 新建一个udev文件 新建一个udev文件能够让Tang Primer被插件搜索到， 在终端中执行以下命令以创建新的 udev 规则文件。 ```bash sudo nano /etc/udev/rules.d/91 anlogic jtag.rules ``` 将下面的内容复制到上面新建的文件中。 ``` SUBSYSTEMS \"usb\", ATTRS{idVendor} \"0547\", ATTRS{idProduct} \"1002\", \\ GROUP \"plugdev\", \\ MODE \"0660\" ``` 在终端中执行下面的命令来重启udev服务 ```bash sudo service udev restart ``` ## 检查设备能否被TD检测到 在td所在路径解压目录指定下面命令来打开gui界面 ```bash ./td gui ``` 点击下图中框出来的下载按钮 ![](./assets/td_linux_gui.jpg) 将开发板与电脑连接，点击下载界面的刷新按钮 ![](./assets/refresh.jpg) > 有奇怪的bug，导致JTAG只能在 400kbps 或者更低的速率运行"},"/hardware/zh/tang/Tang-primer/e203/peripherals.html":{"title":"蜂鸟外设简介","content":" title: 蜂鸟外设简介 待补充。。。"},"/hardware/zh/tang/Tang-primer/e203/rv_ip.html":{"title":"蜂鸟添加外设","content":" title: 蜂鸟添加外设 待补充。。。"},"/hardware/zh/tang/Tang-primer/e203/sensor.html":{"title":"蜂鸟外挂传感器","content":" title: 蜂鸟外挂传感器 待补充。。。"},"/hardware/zh/tang/Tang-primer/e203/display/oled.html":{"title":"OLED屏幕","content":" title: OLED屏幕 待补充。。。"},"/hardware/zh/tang/Tang-primer/e203/display/lcd1602.html":{"title":"1602屏幕","content":" title: 1602屏幕 待补充。。。"},"/hardware/zh/tang/Tang-primer/e203/display/spi_tft.html":{"title":"SPI\\_MCU彩屏","content":" title: 'SPI\\_MCU彩屏' 待补充。。。"},"/hardware/zh/tang/Tang-primer/e203/ft2232.html":{"title":"FT2232使用简明教程","content":" title: FT2232使用简明教程 待补充。。。"},"/hardware/zh/tang/Tang-primer/e203/led/pwm_led.html":{"title":"呼吸灯","content":" title: 呼吸灯 待补充。。。"},"/hardware/zh/tang/Tang-primer/e203/led/ws2812.html":{"title":"WS2812灯带","content":" title: WS2812灯带 待补充。。。"},"/hardware/zh/tang/Tang-primer/e203/led/led.html":{"title":"RGB LED","content":" title: RGB LED 待补充。。。"},"/hardware/zh/tang/Tang-primer/e203/int.html":{"title":"蜂鸟的中断","content":" title: 蜂鸟的中断 待补充。。。"},"/hardware/zh/tang/Tang-primer/e203/led.html":{"title":"蜂鸟点灯","content":" title: 蜂鸟点灯 > maxdepth > : 2 > > led/led led/pwm\\_led led/ws2812"},"/hardware/zh/tang/Tang-primer/e203/display.html":{"title":"蜂鸟驱动屏幕","content":" title: 蜂鸟驱动屏幕 > maxdepth > : 2 > > display/lcd1602 display/oled display/spi\\_tft"},"/hardware/zh/tang/index.html":{"title":"Tang 系列开发板","content":" title: Tang 系列开发板 Tang 系列开发板主要分为 Tang Nano 和 Tang Primer 两个系列。 ## 当前产品 ### 外观总览 <table> <thead> <tr> <th style \"text align:center\">Tang Primer 20K（核心板）</th> <th style \"text align:center\">Tang Nano 1K</th> </tr> </thead> <tbody> <tr> <td style \"text align:center\"><a href \"./tang primer 20k/primer 20k.html\"><img src \"./../../assets/Tang/primer_20k/primer_20k.png\" alt \"Tang Primer 20K（核心板）\"></a></td> <td style \"text align:center\"><a href \"./Tang Nano 1K/Nano 1k.html\"><img src \"./../../assets/Tang/Nano 1K/1K.png\" alt \"Tang Nano 1K\"></a></td> </tr> </tbody> <thead> <tr> <th style \"text align:center\">Tang Nano 4K</th> <th style \"text align:center\">Tang Nano 9K</th> </tr> </thead> <tbody> <tr> <td style \"text align:center\"><a href \"./Tang Nano 4K/Nano 4K.html\"><img src \"./../../assets/Tang/Nano_4K/Nano_4K.png\" alt \"Tang Nano 4K\"></a></td> <td style \"text align:center\"><a href \"./Tang Nano 9K/Nano 9K.html\"><img src \"./../../assets/Tang/Nano 9K/9K.png\" alt \"Tang Nano 9K\"></a></td> </tr> </tbody> </table> ### 主要参数对比 条目 <p style \"white space:nowrap\">Tang Primer 20K</p> <p style \"white space:nowrap\">Tang Nano 9K</p><p style \"white space:nowrap\">Tang Nano 4K</p><p style \"white space:nowrap\">Tang Nano 1K</p> : : : : 逻辑单元(LUT4) 20736 8640 4608 1152 寄存器（FF） 15552 6480 3456 864 S SRAM (bits) 41472 17280 B SRAM (bits) 828K x 46 468K x 26 180K x 10 72K x 4 用户闪存 (bits) 608K 256K 96K 锁相环 (PLL) 4 2 2 1 板载 Flash 32Mbits NOR Flash 32Mbits NOR Flash 32Mbits NOR Flash 预留焊盘 硬核处理器 Cortex M3 ## 售罄产品 Tang Nano Tang Primer : : : : [![Tang Nano](./../../assets/Tang/Nano/Tang_Nano.jpg)](./Tang Nano/Nano.html) [![Tang Primer](./../../assets/Tang/permier/Tang_permier.jpg)](./Tang primer/Tang primer.html) "},"/hardware/zh/tang/tang-primer-20k/examples/decode_led_on.html":{"title":"Tang Primer 20K 译码器亮灯","content":" title: Tang Primer 20K 译码器亮灯 keywords: Tang Primer 20K ,例程, 上手 update: date: 2022 09 30 version: v0.1 author: wonder content: 初稿 ## 说明 本例程使用 Dock 底板上的 S0、S1 按键，和 LED0、LED1、LED2、LED3 四个 LED 灯。 使用两个按键来控制 4 个LED灯的状态，进行的操作与对应的结果如下： <table> <tr> <th colspan \"2\" >按键</th> <th colspan \"4\">LED 状态</th> <th >真值表达式</th> </tr> <tr> <td>S0</td> <td>S1</td> <td>LED0</td> <td>LED1</td> <td>LED2</td> <td>LED3</td> <td></td> </tr> <tr> <td></td> <td></td> <td>亮</td> <td></td> <td></td> <td></td> <td>$$ LED0 S0\\cdot S1 $$</td> </tr> <tr> <td>按下</td> <td></td> <td></td> <td>亮</td> <td></td> <td></td> <td>$$ LED1 \\overline{S0}\\cdot S1 $$</td> </tr> <tr> <td></td> <td>按下</td> <td></td> <td></td> <td>亮</td> <td></td> <td>$$ LED2 S0\\cdot \\overline{S1} $$</td> </tr> <tr> <td>按下</td> <td>按下</td> <td></td> <td></td> <td></td> <td>亮</td> <td>$$ LED3 \\overline{S0}\\cdot \\overline{S1} $$</td> </tr> </table> 从前面的 [按键亮灯](./examples/key_led_on.html) 已知：当 FPGA 与 LED 所连接的引脚为低电平时，对应的 LED 灯会亮；按下按键，对应的 FPGA 引脚为低电平状态。 上面那个表格的输出是以 1 为结果，为了根据原理图来点灯，需要将上面的真值表结果取反来实现最终的效果： <table> <tr> <th colspan \"2\"> 按键 </th> <th colspan \"4\">LED 电平状态</th> <th > 真值表达式 </th> </tr> <tr> <td>S0</td> <td>S1</td> <td>LED0</td> <td>LED1</td> <td>LED2</td> <td>LED3</td> <td></td> </tr> <tr> <td></td> <td></td> <td>0</td> <td></td> <td></td> <td></td> <td>$$ LED0 \\overline{S0\\cdot S1} $$</td> <! <td> LED1 ! ( S0 & S1 ) </td> > </tr> <tr> <td>0</td> <td></td> <td></td> <td>0</td> <td></td> <td></td> <td>$$ LED1 \\overline{\\overline{S0}\\cdot S1} $$</td> <! <td> LED1 ! (!S0 & S1 ) </td> > </tr> <tr> <td></td> <td>0</td> <td></td> <td></td> <td>0</td> <td></td> <td>$$ LED2 \\overline{S0\\cdot \\overline{S1}} $$</td> <! <td> LED2 ! ( S0 & !S1) </td> > </tr> <tr> <td>0</td> <td>0</td> <td></td> <td></td> <td></td> <td>0</td> <td>$$ LED3 \\overline{\\overline{S0}\\cdot \\overline{S1}} S0 S1 $$</td> <! <td> LED3 ( S0 S1 ) </td> > </tr> </table> ## 操作 ### 引脚复用 READY DONE SSPI ### 端口和引脚 Port Direction Location key[0] input T10 key[1] input T3 led[0] output C13 led[1] output A13 led[2] output N16 led[3] output N14 ### 代码 .. tabset:: ## decode_led_on.v Verilog文件； 定义了两个按键输入端口，和四个输出端口。根据按键输入的状态，译码输出到对应的端口。 ```verilog module decode_led_on( input [1:0] key, output [3:0] led ); assign led[0] !( key[0] & key[1] ) ; assign led[1] !(!key[0] & key[1] ) ; assign led[2] !( key[0] &!key[1] ) ; assign led[3] ( key[0] key[1] ) ; endmodule ``` ## decode_led_on.cst 物理约束文件； 将 verilog 代码里的端口绑定到 FPGA 引脚上面 ```txt IO_LOC \"led[3]\" N14; IO_LOC \"led[2]\" N16; IO_LOC \"led[1]\" A13; IO_LOC \"led[0]\" C13; IO_LOC \"key[1]\" T3; IO_LOC \"key[0]\" T10; IO_PORT \"led[3]\" PULL_MODE UP DRIVE 8; IO_PORT \"led[2]\" PULL_MODE UP DRIVE 8; IO_PORT \"led[1]\" PULL_MODE UP DRIVE 8; IO_PORT \"led[0]\" PULL_MODE UP DRIVE 8; IO_PORT \"key[1]\" PULL_MODE UP; IO_PORT \"key[0]\" PULL_MODE UP; ``` ## 效果 默认只有 LED0 亮；按下 S0 按键 LED1 亮；按下 S1 按键 LED1 亮；按下 S0 和 S2 按键 LED3 亮； <table> <tr> <th colspan \"2\" >按键</th> <th colspan \"4\">LED 状态</th> </tr> <tr> <td>S0</td> <td>S1</td> <td>LED0</td> <td>LED1</td> <td>LED2</td> <td>LED3</td> </tr> <tr> <td></td> <td></td> <td>亮</td> <td></td> <td></td> <td></td> </tr> <tr> <td>按下</td> <td></td> <td></td> <td>亮</td> <td></td> <td></td> </tr> <tr> <td></td> <td>按下</td> <td></td> <td></td> <td>亮</td> <td></td> </tr> <tr> <td>按下</td> <td>按下</td> <td></td> <td></td> <td></td> <td>亮</td> </tr> </table> <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/tang-primer-20k/examples/xor_led_on.html":{"title":"异或逻辑亮灯","content":" title: 异或逻辑亮灯 keywords: Tang Primer 20K ,例程, 上手 update: date: 2022 10 11 version: v0.1 author: wonder content: 初次编辑 ## 原理 ### 异或逻辑介绍 异或（xor）是一个数学运算符。它应用于逻辑运算。异或的数学符号为“⊕”，计算机符号为“xor”。 其运算法则为：$$C A\\oplus B (\\overline{A}\\cdot B) (A\\cdot \\overline{B}) $$ 真值表为: <table> <tr> <td>变量 A</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> </tr> <tr> <td>变量 B</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> </tr> <tr> <td>结果 B</td> <td>0</td> <td>1</td> <td>1</td> <td>0</td> </tr> </table> 在 verilog 中，可以使用 `^` 来表示异或运算，所以可以写成$$C A\\oplus B A\\wedge B $$ 同理容易算出，四个信号的异或运算结果如下： $$E A\\oplus B\\oplus C\\oplus D A\\wedge B \\wedge C\\wedge D (((A\\wedge B )\\wedge C)\\wedge D)$$ 根据两项输入的运算方式来计算四项输入运算方法，不难得出以下真值表结果： <table><tr> <td>变量 A</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> </tr> <tr> <td>变量 B</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> </tr> <tr> <td>变量 C</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> </tr> <tr> <td>变量 D</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> </tr> <tr> <td>结果 E</td> <td>0</td> <td>1</td> <td>1</td> <td>0</td> <td>1</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>1</td> <td>0</td> </tr> </table> ### 拨码开关说明 Tang Primer 20K DOCK 底板配备有一个 5P 的拨码开关。其中一号拨码开关被设计成核心板卡使能位；剩下四个拨码开关用于用户自定义编程功能。 拨码开关原理图 拨码开关与 FPGA 连接引脚图 ![dip_switch](./assets/xor_led_on/dip_switch.png) ![dip_switch_pin](./assets/xor_led_on/dip_switch_pin.png) 从上图 [原理图](https://dl.sipeed.com/shareURL/TANG/Primer_20K/02_Schematic) 可以知道，拨码开关连通时对应 FPGA 引脚为高电平输入。 将拨码开关四个角均作输入信号，并将其异或运算，得出一位结果。最终拨码开关状态与输出信号如下表： <table><tr> <td>开关 2</td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> </tr> <tr> <td>开关 3</td> <td> </td> <td> </td> <td> </td> <td> </td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td> </td> <td> </td> <td> </td> <td> </td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> </tr> <tr> <td>开关 4</td> <td> </td> <td> </td> <td>1</td> <td>1</td> <td> </td> <td> </td> <td>1</td> <td>1</td> <td> </td> <td> </td> <td>1</td> <td>1</td> <td> </td> <td> </td> <td>1</td> <td>1</td> </tr> <tr> <td>开关 5</td> <td> </td> <td>1</td> <td> </td> <td>1</td> <td> </td> <td>1</td> <td> </td> <td>1</td> <td> </td> <td>1</td> <td> </td> <td>1</td> <td> </td> <td>1</td> <td> </td> <td>1</td> </tr> <tr> <td>输出结果</td> <td><font color \"#4F84FF\">0</font></td> <td><font color \"#4F84FF\">1</font></td> <td><font color \"#4F84FF\">1</font></td> <td><font color \"#4F84FF\">0</font></td> <td><font color \"#4F84FF\">1</font></td> <td><font color \"#4F84FF\">0</font></td> <td><font color \"#4F84FF\">0</font></td> <td><font color \"#4F84FF\">1</font></td> <td><font color \"#4F84FF\">1</font></td> <td><font color \"#4F84FF\">0</font></td> <td><font color \"#4F84FF\">0</font></td> <td><font color \"#4F84FF\">1</font></td> <td><font color \"#4F84FF\">0</font></td> <td><font color \"#4F84FF\">1</font></td> <td><font color \"#4F84FF\">1</font></td> <td><font color \"#4F84FF\">0</font></td> </tr> </table> 上表中，开关那一行中的空白表示开关断开，`1` 表示开关拨下。 ### 板载 LED 说明 根据 LED 电路，可以知道当 FPGA 引脚为低电平的时候对应连接的 LED 会亮起来。 板载自定义 LED 电路原理图 板载自定义 LED 与 FPGA 连接引脚图 ![key_schematic](./assets/key_led_on/led_schematic.png) ![key_pin](./assets/key_led_on/led_pin.png) 这里选择 LED0 作为结果引脚来验证代码现象。 ## 操作 ### 引脚复用 DONE ### 端口和引脚 Port Direction Location dip_switch[2] input E9 dip_switch[3] input E8 dip_switch[4] output T4 dip_switch[5] output T5 led[0] output C13 ### 代码 .. tabset:: ## xor_led_on.v Verilog文件； 定义了 4 个拨码开关输入端口，和 1 个 LED 输出端口。根据拨码开关输入的状态，异或运算后输出到对应的端口。 ```verilog module xor_led_on( input [5:2] dip_switch, output led ); assign led dip_switch[5] ^ dip_switch[4] ^dip_switch[3] ^ dip_switch[2] ; endmodule ``` ## xor_led_on.cst 物理约束文件； 将 verilog 代码里的端口绑定到 FPGA 引脚上面 ```txt IO_LOC \"led\" C13; IO_LOC \"dip_switch[5]\" T5; IO_LOC \"dip_switch[4]\" T4; IO_LOC \"dip_switch[3]\" E8; IO_LOC \"dip_switch[2]\" E9; IO_PORT \"led\" PULL_MODE UP DRIVE 8; IO_PORT \"dip_switch[5]\" PULL_MODE DOWN; IO_PORT \"dip_switch[4]\" PULL_MODE DOWN; IO_PORT \"dip_switch[3]\" PULL_MODE DOWN; IO_PORT \"dip_switch[2]\" PULL_MODE DOWN; ``` ## 效果 四个拨码开关 2、3、4、5 位有奇数个开关拨下是；LED0 熄灭，偶数个开关拨下时，LED0 点亮。 ## 补充说明 在高云 IDE 中，我们可以看到自己代码综合后所消耗芯片资源数量以及占比。 ![used_resource](./assets/xor_led_on/used_resource.png) 从这里面可以看到这次编写的代码消耗量 1 个 LUT，5 个 IO。 对于 CLS 的解释可以查看高云半导体官方文档 [UG288](http://cdn.gowinsemi.com.cn/UG288.pdf) 中的第二章。 Tang Primer 20K 的主控芯片 [GW2A LV18PG256C8/I7](http://www.gowinsemi.com.cn/prod_view.aspx?TypeId 10&amp;FId t3:10:3&amp;Id 167#GW2A) 内部基本逻辑单元为 LUT4。LUT 即为查找表（Look Up Table），本质上就是一个 RAM。它将数据事先写入 RAM 后，每个输入信号就相当于目标内容地址，找出地址对应的内容，然后输出。LUT4 指的是 4 个输入信号的查找表。其简单解释图如下： > 这里用一个4输入与门为例 <table> <tr> <td><img src \"./assets/xor_led_on/lut_actual.jpeg\"></td> <td><img src \"./assets/xor_led_on/lut_actual.jpeg\"></td> </tr> </table> 本地代码中，我们恰好 4 个输入和 1 个输出。所以使用 1 个 lut4 就够了。 ## 相关问题 ### 烧录代码后拨动拨码开关 LED 状态没有改变 这是因为拨码开关引脚上拉了，自己将物理约束文件 (.cst) 文件里面的 `PULL_MODE UP` 改成 `PULL_MODE DOWN` <p id \"back\"> <a href \"#\" onClick \"javascript:history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/tang-primer-20k/examples/key_led_on.html":{"title":"Tang Primer 20K 按键亮灯","content":" title: Tang Primer 20K 按键亮灯 keywords: Tang Primer 20K ,例程, 上手 update: date: 2022 09 29 version: v0.1 author: wonder content: 初稿 ## 原理 从 [原理图](https://dl.sipeed.com/shareURL/TANG/Primer_20K/02_Schematic) 中，可以知道以下信息： ### 按键电路： 根据 DOCK 底板原理图，可以看出当板载按键按下时，对应的 FPGA 引脚会为低电平输入。 板载按键电路原理图 板载按键与 FPGA 连接引脚图 ![key_schematic](./assets/key_led_on/key_schematic.png) ![key_pin](./assets/key_led_on/key_pin.png) ### LED 电路: 根据 LED 电路，可以知道当 FPGA 引脚为低电平的时候对应连接的 LED 会亮起来。 板载自定义 LED 电路原理图 板载自定义 LED 与 FPGA 连接引脚图 ![key_schematic](./assets/key_led_on/led_schematic.png) ![key_pin](./assets/key_led_on/led_pin.png) 所以直接将按键引脚的逻辑电平输出为 LED 的引脚裸机电平就可以点亮 LED 灯。 ## 操作 ### 引脚复用 LED5 复用了 SSPI 引脚，需要手动前往 Project >Configuration >Place&Route >Dual Purpose Pin 中，勾选 `Use SSPI as regular IO` ![dual_purpose_pin](./assets/key_led_on/dual_purpose_pin.png) **后续文章中不再重复描述步骤，仅说明复用管脚，用户自行前往设置启用管脚复用。** ### 端口和引脚 Port Direction Location key input T10 led[5] output L16 led[4] output L14 ### 代码 .. tabset:: ## key_led_on.v Verilog文件； 定义了一个按键输入端口，和两个输出端口。将输入端口的 IO 电平状态输出到两个输出端口。 此处使用了位拓展语法。可以前往 [位拼接运算](./examples/key_6leds_on.md.html) 查看相关说明，但是本篇后续的文档规范还是应当继续阅读完。 ```verilog module key_led_on( input key, output [5:4] led ); assign led[5:4] {2{key}}; endmodule ``` ## key_led_on.cst 物理约束文件； 将 verilog 代码里的端口绑定到 FPGA 引脚上面 ```txt IO_LOC \"led[5]\" L16; IO_PORT \"led[5]\" PULL_MODE UP DRIVE 8; IO_LOC \"led[4]\" L14; IO_PORT \"led[4]\" PULL_MODE UP DRIVE 8; IO_LOC \"key\" T10; IO_PORT \"key\" PULL_MODE UP; ``` #### 代码用法 **仅本次说明，后续章节除了特定内容外，不再做说明。** 根据文件里所描述的文件类型，创建对应的文件，并且把文件内容复制进去。 发现这是一个 `物理约束文件` ![物理约束文件](./assets/key_led_on/cst_file.png) 新建一个 `物理约束文件` ![file_kind](./assets/key_led_on/file_kind.png) 将文件内容内容复制进去 ![file_content](./assets/key_led_on/file_content.png) 接着保存这个文件。 将所有代码中涉及到的文件创建、复制内容且保存后，就可以进行综合、布局布线操作来生成下载固件了。 具体创建工程操作参考 [Tang Primer 20K Dock 亮一个灯](./assign_led.html) ## 效果 按下 S0 按键，LED4 和 LED5 亮。松开 S0 按键，LED4 和 LED5 灭。 松开 S0 按键按下 S0 按键 <img src \"./assets/key_led_on/led_off.png\" alt \"led_off\"><img src \"./assets/key_led_on/led_on.png\" alt \"led_on\"> <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/tang-primer-20k/examples/assign_led.html":{"title":"Tang Primer 20K Dock 亮一个灯","content":" title: Tang Primer 20K Dock 亮一个灯 tags: Tang Primer 20K Dock，上手 keywords: Primer, Tang, Dock， 入门，20K desc: Tang Primer 20K Dock 简单上手 update: date: 2022 09 29 version: v0.1 author: wonder content: 初稿 ## 安装 IDE 参考 [安装IDE](https://wiki.sipeed.com/hardware/zh/tang/Tang Nano Doc/get_started/install the ide.html) 来完成我们需要准备的软件环境。 Windows 用户建议额外下载一次高云教育版的编程器软件，这样可以避免烧录时因为 Programmer 软件版本不兼容 BL702 下载器而导致的奇怪问题。 对于 Linux 用户的话建议使用 [openfpgaLoader](https://wiki.sipeed.com/hardware/zh/tang/Tang Nano Doc/get_started/flash_in_linux.html) 这软件来烧录这款板子。 ## 新建工程 文件 > 新建 > FPGA Design > Project <div> <img src \"./assets/led_assets/new_project.png\" width 58% alt \"new_project\"> <img src \"./assets/led_assets/fpga_project.png\" width 35% alt \"fpga_project\"> </div> 设置工程名称，要求只用英文的下划线命名，存放路径中不要有中文字符或者空格等。 ![project_path](./assets/assign_led_assets/assign_led_on.png) 然后在下面的芯片型号中选择 GW2A LV18PG256C8/I7，使用上面的筛选能够更快地选择到正确的型号。注意 Device 那一栏为 GW2A 18C ![device_choose](./assets/led_assets/device_choose.png) 然后点击确定后就可以进行最终项目预览了。确认无误后就完成工程创建了。 ## 编写代码 ### 新建文件 高云半导体 IDE 提供了三种新建文件的方法。在此我们直接使用快捷键 `Ctrl + N` 来新建文件，其他两种不在此讲述。 在弹出的窗口中选择 `Verilog File`，会 VHDL 的也可以选择下面的 `VHDL File`，这篇文章只用 Verilog 来做点灯示例。 <img src \"./assets/led_assets/new_verilog_file.png\" width 50% alt \"new_verilog_file\"> 点击 OK 之后会提示让我们输入文件名称，此处以 `led` 为文件名做示范。 <img src \"./assets/led_assets/file_name.png\" width 75% alt \"file_name\"> 到这里我们就完成文件的创建了，可以直接编写代码了。 ![created_file](./assets/led_assets/created_file.png) ### Verilog 简单说明 Verilog 是一种硬件描述语言，用来对数字电路进行抽象化描述。 Verilog 的基本设计单元是“模块”(module)。 一个模块是由两部分组成的：一部分描述接口，另一部分描述内部逻辑功能，即定义输入是如何影响输出的。 一个模块长成这样： ```v module module_name #(parameter) (port) ; function endmodule ``` 模块整体结构由 module 和 endmodule 组成，module 后面跟着的是模块的名称(module_name)，可传递变量参数(parameter)，端口及其方向的申明(port)，紧接着就是内部逻辑功能描述(function) ,最后用 endmodule 来表示这一个模块，描述完毕。 内部逻辑功能通常由 assign 和 always 块完成；其中 assign 语句描述逻辑功能，always 块常用于描述时序功能。 ### 代码思路 根据我们的 Dock 底板 [原理图](https://dl.sipeed.com/shareURL/TANG/Primer_20K/02_Schematic)，可以看到我们将 IO 控制为底的时候，LED 会亮起来。 ![led_schematic](./assets/assign_led_assets/led_schematic.png) 知道怎么样能让灯亮起来后，就快点编写代码吧 ### 代码描述 ```v module assign_led_on( output led_voltage_level ); assign led_voltage_level 1'b0 ; endmodule ``` 上面的代码，定义了一个名为 assign_led_on 得模块，一个名为 led_voltage_level 的输出端口。 `assign` 语句约束了 led_voltage_level 的值，使其值保持为 0。后面再将这个端口绑定到 FPGA 芯片的引脚上后，就可以得到一个电平状态为低电平的引脚，借此来使 LED 亮起来。 ## 综合、约束、布局布线 ### 综合 代码保存后，可以双击 IDE 内部的 Process > Synthesize 来进行代码综合，将 verilog 代码内容转换为综合网表。 ![synthesize](./assets/assign_led_assets/synthesize.png) 关于网表有兴趣的可以自己去查阅相关资料，此处不再额外说明。 ### 约束 综合完之后我们需要进行管脚约束，才能将所编写的模块端口与 FPGA 引脚相对应，并且实现模块的功能。 点击上图 Synthesize 上面的 FloorPlanner 来进行管脚约束。 ![floorplanner](./assets/led_assets/floorplanner.png) 由于是首次创建，所以会弹出下面的对话框，点击 OK 后就弹出了图形化约束交互界面。 ![create_constrain_file](./assets/led_assets/create_constrain_file.png) ![floorplanner_intreface](./assets/led_assets/floorplanner_interface.png) 关于约束的方法可以查看 [SUG935 1.3_Gowin设计物理约束用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG935 1.3_Gowin%E8%AE%BE%E8%AE%A1%E7%89%A9%E7%90%86%E7%BA%A6%E6%9D%9F%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) 此处因个人喜所以仅使用下图中 IO Constranins 方法来约束引脚： ![floor_planner_ioconstrain](./assets/assign_led_assets/floor_planner_ioconstrain.png) 根据下面 Dock 底板原理图，决定点亮 LED4，对应在 FPGA 上的引脚为 L14。 ![led_port](./assets/assign_led_assets/led_port.png) 因此对于在 FloorPlanner 交互窗口下面的 IO Constranins 中将 PORT（端口）与 Location（引脚） 分别填入下面的值： ![io_constrain_value](./assets/assign_led_assets/io_constrain_value.png) 输入完毕后快捷键 Ctrl + S 来保存一下引脚约束，然后接可以关闭 FloorPlanner 的交互图形界面了。 接着发现在工程项目里面多出来刚刚创建的 cst 文件了，里面的内容也比较好理解。 ![cst_content](./assets/assign_led_assets/cst_content.png) ### 布局布线 完成约束后就要开始运行布局布线了，目的是为了把综合所生成的网表与我们自己定义的约束来通过 IDE 算出最优解然后将资源合理地分配在 FPGA 芯片上。 双击下图红框处的 Place&Route 就开始运行了。 ![place_route](./assets/assign_led_assets/place_route.png) 紧接着没有报错，全部通过。就可以开始进行烧录了。 ## 烧录固件 Dock 板载了下载器，在 [安装IDE](https://wiki.sipeed.com/hardware/zh/tang/Tang Nano Doc/get_started/install the ide.html) 的时候我们已经安装了驱动。因此我们将板子与电脑连接起来就行。 ![connected](./assets/led_assets/connected.png) 对于 Programmer 软件建议使用高云官网下载到 [点我跳转](http://www.gowinsemi.com.cn/faq.aspx) ，下载下图所示的高云云源编程器软件即可。 ![educational_edition_programmer](./assets/led_assets/educational_edition_programmer.png) ### 扫描设备 在使用 Dock 底板的时候不要忘记使能核心板，按下 1 号拨码开关即可。 ![Enable_core_board](./../assets/start/switch_1_on.png) 双击下图中的下载程序(Program Device) 来运行 Programmer 软件 ![open_programmer](./assets/led_assets/open_programmer.png) 然后在打开的页面中点击一下 scan_device 来扫描到我们的设备。 ![scan_device](./assets/led_assets/scan_device.png) 点击 OK 后就可以进行烧录操作了。 烧录相关的文档可以参考 [SUG502 1.3_Gowin_Programmer用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG502 1.3_Gowin_Programmer%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) 有问题的话可以前往 [常见问题](https://wiki.sipeed.com/hardware/zh/tang/Tang Nano Doc/questions.html) 自行排查。 ### 下载到 SRAM 一般来说这个模式是以用来快速验证所生成的固件是否满足自己目的的。 因为其烧录快的特性所以使用的较多，然是当然断电会丢失数据，所以如果想上电运行程序的话是不能选这个的。 点击 Operation 下面的功能框来打开设备设置界面，接着在 Operation 框中选择 SRAM Program 选项来设置为下载到 SRAM ，最后点击下面的那三个点点框来选择我们所生成的 .fs 下载固件。通常来说下载固件生成与工程文件目录下的 impl > pnr 目录下。 ![sram_mode](./assets/led_assets/sram_mode.png) 接着来点击红框处开始进行烧录 ![sram_download](./assets/led_assets/sram_download.png) 有问题的话可以前往 [常见问题](https://wiki.sipeed.com/hardware/zh/tang/Tang Nano Doc/questions.html) 自行排查。 到这里就下载完成了。 ### 下载到 Flash 上面说过下载到 SRAM 是为了快速验证，但是不能上电运行程序。 所以想要上电运行的话我们需要设置下载到 Flash。 和上面下载到 SRAM 的步骤几乎类似，先点开 Operation 下面的功能框来打开设备设置界面，接着在 Operation 框中选择 External Flash Mode 选项来设置为下载到外部 Flash ，最后点击下面的那三个点点框来选择我们所生成的 .fs 下载固件，通常来说下载固件生成与工程文件目录下的 impl > pnr 目录下。最后在下面的外部 Flash 选项中选择设备为 Generic Flash 。 ![flash_mode](./assets/led_assets/flash_mode.png) 接着来点击红框处开始进行烧录 ![flash_download](./assets/led_assets/flash_download.png) 然后我们的程序重新上电也能照样运行了。 有问题的话可以前往 [常见问题](https://wiki.sipeed.com/hardware/zh/tang/Tang Nano Doc/questions.html) 自行排查。 ## 代码结果 如图所示，只有 LED4 亮着。 ![led_blink](./assets/assign_led_assets/led4_on.png) ## 结语 到这里我们就已经完成了 FPGA 的 “Hello world” 了。以后的示例工程不会再叙述新建文件等操作了。 ## 常见问题 ### No Cable found 检查设备管理器里有没有下图这两个，没有的话需要安装 Programmer 驱动。 ![converter](./../../assets/questions/converter.png) ### No gowin device found 确认自己使能了核心板。 ### 成功烧录过一次外部 Flash 后 Programmer 软件无法再烧录 注意描述是成功烧录过一次 Flash。 这种情况默认为启用了错误的引脚复用而导致下载器不能再识别到 FPGA 的 JTAG。可以短接 Flash 的 1、4 引脚，让芯片上电时不能正常读 FLASH 。 ![flash_cs](./../assets/flash_cs.png) ### 更多问题及其解决办法前往[相关问题](./../Tang Nano Doc/questions.html)查看"},"/hardware/zh/tang/tang-primer-20k/examples/water_led.html":{"title":"Tang Primer 20K 流水灯","content":" title: Tang Primer 20K 流水灯 keywords: Tang Primer 20K ,例程, 上手 update: date: 2022 11 25 version: v0.1 author: wonder content: 初稿 ## 说明 本例程使用 Dock 底板上 LED0、LED1、LED2、LED3、LED4、LED5 共六个 LED 灯。 依次只点亮底板上一个 LED 灯，LED 灯切换间隔为 0.5S。 在前面的 [计数器亮灯中](./led.html)，已经点亮了一个灯了。这次只是将所点亮的灯的状态 “转移” 到别的灯上，这里使用环形 [移位寄存器](https://baike.baidu.com/item/%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E5%AD%98%E5%82%A8%E5%99%A8/22232752) 就可以完成灯的效果转移目标。在 FPGA 上，可以使用位拼接运算符 `{` 和 `}` 来实现移位寄存器的效果。 ### 移位寄存器 移位寄存器是是一种在若干相同时间脉冲下工作的以触发器为基础的器件，数据以并行或串行的方式输入到该器件中，然后每个时间脉冲依次向左或右移动一个比特，在输出端进行输出。 对于使用移位寄存器来实现流水灯，我们需要保证最低要有一个灯亮着，这个时候我们选择环形移位寄存器。将普通移位寄存器的输出作为它自己的输入即可看作为环形移位寄存器。 在 verilog 中，使用类似于下面的代码就可以很容易的实现上面的状态值转移表： ```v reg [5:0] q; always @(posedge clk or negedge rst_n) begin if (!rst_n) begin q[5:0] < 6'b000001; // 复位 end begin q[5:0] < {q[4:0],q[5]}; //最高位作为最低位输入 // q[5:0] < {q[0],q[5:1]}; //最低位作为最高位输入 end end ``` <! 对应的真值表状态转移如下： 其中以 M[5:0] 来表示底板上的 LED0 到 LED5；clk 表示移位脉冲，每 0.5s 一次；N[5:0] 表示经移动脉冲后的 LED0到 LED5 的状态值。 rst clk M[5:0] N[5:0] 0 x 000001 xxxxxx 0 1 000001 000001 0 1 000001 xxxxxx 0 1 000001 xxxxxx 0 1 000001 xxxxxx 0 1 000001 xxxxxx 0 1 000001 xxxxxx 在 verilog 中，使用类似于下面的代码就可以很容易的实现上面的状态值转移表： ```v always @(posedge clk or negedge rst_n) begin if (!rst_n) begin M[5:0] < 6'b000001; // 复位 N[5:0] < 6'b000001; // 复位 end else begin end end ``` > ## 操作 ### 引脚复用 READY DONE SSPI ### 端口和引脚 Port Direction Location rst_n input T10 Clock input H11 led[5] output L16 led[4] output L14 led[3] output N14 led[2] output N16 led[1] output A13 led[0] output C13 ### 代码 .. tabset:: ## water_led.v Verilog文件； 定义了一个复位输入，一个时钟输入和六个输出端口。复位有效时重置输出端口的电平状态。 ```verilog module led( input rst_n, input Clock, output [5:0] led ); /**********计时部分**********/ //parameter Clock_frequency 27_000_000; // 时钟频率为27Mhz parameter count_value 13_499_999; // 计时 0.5S 所需要的计数次数 reg [23:0] count_value_reg ; // 计数器 reg count_value_flag; // IO 电平标志 always @(posedge Clock or negedge rst_n) begin if (!rst_n) begin count_value_reg < 23'b0; // 清零计数器 count_value_flag < 1'b0 ; // 清零标志位 end else if ( count_value_reg < count_value ) begin //没有计数到 0.5S count_value_reg < count_value_reg + 1'b1; // 继续计数 count_value_flag < 1'b0 ; // 不产生移位标志 end else begin //计数到 0.5S 了 count_value_reg < 23'b0; // 清零计数器，为重新计数最准备 count_value_flag < 1'b1 ; // 产生移位标志 end end /**********电平状态移位部分**********/ reg [5:0] led_reg 6'b000001; //初始化输出 IO 电平状态 always @(posedge Clock or negedge rst_n) begin if (!rst_n) begin led_reg[5:0] < 6'b000001 ; // 复位后输出 IO 电平状态 end else if ( count_value_flag ) // 电平移位标志有效 led_reg[5:0] < { led_reg[4:0],led_reg[5] } ; // IO 电平移位 else // 电平移位标志无效 led_reg[5:0] < led_reg[5:0] ; // IO 电平不变 end /**********寄存器变量与端口连接**********/ assign led[5:0] led_reg[5:0] ; endmodule ``` ## water_led.cst 物理约束文件； 将 verilog 代码里的端口绑定到 FPGA 引脚上面 ```txt IO_LOC \"led[5]\" L16; IO_PORT \"led[5]\" PULL_MODE UP DRIVE 8; IO_LOC \"led[4]\" L14; IO_PORT \"led[4]\" PULL_MODE UP DRIVE 8; IO_LOC \"led[3]\" N14; IO_PORT \"led[3]\" PULL_MODE UP DRIVE 8; IO_LOC \"led[2]\" N16; IO_PORT \"led[2]\" PULL_MODE UP DRIVE 8; IO_LOC \"led[1]\" A13; IO_PORT \"led[1]\" PULL_MODE UP DRIVE 8; IO_LOC \"led[0]\" C13; IO_PORT \"led[0]\" PULL_MODE UP DRIVE 8; IO_LOC \"Clock\" H11; IO_PORT \"Clock\" PULL_MODE UP; IO_LOC \"rst_n\" T10; IO_PORT \"rst_n\" PULL_MODE UP; ``` ## 效果 按下 S0 按键，LED0 灭，其余 LED 均亮。 松开 S0 按键，LED0 到 LED5 依次只熄灭一个，LED5 熄灭后是 LED0 熄灭，形成了闭环的效果。 <! 松开 S0 按键按下 S0 按键 <img src \"./assets/key_led_on/led_off.png\" alt \"led_off\"><img src \"./assets/key_led_on/led_on.png\" alt \"led_on\"> > ## 补充 如果将 `water_led.v` 文件里最后部分的 ```verilog assign led[5:0] led_reg[5:0] ; ``` 改成 ```verilog assign led[5:0] ~led_reg[5:0] ; ``` 那么每次只会有一个 LED 亮起来，而不是五个 LED 亮着。 <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/tang-primer-20k/examples/led.html":{"title":"Tang Primer 20K Dock 点一个灯","content":" title: Tang Primer 20K Dock 点一个灯 tags: Tang Primer 20K Dock，上手 keywords: Primer, Tang, Dock， 入门，20K desc: Tang Primer 20K Dock 简单上手 update: date: 2022 09 21 version: v0.1 author: wonder content: 初稿 date: 2022 09 29 version: v0.2 author: wonder content: 修复部分错误 对于软件开发来说，输出 `hello world` 就是入门了。对于硬件相关的开发而言，点灯就是同款入门。 ## 安装 IDE 参考 [安装IDE](https://wiki.sipeed.com/hardware/zh/tang/Tang Nano Doc/get_started/install the ide.html) 来完成我们需要准备的软件环境。 对于 Linux 用户的话建议使用 [openfpgaLoader](https://wiki.sipeed.com/hardware/zh/tang/Tang Nano Doc/get_started/flash_in_linux.html) 这软件来烧录这款设备。 ## 新建工程 文件 > 新建 > FPGA Design > Project <div> <img src \"./assets/led_assets/new_project.png\" width 58% alt \"new_project\"> <img src \"./assets/led_assets/fpga_project.png\" width 35% alt \"fpga_project\"> </div> 设置工程名称，要求只用英文的下划线命名，存放路径中不要有中文字符或者空格等。 ![project_path](./assets/led_assets/project_path.png) 然后在下面的芯片型号中选择 GW2A LV18PG256C8/I7，使用上面的筛选能够更快地选择到正确的型号。注意 Device 那一栏为 GW2A 18C ![device_choose](./assets/led_assets/device_choose.png) 然后点击确定后就可以进行最终项目预览了。确认无误后就完成工程创建了。 ## 编写代码 ### 新建文件 高云半导体 IDE 提供了三种新建文件的方法。在此我们直接使用快捷键 `Ctrl + N` 来新建文件，其他两种不在此讲述。 在弹出的窗口中选择 `Verilog File`，会 VHDL 的也可以选择下面的 `VHDL File`，这篇文章只用 Verilog 来做点灯示例。 <img src \"./assets/led_assets/new_verilog_file.png\" width 50% alt \"new_verilog_file\"> 点击 OK 之后会提示让我们输入文件名称，此处以 `led` 为文件名做示范。 <img src \"./assets/led_assets/file_name.png\" width 75% alt \"file_name\"> 到这里我们就完成文件的创建了，可以直接编写代码了。 ![created_file](./assets/led_assets/created_file.png) ### Verilog 简单说明 Verilog 是一种硬件描述语言，用来对数字电路进行抽象化描述。 Verilog 的基本设计单元是“模块”(module)。 一个模块是由两部分组成的：一部分描述接口，另一部分描述内部逻辑功能，即定义输入是如何影响输出的。 一个模块长成这样： ```v module module_name #(parameter) (port) ; function endmodule ``` 模块整体结构由 module 和 endmodule 组成，module 后面跟着的是模块的名称(module_name)，可传递变量参数(parameter)，端口及其方向的申明(port)，紧接着就是内部逻辑功能描述(function) ,最后用 endmodule 来表示这一个模块，描述完毕。 内部逻辑功能通常由 assign 和 always 块完成；其中 assign 语句描述逻辑功能，always 块常用于描述时序功能。 ### 阻塞赋值与非阻塞赋值 在时序逻辑描述中，赋值符号有 ` ` 和 `< ` 两种。注意 `< ` 在 if 判断语句中为小于或等于，不是赋值符号。 详细解释查看底部的 [阻塞赋值与非阻塞赋值区别](#阻塞赋值与非阻塞赋值区别) ### 代码思路 写代码前我们需要先想清楚代码目的：每隔 0.5S 灯闪一次。 对此所画的需求框图如下： ![block_method](./assets/led_assets/block_method.png) 然后对于 0.5S 我们需要一个计数器来计时，LED 灯闪就是 IO 翻转 ![count_block](./assets/led_assets/time_count.png) 把上面的思维框图具体到实际使用的话，就变成下面的样式了: ![clock_time_count](./assets/led_assets/clock_time_count.png) 其中 Clock 为时钟源，用来给计时器提供准确的时间。 ### 代码描述 根据上文 Verilog 简单说明和所描述的框图，可以所要编写 Verilog 模块有 Clock 和 IO电平 两个端口； ```v module led( input Clock, output IO_voltage ); endmodule ``` 对于内部的计时模块，Primer 20K 核心板上的晶振为 27MHZ，因此我们每秒钟会有 27000000 个时钟上升沿，想要 0.5S 计数的话那么只需要计数 13500000 次上升沿就好。计数是从 0 开始的，数 13500000 的话就是从 0 数到 13499999。计数完后我们需要设置一个标志位，来通知 LED 的 IO 翻转一下电平。整体计数代码如下： ```v //parameter Clock_frequency 27_000_000; // 时钟频率为27Mhz parameter count_value 13_499_999; // 计时 0.5S 所需要的计数次数 reg [23:0] count_value_reg ; // 计数器 reg count_value_flag; // IO 电平翻转标志 always @(posedge Clock) begin if ( count_value_reg < count_value ) begin //没有计数到 0.5S count_value_reg < count_value_reg + 1'b1; // 继续计数 count_value_flag < 1'b0 ; // 不产生翻转标志 end else begin //计数到 0.5S 了 count_value_reg < 23'b0; // 清零计数器，为重新计数最准备 count_value_flag < 1'b1 ; // 产生翻转标志 end end ``` 对于 LED IO 电平翻转代码如下： ```v reg IO_voltage_reg 1'b0; // 声明 IO 电平状态用于达到计时时间后的翻转，并赋予一个低电平初始态 always @(posedge Clock) begin if ( count_value_flag ) // 电平翻转标志有效 IO_voltage_reg < ~IO_voltage_reg; // IO 电平翻转 else // 电平翻转标志无效 IO_voltage_reg < IO_voltage_reg; // IO 电平不变 end ``` 将上面的代码整合后就变成了下面的内容: ```v module led( input Clock, output IO_voltage ); /**********计时部分**********/ //parameter Clock_frequency 27_000_000; // 时钟频率为27Mhz parameter count_value 13_499_999; // 计时 0.5S 所需要的计数次数 reg [23:0] count_value_reg ; // 计数器 reg count_value_flag; // IO 电平翻转标志 always @(posedge Clock) begin if ( count_value_reg < count_value ) begin //没有计数到 0.5S count_value_reg < count_value_reg + 1'b1; // 继续计数 count_value_flag < 1'b0 ; // 不产生翻转标志 end else begin //计数到 0.5S 了 count_value_reg < 23'b0; // 清零计数器，为重新计数最准备 count_value_flag < 1'b1 ; // 产生翻转标志 end end reg IO_voltage_reg 1'b0; // 声明 IO 电平状态用于达到计时时间后的翻转，并赋予一个低电平初始态 /**********电平翻转部分**********/ always @(posedge Clock) begin if ( count_value_flag ) // 电平翻转标志有效 IO_voltage_reg < ~IO_voltage_reg; // IO 电平翻转 else // 电平翻转标志无效 IO_voltage_reg < IO_voltage_reg; // IO 电平不变 end /**********补充一行代码**********/ assign IO_voltage IO_voltage_reg; endmodule ``` 上面代码最后面补充了一行代码，是因为 IO_voltage 声明在了 port 位置，默认为 wire 型，想要将它与 reg 变量 IO_voltage_reg 连接起来，需要用到 assign 语句。 ## 综合，约束，布局布线 ### 综合 代码保存后，可以双击 IDE 内部的 Process > Synthesize 来进行代码综合，将 verilog 代码内容转换为综合网表。 ![synthesize](./assets/led_assets/synthesize.png) 关于网表有兴趣的可以自己去查阅相关资料，此处不再额外说明。 ### 约束 综合完之后我们需要进行管脚约束，才能将所编写的模块端口与 FPGA 引脚相对应，并且实现模块的功能。 点击上图 Synthesize 上面的 FloorPlanner 来进行管脚约束。 ![floorplanner](./assets/led_assets/floorplanner.png) 由于是首次创建，所以会弹出下面的对话框，点击 OK 后就弹出了图形化约束交互界面。 ![create_constrain_file](./assets/led_assets/create_constrain_file.png) ![floorplanner_intreface](./assets/led_assets/floorplanner_interface.png) 关于约束的方法可以查看 [SUG935 1.3_Gowin设计物理约束用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG935 1.3_Gowin%E8%AE%BE%E8%AE%A1%E7%89%A9%E7%90%86%E7%BA%A6%E6%9D%9F%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) 此处因个人喜所以仅使用下图中 IO Constranins 方法来约束引脚： ![floor_planner_ioconstrain](./assets/led_assets/floor_planner_ioconstrain.png) 根据[核心板原理图](https://dl.sipeed.com/fileList/TANG/Primer_20K/02_Schematic/)，我们可以知道晶振所输入的引脚为 H11。 <img src \"./assets/led_assets/crystal_port.png\" alt \"crystal_port\" width 45%> 然后结合底板上的 IO 丝印，决定用底板上的 FPGA 的 L14 引脚进行点灯，对应的 LED 编号为 LED4。 ![led_port](./assets/led_assets/led_port.png) 因此对于在 FloorPlanner 交互窗口下面的 IO Constranins 中将 PORT（端口）与 Location（引脚） 分别填入下面的值： ![io_constrain_value](./assets/led_assets/io_constrain_value.png) 输入完毕后快捷键 Ctrl + S 来保存一下引脚约束，然后接可以关闭 FloorPlanner 的交互图形界面了。 接着发现在工程项目里面多出来刚刚创建的 cst 文件了，里面的内容也比较好理解。 ![cst_content](./assets/led_assets/cst_content.png) ### 布局布线 完成约束后就要开始运行布局布线了，目的是为了把综合所生成的网表与我们自己定义的约束来通过 IDE 算出最优解然后将资源合理地分配在 FPGA 芯片上。 双击下图红框处的 Place&Route 就开始运行了。 ![place_route](./assets/led_assets/place_route.png)。 紧接着没有报错，全部通过。就可以开始进行烧录了。 ## 烧录固件 Dock 板载了下载器，在 [安装IDE](https://wiki.sipeed.com/hardware/zh/tang/Tang Nano Doc/get_started/install the ide.html) 的时候我们已经安装了驱动。因此我们将板子与电脑连接起来就行。 ![connected](./assets/led_assets/connected.png) 对于 Programmer 软件建议使用高云官网下载到 [点我跳转](http://www.gowinsemi.com.cn/faq.aspx) ，下载下图所示的 Programmer 软件即可。 ![educational_edition_programmer](./assets/led_assets/educational_edition_programmer.png) ### 扫描设备 在使用 Dock 底板的时候不要忘记使能核心板，按下 1 号拨码开关即可。 ![Enable_core_board](./../assets/start/switch_1_on.png) 双击下图中的下载程序(Program Device) 来运行 Programmer 软件 ![open_programmer](./assets/led_assets/open_programmer.png) 然后在打开的页面中点击一下 scan_device 来扫描到我们的设备。 ![scan_device](./assets/led_assets/scan_device.png) 点击 OK 后就可以进行烧录操作了。 烧录相关的文档可以参考 [SUG502 1.3_Gowin_Programmer用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG502 1.3_Gowin_Programmer%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) ### 下载到 SRAM 一般来说这个模式是以用来快速验证所生成的固件是否满足自己目的的。 因为其烧录快的特性所以使用的较多，然是当然断电会丢失数据，所以如果想上电运行程序的话是不能选这个的。 点击 Operation 下面的功能框来打开设备设置界面，接着在 Operation 框中选择 SRAM Program 选项来设置为下载到 SRAM ，最后点击下面的那三个点点框来选择我们所生成的 .fs 下载固件。通常来说下载固件生成与工程文件目录下的 impl > pnr 目录下。 ![sram_mode](./assets/led_assets/sram_mode.png) 接着来点击红框处开始进行烧录 ![sram_download](./assets/led_assets/sram_download.png) 有问题的话可以前往 [常见问题](https://wiki.sipeed.com/hardware/zh/tang/Tang Nano Doc/questions.html) 自行排查。 到这里就下载完成了。 ### 下载到 Flash 上面说过下载到 SRAM 是为了快速验证，但是不能上电运行程序。 所以想要上电运行的话我们需要设置下载到 Flash。 和上面下载到 SRAM 的步骤几乎类似，先点开 Operation 下面的功能框来打开设备设置界面，接着在 Operation 框中选择 External Flash Mode 选项来设置为下载到外部 Flash ，最后点击下面的那三个点点框来选择我们所生成的 .fs 下载固件，通常来说下载固件生成与工程文件目录下的 impl > pnr 目录下。最后在下面的外部 Flash 选项中选择设备为 Generic Flash 。 ![flash_mode](./assets/led_assets/flash_mode.png) 接着来点击红框处开始进行烧录 ![flash_download](./assets/led_assets/flash_download.png) 然后我们的程序重新上电也能照样运行了。 ## 代码结果 如图所示，只有一个灯在闪。 ![led_blink](./assets/led_assets/led_blink.gif) ## 结语 到这里我们就已经完成了 FPGA 的 “Hello world” 了。以后的示例工程不会再叙述新建文件等操作了。 ## 阻塞赋值与非阻塞赋值区别 以下内容搬运自 `大猪蹄子` （有改动）： 编写一段简单的代码，对它进行简单的仿真： ```v module test( input CLK, input [3:0] A, output reg [3:0] B,C,D,E ); always@(posedge CLK) begin B < A; C < B; D A; E D; end endmodule ``` ![simulation_result](./assets/led_assets/simulation_result.png) 根据仿真结果我们可以看出阻塞和非阻塞赋值的差别。这里对比 `B` `C` `D` `E` 四种结果。`< ` 叫做非阻塞赋值，同一个 `always` 中的 `< ` 会同时执行。这就造成了绿框内的情况：`B` 直接被赋予 `A` 的值同时 `C` 被赋予 `B` 的值。由于这两步是同时进行的，就导致 `C` 被赋予的值是 `B` 的旧值，也就造成了图中所示，`C` 的数据变化时钟要慢 `B` 一个时钟周期。再说阻塞赋值 ` `，也就是说同一个 `always` 中上一个 ` ` 语句执行完才会执行下一个 ` ` 语句。在这个代码中，上一个语句 `D` 已经被赋予了 `A` 的值，才执行把 `D` 的值赋给 `E`，所以 `D` 、`E` 的值在仿真中始终保持一致。 > 不过一般来说，不建议在时序逻辑中使用阻塞赋值 ` `。 也得出了额外两个结论： 第一，输入的数据不是完全有效，以时钟边沿时刻的输入数据为准。`posedge` 就是以上升沿执行，`negedge` 就是以下降沿执行。如果数据维持的时间小于一个时钟周期，就很有可能采集不到（如红框所示）。 第二、每次触发特定时钟边沿，对应的 `always` 块就会从头到尾执行一次代码（如绿框所示），而不是从中间某处执行。 ## 常见问题 ### No Cable found 检查设备管理器里有没有下图这两个，没有的话需要安装 Programmer 驱动。 ![converter](./../../assets/questions/converter.png) 确定有 converter 设备的话在确认用的是不是所要求使用的 Programmer, 本文[这里](#烧录固件)有写过。 ### No gowin device found 确认自己使能了核心板。 ### 其他问题 前往 [Gowin 板卡常见问题查看](./../../Tang Nano Doc/questions.html)"},"/hardware/zh/tang/tang-primer-20k/examples/gao.html":{"title":"Tang Primer 20K Dock 点一个灯仿真","content":" title: Tang Primer 20K Dock 点一个灯仿真 tags: Tang Primer 20K Dock，上手 keywords: Primer, Tang, Dock，入门，20K, GAO desc: 使用 GAO update: date: 2022 09 22 version: v0.1 author: wonder content: 初稿 "},"/hardware/zh/tang/tang-primer-20k/examples/lcd.html":{"title":"","content":"# 施工中"},"/hardware/zh/tang/tang-primer-20k/examples/key_6leds_on.html":{"title":"Tang Primer 20K Dock 按键点六个灯","content":" title: Tang Primer 20K Dock 按键点六个灯 tags: Tang Primer 20K Dock，上手 keywords: Primer, Tang, Dock， 入门，20K desc: Tang Primer 20K Dock 基础进阶 update: date: 2022 11 27 version: v0.1 author: wonder content: 初稿 前面已经完成按键亮两个灯操作了，板子上还剩下五个 LED 可自定义操作，这次可以使用位拼接运算符 `{` `}` 来一起控制六个 LED。 ## 位拼接运算符 ### 例子① 语法： `assign c[5:0] {{3{1'b1}},{3{1'b0}}};` 等效于 `assign c[5:0] 6'b111000 ;` ### 例子② 语法： ```verilog wire [2:0] a 3'b111; wire [2:0] b 3'b000; wire [5:0] c {a,b} ; ``` 等效于 `assign c[5:0] 6'b111000 ;` ## 硬件电路说明 从 [原理图](https://dl.sipeed.com/shareURL/TANG/Primer_20K/02_Schematic) 中，可以知道以下信息： ### 按键电路： 根据 DOCK 底板原理图，可以看出当板载按键按下时，对应的 FPGA 引脚会为低电平输入。 板载按键电路原理图 板载按键与 FPGA 连接引脚图 ![key_schematic](./assets/key_led_on/key_schematic.png) ![key_pin](./assets/key_led_on/key_pin.png) ### LED 电路: 根据 LED 电路，可以知道当 FPGA 引脚为低电平的时候对应连接的 LED 会亮起来。 板载自定义 LED 电路原理图 板载自定义 LED 与 FPGA 连接引脚图 ![key_schematic](./assets/key_led_on/led_schematic.png) ![key_pin](./assets/key_led_on/led_pin.png) 所以直接将按键引脚的逻辑电平输出为 LED 的引脚逻辑电平就可以点亮 LED 灯。 ## 操作 ### 引脚复用 READY DONE SSPI ### 端口和引脚 Port Direction Location key input T10 led[5] output L16 led[4] output L14 led[3] output N14 led[2] output N16 led[1] output A13 led[0] output C13 ### 代码 .. tabset:: ## key_6leds_on.v Verilog文件； 定义了一个按键输入端口，和六个输出端口。六个输出端口的 IO 电平状态由输入端口决定。 ```verilog module key_6leds_on( input key, output [5:0] led ); assign led[5:0] {{3{key}},{3{~key}}}; // led[5:0] {key,key,key,~key,~key,~key}; endmodule ``` ## key_6leds_on.cst 物理约束文件； 将 verilog 代码里的端口绑定到 FPGA 引脚上面 ```txt IO_LOC \"led[5]\" L16; IO_PORT \"led[5]\" PULL_MODE UP DRIVE 8; IO_LOC \"led[4]\" L14; IO_PORT \"led[4]\" PULL_MODE UP DRIVE 8; IO_LOC \"led[3]\" N14; IO_PORT \"led[3]\" PULL_MODE UP DRIVE 8; IO_LOC \"led[2]\" N16; IO_PORT \"led[2]\" PULL_MODE UP DRIVE 8; IO_LOC \"led[1]\" A13; IO_PORT \"led[1]\" PULL_MODE UP DRIVE 8; IO_LOC \"led[0]\" C13; IO_PORT \"led[0]\" PULL_MODE UP DRIVE 8; IO_LOC \"key\" T10; IO_PORT \"key\" PULL_MODE UP; ``` ## 效果 松开 S0 按键，LED0、LED1 和 LED2 亮，LED3、LED4 和 LED5 灭。 按下 S0 按键，LED3、LED4 和 LED5 亮，LED0、LED1 和 LED2 灭。 <! 松开 S0 按键按下 S0 按键 <img src \"./assets/key_led_on/led_off.png\" alt \"led_off\"><img src \"./assets/key_led_on/led_on.png\" alt \"led_on\"> > <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/tang-primer-20k/examples/timing_decode_led_on.html":{"title":"Tang Primer 20K 译码器亮灯","content":" title: Tang Primer 20K 译码器亮灯 keywords: Tang Primer 20K ,例程, 上手 update: date: 2022 11 03 version: v0.1 author: wonder content: 初稿 ## 说明 在前面的 [译码器亮灯](./decode_led_on.html) 中，使用 verilog 语句来写出真值表达式来达到译码器的目的。这里介绍使用 case 语句来实现译码器功能。 在前面的 [译码器亮灯](./decode_led_on.html) 中，我们所需要的最终结果如下： <table> <tr> <th colspan \"2\"> 按键 </th> <th colspan \"4\">LED 电平状态</th> </tr> <tr> <td>S0</td> <td>S1</td> <td>LED0</td> <td>LED1</td> <td>LED2</td> <td>LED3</td> </tr> <tr> <td></td> <td></td> <td>0</td> <td></td> <td></td> <td></td> </tr> <tr> <td>0</td> <td></td> <td></td> <td>0</td> <td></td> <td></td> </tr> <tr> <td></td> <td>0</td> <td></td> <td></td> <td>0</td> <td></td> </tr> <tr> <td>0</td> <td>0</td> <td></td> <td></td> <td></td> <td>0</td> </tr> </table> ### case 语法 ## 操作 ### 引脚复用 READY DONE SSPI ### 端口和引脚 Port Direction Location key[0] input T10 key[1] input T3 led[0] output C13 led[1] output A13 led[2] output N16 led[3] output N14 ### 代码 .. tabset:: ## decode_led_on.v Verilog文件； 定义了两个按键输入端口，和四个输出端口。根据按键输入的状态，译码输出到对应的端口。 ```verilog module decode_led_on( input [1:0] key, output [3:0] led ); assign led[0] !( key[0] & key[1] ) ; assign led[1] !(!key[0] & key[1] ) ; assign led[2] !( key[0] &!key[1] ) ; assign led[3] ( key[0] key[1] ) ; endmodule ``` ## decode_led_on.cst 物理约束文件； 将 verilog 代码里的端口绑定到 FPGA 引脚上面 ```txt IO_LOC \"led[3]\" N14; IO_LOC \"led[2]\" N16; IO_LOC \"led[1]\" A13; IO_LOC \"led[0]\" C13; IO_LOC \"key[1]\" T3; IO_LOC \"key[0]\" T10; IO_PORT \"led[3]\" PULL_MODE UP DRIVE 8; IO_PORT \"led[2]\" PULL_MODE UP DRIVE 8; IO_PORT \"led[1]\" PULL_MODE UP DRIVE 8; IO_PORT \"led[0]\" PULL_MODE UP DRIVE 8; IO_PORT \"key[1]\" PULL_MODE UP; IO_PORT \"key[0]\" PULL_MODE UP; ``` ## 效果 默认只有 LED0 亮；按下 S0 按键 LED1 亮；按下 S1 按键 LED1 亮；按下 S0 和 S2 按键 LED3 亮； <table> <tr> <th colspan \"2\" >按键</th> <th colspan \"4\">LED 状态</th> </tr> <tr> <td>S0</td> <td>S1</td> <td>LED0</td> <td>LED1</td> <td>LED2</td> <td>LED3</td> </tr> <tr> <td></td> <td></td> <td>亮</td> <td></td> <td></td> <td></td> </tr> <tr> <td>按下</td> <td></td> <td></td> <td>亮</td> <td></td> <td></td> </tr> <tr> <td></td> <td>按下</td> <td></td> <td></td> <td>亮</td> <td></td> </tr> <tr> <td>按下</td> <td>按下</td> <td></td> <td></td> <td></td> <td>亮</td> </tr> </table> <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/tang-primer-20k/start.html":{"title":"Tang Primer 20K 开箱指南","content":" title: Tang Primer 20K 开箱指南 keywords: FPGA, Primer, Tang, 20K update: date: 2022 09 16 version: v0.1 author: wonder content: 首次编辑 持续施工中 Primer 20K 底板有 Lite 和 Dock 两款，这里分开说明一下 ## Dock 开箱指南 ### 注意事项 首先列出相关注意事项，来避免因为操作不当所产生的问题却花费大量时间但又未解决。 #### 使能核心板 对于 Dock 板，使用的时候需要注意将拨码开关 1 号位开启，以此来使能核心板。 使能核心板 未使能状态 补充说明 <img src \"./assets/start/switch_1_on.png\" alt \"switch_1_on\" width 100%><img src \"./assets/start/reset_led_on.png\" alt \"reset_led_on\" width 100%> 未使能核心板的话板子上的 0、1 号 LED 会一直亮着，且核心板不会正常启动。 #### 设备不工作 默认的包装盒里已经将核心板组装在底板上面了，但是有时候因为一些必要操作需要取下核心板。 然后再次组装回去后发现设备不再工作了，这个时候我们需要确认一下核心板与底板是否连接好。 正确的连接顺序是先将核心板斜插入到底板中，倾斜角度大概如如下图左图所示。确定从上面看到斜插入的核心板与底板均匀接触，可以从金手指裸露出来的均匀程度来判断。 <img src \"./assets/start/edge_view.png\" alt \"edge_view\" width 45%> <img src \"./assets/start/top_view.png\" alt \"top_view\" width 35%> 然后轻压翘起来的那一头，可以清脆的听见核心板被底板插槽固定住的声音。 如果按压时候觉得困难的话，可以尝试将核心板两侧稍微打磨一下，来消除由于生产工艺所带来的尺寸误差。 <img src \"./assets/start/clean_core_board.png\" alt \"clean_core_board\" width 20%> 将上图红框的两处侧边稍微打磨一下，来减少配合时的困难。 #### 硬件改版说明 对于 Dock 底板，可以从如下图所指的位置来了解当前自己所使用的板子版本。 ![version](./assets/start/dock version.png) 比如上面这张图的板子的版本号为 V3708 下面是有问题的版本修正： ##### V3708 LED2 与 LED3 的丝印错误，应当为： 外设 正确引脚 错误丝印 LED2 N16 B14 LED3 N14 N16 ### 开始使用 对于 Dock 底板，默认固件可进行如下操作： 按下 S0 按键，复位 RGB 屏幕、摄像头、HDMI 信号复位，且 3、4、5 号三个 LED 会常亮。 S2 到 S5 按键及 2 号到 5 号拨码开关控制 0、1、2 三个 LED 灯的状态 将 OV5640 摄像头与 4.3寸 RGB 屏幕连接到板子上（连接时注意断开板子电源），屏幕上面会显示摄像头所捕获到的画面。如果屏幕显示有撕裂现象的话，可以按下 S0 按键来同步一下输出画面。 默认固件中，将 3、4 号两个灯设置为时钟检测信号，可以通过这两个灯的状态来鉴别设备是否工作。 ### 实战使用 [点一个灯](./examples/led.html) ### 相关问题 使用中碰到问题可以先前往 [常见问题](https://wiki.sipeed.com/hardware/zh/tang/Tang Nano Doc/questions.html) 来查看解决方法。 ## Lite 开箱说明 ### 硬件版本说明 对于 Lite 底板，可以从如下图所指的位置来了解当前自己所使用的板子版本。 ![lite version](./assets/start/lite version.png) 比如上面这张图的板子的版本号为 3710 下面是有问题的版本修正： #### 3710 底板 R8 与 P9 之间为 P8 引脚。参考右图左上方，已标明 <div> <img src \"./assets/lite up.png\" alt \"lite up\" width 45%> <img src \"./assets/lite back.png\" alt \"lite back\" width 45%> </div> ### 实战使用 [点一个灯](https://wiki.sipeed.com/news/others/20k_lite_start/20k_lite_start.html) ### 相关问题 使用中碰到问题可以先前往 [常见问题](https://wiki.sipeed.com/hardware/zh/tang/Tang Nano Doc/questions.html) 来查看解决方法。"},"/hardware/zh/tang/tang-primer-20k/primer-20k.html":{"title":"Tang Primer 20K","content":"# Tang Primer 20K ## 概述 Tang Primer 20K 是基于 [GW2A LV18PG256C8/I7](http://www.gowinsemi.com.cn/prod_view.aspx?TypeId 10&amp;FId t3:10:3&amp;Id 167#GW2A) 所设计的一款 DDR3 sodimm 封装的核心板，额外准备了两个底板，分别为 Dock 底板和 Lite 底板。 <div> <img src \"./assets/20k_front.png\" width 45%> <img src \"./assets/20k_back.png\" width 45%> </div> 购买链接：[淘宝](https://item.taobao.com/item.htm?&id 680099020807) ## 基础参数 <table> \t<thead> \t\t<tr> \t\t\t<th style \"text align:center\">项目</th> \t\t\t<th style \"text align:center\">参数</th> \t\t\t<th style \"text align:center\">补充</th> \t\t</tr> \t</thead> \t<tbody> \t\t<tr> \t\t\t<td style \"text align:left\">FPGA 芯片</td> \t\t\t<td style \"text align:left\"><a href \"http://www.gowinsemi.com.cn/prod_view.aspx?TypeId 10&amp;FId t3:10:3&amp;Id 167#GW2A\">GW2A LV18PG256C8/I7</a> \t\t\t</td> \t\t\t<td style \"text align:left\"> \t\t\t\t<table> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>逻辑单元(LUT4)</td> \t\t\t\t\t\t<td>20736</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>寄存器(FF)</td> \t\t\t\t\t\t<td>15552</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>分布式静态随机存储器S SRAM(bits)</td> \t\t\t\t\t\t<td>41472</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>块状静态随机存储器B SRAM(bits)</td> \t\t\t\t\t\t<td>828K</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>块状静态随机存储器数目B SRAM(个)</td> \t\t\t\t\t\t<td>46</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>乘法器(18x18 Multiplier)</td> \t\t\t\t\t\t<td>48</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>锁相环(PLLs)</td> \t\t\t\t\t\t<td>4</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>I/O Bank 总数</td> \t\t\t\t\t\t<td>8</td> \t\t\t\t\t</tr> \t\t\t\t</table> \t\t\t</td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">内存</td> \t\t\t<td style \"text align:left\">128M DDR3</td> \t\t\t<td style \"text align:left\">128Meg x 16</td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">Flash</td> \t\t\t<td style \"text align:left\">32Mbits NOR Flash</td> \t\t\t<td style \"text align:left\">下载方式参考底部相关问题</td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">调试接口</td> \t\t\t<td style \"text align:left\">Jtag + Uart</td> \t\t\t<td style \"text align:left\">JST SH1.0 8Pins 连接器</td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">SD 卡槽</td> \t\t\t<td style \"text align:left\">一个</td> \t\t\t<td style \"text align:left\">推拉式</td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">显示接口</td> \t\t\t<td style \"text align:left\">8Pins spi lcd 连接器</td> \t\t\t<td style \"text align:left\"></td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">整体封装</td> \t\t\t<td style \"text align:left\">204P DDR3 Sodimm 金手指</td> \t\t\t<td style \"text align:left\"></td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">可用 IO</td> \t\t\t<td style \"text align:left\">一共 117 个</td> \t\t\t<td style \"text align:left\"></td> \t\t</tr> \t</tbody> </table> ## 底板对比 ### Dock 底板产品图 其中 LED2 和 LED3 所对应的引脚编号为 N16 和 N14。查阅右图左方，已标明。 <div> <img src \"./assets/dock up.png\" alt \"dock up\" width 45%> <img src \"./assets/dock back.png\" alt \"dock back\" width 45%> </div> ### Lite 底板产品图 底板 R8 与 P9 之间为 P8 引脚。参考右图左上方，已标明 <div> <img src \"./assets/lite up.png\" alt \"lite up\" width 45%> <img src \"./assets/lite back.png\" alt \"lite back\" width 45%> </div> ### 外设参数对比 <table> \t<thead> \t\t<tr> \t\t\t<th rowspan \"2\" colspan \"2\">项目</th> \t\t\t<th colspan \"2\">Dock</th> \t\t\t<th colspan \"2\">Lite</th> \t\t</tr> \t\t<tr> \t\t\t<th>数量</th> \t\t\t<th>补充说明</th> \t\t\t<th>数量</th> \t\t\t<th>补充说明</th> \t\t</tr> \t</thead> \t<body> \t\t<tr> \t\t\t<td colspan \"2\">RGB 接口</td> \t\t\t<td>1</td> \t\t\t<td>RGB565 40P FPC 连接器</td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">DVP 接口</td> \t\t\t<td>1</td> \t\t\t<td>24P FPC 连接器</td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">麦克风阵列接口</td> \t\t\t<td>1</td> \t\t\t<td>10P FPC 连接器</td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">触摸接口</td> \t\t\t<td>1</td> \t\t\t<td>4P FPC 连接器</td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">PMOD 接口</td> \t\t\t<td>4</td> \t\t\t<td></td> \t\t\t<td>4</td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">3.5mm 耳机接口</td> \t\t\t<td>1</td> \t\t\t<td>使用 LPA4809MSF 驱动</td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">拨码开关</td> \t\t\t<td>1</td> \t\t\t<td>5P 拨码开关</td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">滑动开关</td> \t\t\t<td>1</td> \t\t\t<td>切换板载 USB 功能</td> \t\t\t<td>2</td> \t\t\t<td>用户自定义功能</td> \t\t</tr> \t\t<tr> \t\t\t<td style \"white space:nowrap\" rowspan \"2\">Type C 接口</td> \t\t\t<td style \"white space:nowrap\">USB JTAG&UART</td> \t\t\t<td>1</td> \t\t\t<td>板载 BL702 芯片用来<br>下载比特流并提供串口功能</td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td>自定义 USB</td> \t\t\t<td>1</td> \t\t\t<td>USB3317 芯片与滑动开关<br>来自定义该 USB 接口功能</td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">无线天线</td> \t\t\t<td>1</td> \t\t\t<td>使用 BL702 芯片的无线功能</td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">按键</td> \t\t\t<td>6</td> \t\t\t<td>一个用来烧录 BL702,<br>剩下五个用户自定义功能</td> \t\t\t<td>2</td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">LED</td> \t\t\t<td>6</td> \t\t\t<td></td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">HDMI 接口</td> \t\t\t<td>1</td> \t\t\t<td></td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">以太网接口</td> \t\t\t<td>1</td> \t\t\t<td>TL8201F 芯片实现以太网功能</td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">RGB LED</td> \t\t\t<td>1</td> \t\t\t<td>WS2812</td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t</body> </table> ## 硬件资料 规格书、原理图、尺寸图等均可在这里找到：[点击这里](https://dl.sipeed.com/shareURL/TANG/Primer_20K) [板卡规格书](https://dl.sipeed.com/shareURL/TANG/Primer_20K/01_Specification) [板卡原理图](https://dl.sipeed.com/shareURL/TANG/Primer_20K/02_Schematic) [板卡点位图](https://dl.sipeed.com/shareURL/TANG/Primer_20K/03_Bit_number_map) [布线长度表](https://dl.sipeed.com/shareURL/TANG/Primer_20K/04_Net_Length) [板卡尺寸图](https://dl.sipeed.com/shareURL/TANG/Primer_20K/05_Dimensional_drawing) [核心板封装](https://dl.sipeed.com/shareURL/TANG/Primer_20K/06_Footprint) (KICAD) [芯片部分资料](https://dl.sipeed.com/shareURL/TANG/Primer_20K/07_Chip_manual) [3D 模型文件](https://dl.sipeed.com/shareURL/TANG/Primer_20K/08_Dimensions) ## 上手简明 `准备开发环境` > `学习相关语法` > `查看开箱指南` > `基础代码编写` > `查看官方文档` 1. 安装 IDE ：[点击这里](./../Tang Nano Doc/get_started/install the ide.html) 2. 查看 [上手指南](https://wiki.sipeed.com/hardware/zh/tang/tang primer 20k/start.html) 来避免一些问题，并且从那里面可以开始进行代码实战。 3. 如果进行完上面的点灯操作后后感觉有压力，可以自己查漏补缺： 可以在下面的这些网站学习 Verilog: \t+ 在线免费教程：[Verilog 教程](https://www.runoob.com/w3cnote/verilog tutorial.html)（学习Verilog） \t+ 在线免费 FPGA 教程：[Verilog](https://www.asic world.com/verilog/index.html) （英文网站） \t+ Verilog 刷题网站：[HDLBits](https://hdlbits.01xz.net/wiki/Main_Page)（英文网站） \t+ 在线高云半导体可参考视频教程：[点击这里](http://www.gowinsemi.com.cn/video_complex.aspx?FId n15:15:26) 对 IDE 使用有疑问的话，可以查看官方的一些文档来熟悉相关内容 [SUG100 2.6_Gowin云源软件用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG100 2.6_Gowin%E4%BA%91%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) [SUG949 1.1_Gowin_HDL编码风格用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG949 1.1_Gowin_HDL%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) <a href \"http://cdn.gowinsemi.com.cn/UG286 1.9.1_Gowin%E6%97%B6%E9%92%9F%E8%B5%84%E6%BA%90(Clock)%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf\">UG286 1.9.1_Gowin时钟资源(Clock)用户指南.pdf</a> [SUG940 1.3_Gowin设计时序约束用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG940 1.3_Gowin%E8%AE%BE%E8%AE%A1%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) [SUG502 1.3_Gowin_Programmer用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG502 1.3_Gowin_Programmer%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) [SUG114 2.5_Gowin在线逻辑分析仪用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG114 2.5_Gowin%E5%9C%A8%E7%BA%BF%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90%E4%BB%AA%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) 上面的所有文档都已经打包进了下载站[点我跳转](https://dl.sipeed.com/shareURL/TANG/Primer_20K/07_Chip_manual/CN/%E9%80%9A%E7%94%A8%E6%8C%87%E5%BC%95)，需要的话可以点击压缩包全都下载下来。 ## 例程汇总 ### 公开例程 github 链接： https://github.com/sipeed/TangPrimer 20K example ### 部分教程 Lite 底板点灯 ：<a href \"https://wiki.sipeed.com/news/others/20k_lite_start/20k_lite_start.html\" target \"blank\">点我跳转</a> Dock 底板例程指南: [点我跳转](https://wiki.sipeed.com/hardware/zh/tang/Tang Nano Doc/questions.html) ## 交流方式 **交流论坛: [bbs.sipeed.com](https://bbs.sipeed.com)** **QQ 交流群：[834585530](https://jq.qq.com/?_wv 1027&k wBb8XUan)** 直接本页下方留言 商业邮箱 : [support@sipeed.com](support@sipeed.com) ## 补充说明 对于板子上的 bank 0、bank 1、bank 7 这 3 个 bank 电压，默认所接的是 3.3V，对应的 bank IO 会对外输出 3.3V 电压。如果需要输入自定义的 IO bank 电压，请拆除 R5 和 R9，请参考对应 Assembly [点我跳转](https://dl.sipeed.com/shareURL/TANG/Primer_20K/03_Bit_number_map) 图来确定 R5 和 R9 的位置。 ![io_vltage](./assets/io_vltage.png) 对应核心板原理图上在金手指处的说明如下 ![sodimm_voltage](./assets/sodimm_voltage.png) ## 相关问题 ### Dock 底板不工作 拨下 1 号拨码开关以使能核心板，不然底板会不工作且 LED0 和 LED1 常亮。 使能核心板 未使能核心板 ![switch_1_on](./assets/start/switch_1_on.png) ![reset_led_on](./assets/start/reset_led_on.png) <! <img src \"./assets/start/switch_1_on.png\" alt \"switch_1_on\" width 20%> > ### 如何下载到外部 FLASH 进行如下选项设置： <img src \"./assets/flash_mode.png\" alt \"flash_mode\" width 75%> ### 烧录后没反应或者引脚现象不对 首先确定选择了正确的型号，下图中的每一个参数都要求一致 <img src \"./assets/device_choose.png\" alt \"device_choose\" width 75%> 然后检查自己的代码和对应的仿真波形是否满足要求 ### 成功烧录过一次外部 Flash 后 Programmer 软件无法再烧录 注意描述是成功烧录过一次 Flash。 这种情况默认为启用了错误的引脚复用而导致下载器不能再识别到 FPGA 的 JTAG。可以短接 Flash 的 1、4 引脚，让芯片上电时不能正常读 FLASH 。 ![flash_cs](./assets/flash_cs.png) 如果有 dock 底板的话，可以直接操作一号拨码开关重新救活核心板，具体操作如下： 首先正常使能核心板，将拨码开关一号位拨下。然后在 Programmer 软件中，选择一个操作（烧写、擦除都可以），当 Programmer 软件中进度条出现的时候，快速将一号拨码开关拉高，然后再拉低重新使能核心板，这样就会发现 Programmer 可以正常烧录 FPGA 板卡了。 <table> \t<tr> \t\t<td><img src \"./assets/start/switch_1_on.png\" alt \"switch_1_on\"></td> \t\t<td> 首先使能核心板。</td> \t</tr> \t<tr> \t\t<td><img src \"./assets/start/progress_bar.jpg\" alt \"progress_bar\"></td> \t\t<td> 对板卡进行操作，出现进度条的时候快速拨动使能引脚。 </td> \t</tr> \t<tr> \t\t<td> \t\t<img src \"./assets/start/switch_1_off.jpg\" alt \"switch_1_off\" witdh \"25%\"> \t\t<img src \"./assets/start/switch_1_on.png\" alt \"switch_1_on\" witdh \"25%\"> \t\t</td> \t\t<td> 先向上拨动1号拨码开关，再向下拨动 </td> \t</tr> \t<tr> \t\t<td><img src \"./assets/start/progress_bar_running.jpg\" alt \"progress_bar_running\"><img src \"./assets/start/progress_bar_finishing.jpg\" alt \"progress_bar_finishing\"></td> \t\t<td> 然后就看到进度条正常，操作顺利 </td> \t</tr> </table> ### 更多问题及其解决办法前往[相关问题](./../Tang Nano Doc/questions.html)查看"},"/hardware/zh/tang/tang-primer-20k/example.html":{"title":"Tang Primer 20K 例程指南","content":" title: Tang Primer 20K 例程指南 keywords: Tang Primer 20K ,例程, 上手 update: date: 2022 09 29 version: v0.1 author: wonder content: 目录确定 ## LED 篇 Dock 底板上六个 LED 可以拿来做不少新手实验 组合逻辑操作： [约束亮灯](./examples/assign_led.html)（快速熟悉 IDE，必看） [按键亮灯](./examples/key_led_on.html) (后续文档规范，必看) [异或逻辑亮灯](./examples/xor_led_on.html) [译码器亮灯](./examples/decode_led_on.html)（数电表达式实现） <! [译码器亮灯](./examples/timing_decode_led_on.html)（ verilog case 语句实现） > [位拼接运算](./examples/key_6leds_on.html) 时序逻辑操作： [计数器亮灯](./examples/led.html) [流水灯](./examples/water_led.html) 呼吸灯 ## RGB LCD 篇 ## SPI LCD 篇 ## CAM LCD 篇 ## 余下工程 HDMI USB 示例 以太网"},"/hardware/zh/tang/Tang-Nano/examples/led/github_sourcecode.html":{"title":"使用github例程","content":"# 使用github例程 首先获得仓库文件 https://github.com/sipeed/Tang Nano examples 打开 Tang Nano examples\\example_led\\led_prj 目录下的 led_prj.gprj 文件 在process界面右键选择 clean&Rerun all ![](./assets/github_place&route.png) 紧接着会报错（这是历史问题，有兴趣可以自己查查）。 顶部菜单栏 Project > Configuration > Syntheize 选择 GowinSyntheize 后点击**确定**，然后重新在 Place&Route 右键 clean&Rerun all ![](./assets/Change_Synthesis.png) 然后是进行连接板子，烧录固件。在Process界面双击`Program Device` 后打开烧录工具 ![](./assets/Open_Programmer.png) 接下来选择sram烧录即可验证程序。 ![](./assets/Success_led.png) <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano/examples/led/self_create.html":{"title":"自己点灯","content":"# 自己点灯 ## 新建项目 新建工程：File >NEW >FPGA Design Project >OK ![](./../../assets/LED 1.png) 弹出的选项框选择存储路径和工程名称（路径和文件名称要求是英文路径） ![](./../../assets/LED 2.png) 选择对应的型号： ![Tang_nano_1k_device_choose](./assets/Nano_device_choose.png) ## 编写代码 新建好工程之后接下来进行代码编辑，在Design工作栏内新建“Verilog File”,如下图所示： ![](./../../assets/LED 5.png) 为文件命名（要求写英文名，不然后续综合很容易报错）； 一般来说对于verolog文件建议文件名称与文件module名称应当相同 ![](./../../assets/LED 6.png) 双击新建的 .v 文件，可以在右侧的编辑框中编写代码。 ![](./../../assets/LED 7.png) ### Verilog 预备知识 这里只介绍接下来会用到的相关语法，更多的可以参考 《Verilog 数字系统设计教程》 Verilog 的基本设计单元是模块，一个模块是由两部分组成的，一部分描述接口，另一部分描述逻辑功能，即描述输出和输入的关系的。 模块就像我们平时提到的黑匣子，当我们实现了模块后，就不需要去关心模块内部，只需要根据模块定义的输入输出格式，将模块实例化，给模块提供输入，就可以让模块自己工作了 一个模块长成这样 ```v module module_name #(parameter) (port) ; Function description; endmodule ``` 模块整体结构由 module 和 endmodule 组成，module 后面跟着的是模块的名称，可传递变量参数，接口的定义，声明了端口的方向 模块内部有时候会使用内部的信号，内部信号有 wire 和 reg 类型 功能的定义可以通过 assign 和 always 块完成。 assign 是描述组合逻辑最常用的方法之一； always 可用于描述组合逻辑，也可描述时序逻辑 ### 示例代码 以流水灯为例；将下方的代码粘贴到自己的文件中，也可以自己编写代码。 ```verilog module led ( input sys_clk, input sys_rst_n, output reg [2:0] led // 110 B, 101 R, 011 G ); reg [23:0] counter; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) counter < 24'd0; else if (counter < 24'd1199_9999) // 0.5s delay counter < counter + 1'b1; else counter < 24'd0; end always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) led < 3'b110; else if (counter 24'd1199_9999) // 0.5s delay led[2:0] < {led[1:0],led[2]}; else led < led; end endmodule ``` ## 综合、约束、布局布线 ### 综合 保存编辑的代码后转到“Process”界面下，对编辑好的代码进行综合，即双击“Synthesize” ![](./../../../Tang Nano 9K/nano_9k/nano_9k_synthsize.png) 运行之后如没有报错而且 Synthesize 变成下图里的图标 ![](./../../../Tang Nano/assets/LED.png) 说明前面编辑的代码无误；如果有错，根据错误提示进行改正即可。 ### 约束 此处未涉及时钟约束 想让 Fpga 实现代码的功能，必须将代码中涉及的 端口 绑定到 Fpga 实际的引脚上。 如下图，在左边的工作区点击 process，然后双击 FloorPlanner ![](./../../../assets/examples/led_pjt_2.png) 接下来通过 双击 Process 界面里的FloorPlanner来设置管脚约束。第一次打开会弹出缺少.cst文件.选择“OK”即可； ![](./../../assets/LED 9.pngassets/LED 9.png) nano 的 rgb led电路图如下所示 ![](./assets/nano_led_pins.png \"nano rgb pins\") 整个项目需要约束的引脚如下 port I/O pin desc sys_clk input 35 时钟输入脚 sys_rst_n input 15 系统复位脚 led[0] output 16 绿灯 led[1] output 17 蓝灯 led[2] output 18 红灯 对于交互式管脚约束有下图中的两种方法 将对应的端口拖拽到芯片引脚上 在IO约束中输入端口对应的引脚编号 在打开的界面中按照序号的顺序来进行相应的操作（两种方式选择一种即可） ![](./assets/pin_constrain_1.png) ![](./assets/pin_constrain_2.png) 直接编写约束文件方法用户自行研究 关于 FloorPlanner 更多的相关说明，可以参考 [SUG935 1.3_Gowin设计物理约束用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG935 1.3_Gowin%E8%AE%BE%E8%AE%A1%E7%89%A9%E7%90%86%E7%BA%A6%E6%9D%9F%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf)。里面的内容都很有用 ### 布局布线 到“Process”下运行“Place&Route”，即运行管脚布局布线，运行结果如下图所示： ![](./assets/RGB_LED_Place&Route.png) ## 烧录 接下来是连接板子，烧录固件。在Process界面双击 `Program Device` 后打开烧录工具 ![](./assets/Open_Programmer.png) 可以在图中进行相应的修改 ![](./../../../../../zh/tang/Tang Nano/examples/led/assets/tang nano programmer config.png) 接下来选择sram烧录即可验证程序。 ![](./assets/Success_led.png) 点灯验证到此结束。 ## 结语 有问题的话可以在下方留言。 <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano/examples/1_led.html":{"title":"点灯","content":"# 点灯 > 编辑于2022年3月29日 ## 前言 本文提供两种方法点灯 [使用github仓库](./led/github_sourcecode.html) [自己新建项目](./led/self_create.html) <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano/examples/2_lcd.html":{"title":"RGB LCD 示例","content":"# RGB LCD 示例 > 编辑于2022.04.12 ## 先介绍时序 RGB LCD 显示协议和 VGA 类似，通信都有专用的行同步、场同步信号线。它们的主要区别是前者传输用的是数字信号，后者传输走的是模拟信号。 下面就介绍 VGA 的时序 ![](./../../assets/examples/lcd_pjt_1.png) 上图分别是 VGA 在数据传输中的行同步、场同步时序 从时序图中可以看出，不论是显示一行数据还是一列数据，都需要一个对应的同步(sync)信号，数据的传输在两个同步信号的脉冲之间完成 每一行的数据包括显示前沿(back porch)、有效数据(active video)、显示后沿(front porch)三个阶段 其中的有效数据就是我们常说的分辨率，而显示前后沿的参数需要参考具体的分辨率与帧数进行设置，相关参数可以参考典型参数，链接在此： http://www.tinyvga.com/vga timing 这块5寸屏幕的控制时序略有不同，相关参数的设置可以查看[规格书](https://dl.sipeed.com/fileList/TANG/Nano%209K/6_Chip_Manual/CN/LCD_Datasheet/5.0inch_LCD_Datashet%20RGB.pdf) 其他尺寸的屏幕相关规格书均可以在这里下载 [点我](https://dl.sipeed.com/shareURL/TANG/Nano%209K/6_Chip_Manual/CN/LCD_Datasheet) 下面为这块 LCD 时序相关的截图 ![](./../../assets/examples/lcd_pjt_2.png) ![](./../../assets/examples/lcd_pjt_3.png) 上面一张图是时序中的参数表，下面的图是时序图 从时序图中看出，这块屏幕可以不用设置前后沿，可以只设置消影(blanking)时间，通过实际的程序证明，两种方式都是可以的 ## 新建工程 新建工程方法参考[自建点灯文章(点我)](./led/self_create.html) ## 生成屏幕时钟 这里需要用到高云半导体官方的IP核 板载的晶振时钟为 24MHz ，但是我们的屏幕要求 33.3MHZ 的时钟，所以我们需要使用对应的ip核来生成相应的时钟 ### pll 这里需要使用到 `IP Core Generate` ，位置在 Tools > IP Core Generate ![](./../../Tang Nano 1K/assets/Gowin_IP_rpll.png) 双击 `rPLL` ，在弹出窗口 language 选择 Verilog ，CLKIN 为 24MHz ，CLKOUT 为 200MHz，CLKOUTD 要选择 Enable，然后生成时钟为 33.33MHz，Tolerance 选择 0.2% ![](./../../assets/examples/lcd_pjt_5.png) 点击ok后提示是否需要添加到当前工程，此时应当选择确定 ![](./led/assets/add_ip_file_in_project.png) 接着会出现一个例化的tmp文件，用来例化所设置的ip。比如下图中例子 ![](./led/assets/ip_examples.png) ### osc **这一步可以不做** 系统的时钟可以由外部时钟提供，也可以使用 OSC 生成的时钟 同样也是使用 `IP Core Generate` 找到 `OSC` 并双击打开进行分频的设置 在帮助页面可以知道，GW1N 1 系列的 fpga 的 OSC 是从 240MHz 进行分频的，所以要产生 24MHz 的时钟，只需要进行 10 的分频 ## 屏幕驱动代码 **首先新建一个额外的verilog文件来保存下面要编写的代码** ### 端口定义 首先需要先定义出驱动屏幕所需要的端口 ```verilog module VGAMod ( input CLK, input nRST, input PixelClk, output LCD_DE, output LCD_HSYNC, output LCD_VSYNC, \toutput [4:0] LCD_B, \toutput [5:0] LCD_G, \toutput [4:0] LCD_R ); ``` 本例程使用RGB565作为驱动方式； ### 时序常量 接着定义出时序图上所要求的常量 ```verilog localparam V_BackPorch 16'd6; //0 or 45 localparam V_Pluse \t 16'd5; localparam HightPixel 16'd480; localparam V_FrontPorch 16'd62; //45 or 0 localparam H_BackPorch 16'd182; \t localparam H_Pluse \t 16'd1; localparam WidthPixel 16'd800; localparam H_FrontPorch 16'd210; localparam PixelForHS WidthPixel + H_BackPorch + H_FrontPorch; \t localparam LineForVS HightPixel + V_BackPorch + V_FrontPorch; ``` 首先是设置时序相关的参数：前沿、后沿、有效像素 关于显示前沿、后沿，前面也说了，可以合并为一个消影时间，就是可以把其中一个设置为0，另一个设置为消影时间。反正前后沿的时间加起来符合表中的时间要求就可以 ### 定义变量 定义一些变量能够容易编写程序 ```verilog reg [15:0] LineCount; reg [15:0] PixelCount; reg\t[9:0] Data_R; reg\t[9:0] Data_G; reg\t[9:0] Data_B; ``` ### 同步信号 这段代码产生同步信号，需要注意的是，这块屏幕的同步信号是负极性使能 ```verilog always @( posedge PixelClk or negedge nRST )begin if( !nRST ) begin LineCount < 16'b0; PixelCount < 16'b0; end else if( PixelCount PixelForHS ) begin PixelCount < 16'b0; LineCount < LineCount + 1'b1; end else if( LineCount LineForVS ) begin LineCount < 16'b0; PixelCount < 16'b0; end else PixelCount < PixelCount + 1'b1; end always @( posedge PixelClk or negedge nRST )begin if( !nRST ) begin \t\t\tData_R < 9'b0; \t\t\tData_G < 9'b0; \t\t\tData_B < 9'b0; end else begin \t\t\tend \tend //注意这里HSYNC和VSYNC负极性 assign LCD_HSYNC (( PixelCount > H_Pluse)&&( PixelCount < (PixelForHS H_FrontPorch))) ? 1'b0 : 1'b1; assign LCD_VSYNC ((( LineCount > V_Pluse )&&( LineCount < (LineForVS 0) )) ) ? 1'b0 : 1'b1; ``` ### 使能信号 这段代码设置 LCD 使能图像显示，这块屏幕需要控制一个管脚用作显示开关，实际这个信号就是传输图像有效的那 800*480 的数据时置 1 ```verilog assign LCD_DE ( ( PixelCount > H_BackPorch )&& ( PixelCount < PixelForHS H_FrontPorch ) && ( LineCount > V_BackPorch ) && ( LineCount < LineForVS V_FrontPorch 1 )) ? 1'b1 : 1'b0; //这里不减一，会抖动 ``` ### 测试彩条 这段代码用来产生 LCD 的测试数据，产生彩条显示 ```verilog localparam Colorbar_width WidthPixel / 16; assign LCD_R ( PixelCount < ( H_BackPorch + Colorbar_width * 0 )) ? 5'b00000 : ( PixelCount < ( H_BackPorch + Colorbar_width * 1 )) ? 5'b00001 : ( PixelCount < ( H_BackPorch + Colorbar_width * 2 )) ? 5'b00010 : ( PixelCount < ( H_BackPorch + Colorbar_width * 3 )) ? 5'b00100 : ( PixelCount < ( H_BackPorch + Colorbar_width * 4 )) ? 5'b01000 : ( PixelCount < ( H_BackPorch + Colorbar_width * 5 )) ? 5'b10000 : 5'b00000; assign LCD_G ( PixelCount < ( H_BackPorch + Colorbar_width * 6 )) ? 6'b000001: ( PixelCount < ( H_BackPorch + Colorbar_width * 7 )) ? 6'b000010: ( PixelCount < ( H_BackPorch + Colorbar_width * 8 )) ? 6'b000100: ( PixelCount < ( H_BackPorch + Colorbar_width * 9 )) ? 6'b001000: ( PixelCount < ( H_BackPorch + Colorbar_width * 10 )) ? 6'b010000: ( PixelCount < ( H_BackPorch + Colorbar_width * 11 )) ? 6'b100000: 6'b000000; assign LCD_B ( PixelCount < ( H_BackPorch + Colorbar_width * 12 )) ? 5'b00001 : ( PixelCount < ( H_BackPorch + Colorbar_width * 13 )) ? 5'b00010 : ( PixelCount < ( H_BackPorch + Colorbar_width * 14 )) ? 5'b00100 : ( PixelCount < ( H_BackPorch + Colorbar_width * 15 )) ? 5'b01000 : ( PixelCount < ( H_BackPorch + Colorbar_width * 16 )) ? 5'b10000 : 5'b00000; ``` **当然在最后的驱动文件最后别忘记换行加上 endmodule** 到这里驱动模块的编写已经完成了。 ## 在顶层模块中例化 **这里也是要新建verilog文件的** 新建文件之后直接把下面的内容复制进去保存即可 ```verilog module TOP //设置顶层模块 ( \tinput\t\t\tnRST, input XTAL_IN, \toutput\t\t\tLCD_CLK, \toutput\t\t\tLCD_HYNC, \toutput\t\t\tLCD_SYNC, \toutput\t\t\tLCD_DEN, \toutput\t[4:0]\tLCD_R, \toutput\t[5:0]\tLCD_G, \toutput\t[4:0]\tLCD_B ); // 列出需要的端口 \twire\t\tCLK_SYS;\t \twire\t\tCLK_PIX; //例化pll Gowin_rPLL chip_pll( .clkout(CLK_SYS), //output clkout //200M .clkoutd(CLK_PIX), //output clkoutd //33.00M .clkin(XTAL_IN) //input clkin );\t \tVGAMod\tVGAMod_inst //例化vga驱动 \t( \t\t.CLK\t\t(\tCLK_SYS ), \t\t.nRST\t\t(\tnRST\t\t), \t\t.PixelClk\t(\tCLK_PIX\t\t), \t\t.LCD_DE\t\t(\tLCD_DEN\t \t), \t\t.LCD_HSYNC\t(\tLCD_HYNC \t), \t.LCD_VSYNC\t(\tLCD_SYNC \t), \t\t.LCD_B\t\t(\tLCD_B\t\t), \t\t.LCD_G\t\t(\tLCD_G\t\t), \t\t.LCD_R\t\t(\tLCD_R\t\t) \t); \tassign\t\tLCD_CLK\t\t \tCLK_PIX; endmodule ``` ## 综合、约束、布局布线 ### 综合 完成上面步骤后转到“Process”界面下，对编辑好的代码进行综合，即运行“Synthesize” ![](./../../Tang Nano 9K/nano_9k/nano_9k_synthsize.png) 运行的结果如下图出现 ![](./../../Tang Nano/assets/LED.png) 说明前面编辑的代码无误；如果有错，根据错误提示进行改正即可。 ### 管脚约束 对应的管脚约束如下表格所示； 关于管脚约束方法可以参考[自建点灯文章(点我)](./led/self_create.html)里面的约束方法。 感觉麻烦的话也可以直接复制准备好的[文件(点我)](./lcd_constrains.html)，将页面里的内容复制到工程目录里 .cst 文件中（如果没有.cst 文件那么自己新建一个**物理管脚约束文件**） 即可。 PORT PIN PORT PIN PORT PIN : : : : : : : : : : : : LCD_CLK 11 nRST 14 XTAL_IN 35 LCD_B[4] 45 LCD_B[3] 44 LCD_B[2] 43 LCD_B[1] 42 LCD_B[0] 41 LCD_G[5] 40 LCD_G[4] 39 LCD_G[3] 38 LCD_G[2] 34 LCD_G[1] 33 LCD_G[0] 32 LCD_R[4] 31 LCD_R[3] 30 LCD_R[2] 29 LCD_R[1] 28 LCD_R[0] 27 LCD_DEN 5 LCD_SYNC 46 LCD_HYNC 10 ### 布局布线 管脚约束之后需要在设置里面开启引脚复用才能完成布局布线。 具体位置在 软件顶部菜单栏 Project > Configuration > Place&Route > Dual Purpose Pin ![](./led/assets/enable_io_mux.png) 设置完上面的之后。 就可以开始布局布线(Place&Route)了。 完成后就可以给开发板验证代码内容了。 ## 烧录 布局布线结束后生成比特流，就可以烧录开发板了。 ## 结束 上面差不多叙述了所有代码。 整个工程可以参考 [这里](https://github.com/sipeed/Tang Nano examples/tree/master/example_lcd) <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano/examples/lcd_constrains.html":{"title":"LCD constrain file content","content":" title: LCD constrain file content <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p> ```cst IO_LOC \"LCD_B[4]\" 45; IO_PORT \"LCD_B[4]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[3]\" 44; IO_PORT \"LCD_B[3]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[2]\" 43; IO_PORT \"LCD_B[2]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[1]\" 42; IO_PORT \"LCD_B[1]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[0]\" 41; IO_PORT \"LCD_B[0]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[5]\" 40; IO_PORT \"LCD_G[5]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[4]\" 39; IO_PORT \"LCD_G[4]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[3]\" 38; IO_PORT \"LCD_G[3]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[2]\" 34; IO_PORT \"LCD_G[2]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[1]\" 33; IO_PORT \"LCD_G[1]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[0]\" 32; IO_PORT \"LCD_G[0]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[4]\" 31; IO_PORT \"LCD_R[4]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[3]\" 30; IO_PORT \"LCD_R[3]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[2]\" 29; IO_PORT \"LCD_R[2]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[1]\" 28; IO_PORT \"LCD_R[1]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[0]\" 27; IO_PORT \"LCD_R[0]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_DEN\" 5; IO_PORT \"LCD_DEN\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_SYNC\" 46; IO_PORT \"LCD_SYNC\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_HYNC\" 10; IO_PORT \"LCD_HYNC\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_CLK\" 11; IO_PORT \"LCD_CLK\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"nRST\" 14; IO_PORT \"nRST\" IO_TYPE LVCMOS33 PULL_MODE UP; IO_LOC \"XTAL_IN\" 35; IO_PORT \"XTAL_IN\" IO_TYPE LVCMOS33 PULL_MODE UP; ``` <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano/Tang-nano.html":{"title":"Tang nano 一些例程","content":" title: Tang nano 一些例程 对于Programmer(下载程序)建议使用 https://dl.sipeed.com/shareURL/TANG/programmer 里面的文件。 下载后解压替换掉Gowin对应安装目录的Programmer文件夹即可。 不会替换的话可以在下载解压后的Programmer程序中手动添加对应下载文件来进行烧录。 ## 例程 [点灯例程](./examples/1_led.html) [驱屏教程](./examples/2_lcd.html)"},"/hardware/zh/tang/Tang-Nano/Nano.html":{"title":"Tang Nano","content":"# Tang Nano ## 概述 Tang Nano是基于高云半导体的小蜜蜂系列GW1N 1 FPGA设计的简约型开发板。开发板设计小巧精致，将芯片的所有资源都引出，板载Type C、USB JTAG、PSRAM、RGB接口(可接LCD屏、VGA等外设)等，并把所有IO资源引出，方便开发者拓展使用，非常适用于小型数字逻辑的设计和实验。 ![](/hardware/assets/Tang/Nano/Tang_Nano.jpg) ## 参数 Tang Nano开发板板载的GW1N 1 FPGA芯片功能非常强大，具有较丰富的逻辑资源，支持多种I/O电平标准，内嵌块状静态随机存储器、锁相环、Flash等资源，是一款具有非易失性的FPGA产品;另外，板载64Mbits PSRAM，为FPGA提供了丰富的存储资源。 ![Nano](/hardware/assets/Tang/Nano/Tang Nano 4.png) 项目 参数 核心 GW1N 1 FPGA 逻辑单元(LUT4) 1152 寄存器(FF) 864 Block SRAM(bits) 72K B SRAM块个数 4 用户闪存(bits) 96K 锁相环PLL 1 I/O Bank总数 4 最多用户I/O数 41 核电压 1.2V ![Nano Pin](/hardware/assets/Tang/Nano/Tang Nano Pin.png) ## 产品技术支持 Tang Nano开发板可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com> ## 资料 [相关例程](./../Tang Nano Doc/examples.html#板型) [资料下载](https://dl.sipeed.com/shareURL/TANG/Nano)"},"/hardware/zh/tang/Tang-Nano/start.html":{"title":"摄像头和HDIM屏幕显示","content":"# 摄像头和HDIM屏幕显示 具体工程[文件](https://github.com/sipeed/TangNano 4K example) 接好摄像头和HDMI显示器之后，将这个工程烧录到开发板上即可使用了。"},"/hardware/zh/tang/Tang-Nano/user.html":{"title":"一些例程","content":"# 一些例程 ## 点灯LED 1. 新建工程：File >NEW >FPGA Dsign Project >OK ![](./assets/LED 1.png) 2. 弹出的选项框选择存储路径和工程名称（路径和文件名称要求是英文路径） ![](./assets/LED 2.png) 3. 选择合适的型号： ![](./assets/LED 3.png)![](./assets/LED 4.png) 4. 新建好工程之后接下来进行代码编辑，在Design工作栏内新建“Verilog File”,如下图所示： ![](./assets/LED 5.png) 5. 为文件命名（要求写英文名，不然后续综合很容易报错） ![](./assets/LED 6.png)![](./assets/LED 7.png) 6. 双击文件，可以在右侧的编辑框中进行代码的编写。以编辑流水灯为例，将下方的“LED例程代码”粘贴到自己的文件中，也可以自己编写自己的代码，例程代码地址：<https://github.com/sipeed/TangNano 1K examples> ```v module led ( input sys_clk, input sys_rst_n, output reg [2:0] led // 110 R, 101 B, 011 G ); reg [31:0] counter; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin counter < 31'd0; led < 3'b110; end else if (counter < 31'd1350_0000) // 0.5s delay counter < counter + 1'b1; else begin counter < 31'd0; led[2:0] < {led[1:0],led[2]}; end end Endmodule ``` 7. 代码编辑结束后转到“Process”界面下，对编辑好的代码进行综合，即运行“Synthesize” ![](./assets/LED 8.png) 运行的结果如上图出现 ![](./assets/LED.png) 的形状，且下方结果栏不出现任何从报错，说明前面编辑的代码无误，如果有错，根据错误提示进行改正即可。 8. 接下来通过 打开“FloorPlanner”实现管脚约束（前面的综合如果运行失败，这一步无法进行），第一次打开会弹出缺少.cst文件： ![](./assets/LED 9.png) 选择“OK”即可； 初始界面如图：![](./assets/LED 10.png)![](./assets/LED 11.png) 9. 将界面转到“Package View”界面，点击下方“I/O Constraints”编辑引脚数据，如下图所示： ![](./assets/LED 12.png)![](./assets/LED 13.png) 引脚情况： ![](./assets/LED 14.png) 引脚分布情况： PORT I/O PIN DESE SYS_CLK INPUT 47 47 SYS RST N INPUT 13 LED[0] OUTPUT 9 LED[1] OUTPUT 10 LED[2] OUTPUT 11 10.将界面转到“Package View”界面，点击下方“I/O Constraints”编辑引脚数据，如下图所示： ![](./assets/LED 15.png) 11.到“Process”下运行“Place&Route”，即运行管脚布局布线，运行结果如下图所示： ![](./assets/LED 16.png) 12.接下来是进行连接板子，烧录固件，可参照下图选择版型： ![](./assets/LED 17.png) 13.以烧录进SRAM为例进行说明，如下图： ![](./assets/LED 18.png)![](./assets/LED 19.png) 最后运行： ![](./assets/LED 20.png) 14、结果显示： 【此处放置LED闪烁动图】 15、解说烧录到FLASH中的方式： ![](./assets/LED 21.png)![](./assets/LED 22.png) 点灯步骤到此结束。 > 说明： > 01、只测试过下载站下班的版本以及1.9.8版本测试正常，其他版本需用户自行确认。 > 02、不要使用中文路径 >错误：![](./assets/LED 23.png) ## 驱屏教程 例程代码地址：<https://github.com/sipeed/TangNano 1K examples> ![](./assets/pin 1.png)![](./assets/pin 2.png)![](./assets/pin 3.png) 引脚分布情况： PORT I/O PIN DESE KEY INPUT 13 47 LCD_B[0] INPUT 19 LCD_B[1] OUTPUT 20 LCD_B[2] OUTPUT 22 LCD_B[3] OUTPUT 23 LCD_B[4] OUTPUT 24 LCD_CLK OUTPUT 8 LCD_DEN OUTPUT 21 LCD_G[0] OUTPUT 28 LCD_G[1] OUTPUT 27 LCD_G[2] OUTPUT 15 LCD_G[3] OUTPUT 16 LCD_G[4] OUTPUT 17 LCD_G[5] OUTPUT 18 LCD_HYNC OUTPUT 33 LCD_R[0] OUTPUT 15 LCD_R[2] OUTPUT 34 LCD_R[3] OUTPUT 31 LCD_R[4] OUTPUT 30 LCD_R[4] OUTPUT 29 LCD_SYNC OUTPUT 32 LED_B OUTPUT 10 LED_G OUTPUT 11 LED_R OUTPUT 9 XTAL_IN INPUT 47 nRST INPUT 44 详细代码和工程建立步骤请参照LED点灯例程。"},"/hardware/zh/tang/Tang-Nano-9K/examples/picorv.html":{"title":"Tang Nano 9K picoRV 简单示例","content":" title: Tang Nano 9K picoRV 简单示例 > 编辑于2022年3月28日 ## 前言 在Tang Nano 9K [例程仓库](https://github.com/sipeed/TangNano 9K example/tree/main/picotiny)里面有一个picoRV的例程。 本篇文章仅简单叙述如何使用例程，无其他内容。 ## 相关环境 Python Gowin IDE ## 相关步骤 ### 烧录Bitstream 打开 TangNano 9K example\\picotiny\\project 目录下的 picotiny.gprj 文件 在顶部菜单栏 Project >Configuration >Place&Route >Dual Purpose Pin 里面勾选 Use MSPI as regular IO 在 IDE 的 Process 窗口右键 Place&Route 选择 Clean＆Rerun All 将生成的文件下载到 Nano 9K 的 Embedded Flash 完成上面步骤后我们已经成功将PicoRV固化到FPGA里面了 ### 烧录例程文件 在 TangNano 9K example\\picotiny 目录下执行 ```python python .\\sw\\pico programmer.py .\\example fw flash.v COM13 ``` 上面命令行中最后的 COM13 指的是开发板在系统中的串口编号， 比如在系统中显示为COM14的话就需要将它改成对应的COM14。 成功执行上面命令后会出现 ` Waiting for reset ` 的计时， 这时候按下开发板的S1按键就可以完成烧录。 附带完成的烧录log： ```powershell \\TangNano 9K example\\picotiny> python .\\sw\\pico programmer.py .\\example fw flash.v COM13 Read program with 11760 bytes Waiting for reset ... Total sectors 3 Total pages 46 Flashing 1 / 3 Flashing 2 / 3 Flashing 3 / 3 Flashing completed ``` 然后就可以使用在串口工具来执行我们的代码了，当然也可以用HDMI来显示代码界面 ![](./../nano_9k/picorv.jpg) ## 其他事项 本文仅提供一种运行方法，无其他作用 交叉编译等高阶玩法自己参考项目目录的makefile修改，无其他支持 <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano-9K/examples/spi_lcd/spi_lcd.html":{"title":"Spi lcd","content":" title: Spi lcd keywords: Tang Nano 9K, spi, lcd update: date: 2022 10 25 version: v0.1 author: wonder content: 内容编写 ## 前言 Tang Nano 9K 板卡上有一个 8P 的 spi lcd 连接器，可以用来去驱动配套的 spi lcd 屏幕。 <img src \"./../nano_9k/spi_lcd.jpg\" alt \"spi_lcd\" width 48%> 配套 SPI 屏幕可以在淘宝店询问客服购买：[点我跳转到淘宝页面](https://sipeed.taobao.com/) ## 分析 SPI 屏幕的数据手册在这里：[点我跳转到下载页面](https://dl.sipeed.com/shareURL/TANG/Nano%209K/6_Chip_Manual/CN/LCD_Datasheet) 从数据手册中可以看到以下信息： NO. Item Contents Unit 1 LCD Size 1.14 inch 2 Display Mode Normally black 3 Resolution 135(H)RGB x240(V) pixels 4 Pixel pitch 0.1101(H) x 0.1038(V) mm 5 Active area 14.864(H) x 24.912(V) mm 6 Module size 17.6(H) x 31.0(V) x1.6 (D) mm 7 Pixel arrangement RGB Vertical stripe 8 Interface 4 Line SPI 9 Display Colors 262K colors 10 Drive IC ST7789V3 11 Luminance(cd/m2) 400 (TYP) Cd/m2 12 Viewing Direction All View Best image 13 Backlight 1 White LED 14 Operating Temp. 20℃~ + 70℃ ℃ 15 Storage Temp. 30℃~ + 80℃ ℃ 16 Weight 1.8 g 在里面我们主要需要知道以下信息： 分辨率 (Resolution)：135(H)RGB x240(V) 接口 (Interface)：4 Line SPI 驱动 (Drive IC)：ST7789V3 [点我下载相关数据手册](https://dl.sipeed.com/fileList/MAIX/HDK/Chip_DS/ST7789V3_SPEC_Preliminary_V0.0_200102.pdf) 感谢群友提供的代码，前往 https://github.com/sipeed/TangNano 9K example/tree/main/spi_lcd 查看详情，相关说明会在整理之后展示。 ![spi_lcd](./../nano_9k/spi_lcd.jpg)"},"/hardware/zh/tang/Tang-Nano-9K/examples/lushaylabs/8_sharing_resources/sharing_resources.html":{"title":"","content":""},"/hardware/zh/tang/Tang-Nano-9K/examples/lushaylabs/1_installation_getting_started/installation_getting_started.html":{"title":"Tang Nano 9K 安装上手","content":" title: Tang Nano 9K 安装上手 keywords: FPGA, Tang, Nano, 9K update: date: 2023 02 13 version: v0.1 author: wonder content: 新建文档 原文链接：[https://learn.lushaylabs.com/tang nano series/](https://learn.lushaylabs.com/getting setup with the tang nano 9k/) In this article we will be going over how to get started developing for the Tang Nano FPGA using a fully open source toolchain. We will start with an overview of FPGAs and the toolchain required to develop them, we will then go through setting up your development environment and finish off with a simple example so we can test and verify that everything is working. ## What's an FPGA ? An FPGA is a type of IC that you \"program\" with digital hardware circuits as apposed to microcontrollers or CPUs that you program with software. A CPU has a fixed internal architecture and only understands how to process its own machine codes / assembly language. Developers then compile programming languages into these machine codes and the CPU will run them as it goes through the code. With FPGAs the internal architecture is a blank canvas, you can choose to create a CPU type architecture and design your own assembly language if you like there are even open source architectures like RISC V but you can also decide to custom build your own application specific circuit (ASIC) developing your application in hardware instead of software. A general purpose CPU is convenient in the sense that one design can be used to perform a lot of different tasks its general purpose but the downside is its not very efficient for any specific task. Take for example a single core 2 ghz CPU, even though the clock pulses 2 billion times per second it doesn't mean you can actually do 2 billion things in your application. Each line of code will get converted to many assembly instructions, each of which will be handled serially one at a time and each can take multiple clock cycles. Modern CPUs try to pipeline or parallelize these multiple clock cycles but for the most part you have a lot of overhead. Add on top of that you usually have other things that are running like an operating system which also are scheduled and take clock cycles. On the other hand with FPGAs you are programming your application in hardware, you can react to every clock pulse directly. There is no central processing unit, each part of the application can be handled in parallel, so not only do you actually get the full clock speed, but you get the effect of having as many parallel cores as needed. This also means that with a microcontroller for example, each extra operation that you would like to add to your application will negatively effect all the current operations since they are all fighting for the same resources. In an FPGA unless you specifically want it to block adding new cores / applications to your FPGA has no effect on the existing cores as they are completely separate hardware. So how does it work ? How can an FPGA dynamically reprogram its internal hardware ? At its core an FPGA is made up of lookup tables, flip flops and multiplexers. A lookup table can be thought of as a reconfigurable logic gate, its a prebuilt table where for each set of inputs there is a predefined output. For example a lookup table for an AND gate would look something like this: AND Gate: <table> <tbody> <tr> <th>Input 1</th> <th>Input 2</th> <th>Output</th> </tr> <tr> <td>0</td> <td>0</td> <td>0</td> </tr> <tr> <td>1</td> <td>0</td> <td>0</td> </tr> <tr> <td>0</td> <td>1</td> <td>0</td> </tr> <tr> <td>1</td> <td>1</td> <td>1</td> </tr> </tbody> </table> Usually the lookup tables (LUTs) in an FPGA have more inputs and outputs so they are a bit bigger, but by being able to reprogram these tables you can change the AND gate into an OR gate as follows: OR gate: <table> <tbody><tr> <th>Input 1</th> <th>Input 2</th> <th>Output</th> </tr> <tr> <td>0</td> <td>0</td> <td>0</td> </tr> <tr> <td>1</td> <td>0</td> <td>1</td> </tr> <tr> <td>0</td> <td>1</td> <td>1</td> </tr> <tr> <td>1</td> <td>1</td> <td>1</td> </tr> </tbody> </table> So as you can see in this example by just changing two of the outputs you \"changed\" the internal hardware from an AND gate to an OR gate. Combine these reprogrammable gates with flip flops which allow for storing data and multiplexers which allow for routing connections and you have a method of dynamically \"programming\" the internal electrical circuit. This is a bit of a simplified view, usually FPGAs also come with built in memory/ram, DSPs or even dedicated math functions but at a high level I think the parts that LUTs, flip flops and multiplexers are the core. ## Tang Nano 9K In this series we will be focusing on the Tang Nano 9K FPGA development board (<a href \"https://item.taobao.com/item.htm?id 666055424174\">available in our store</a>) which includes an FPGA from Gowin's LittleBee family the GW1NR 9. This board IMHO currently provides the best bang for your buck both in terms of the FPGA itself number of LUTs / Flip flops / ram and also the development board exposes a good number of IOs and has on board LEDs, buttons and a built in UART debugger and other peripherals. The open source toolchain support is also very good supporting all the features we will be using. Open source toolchain Supported Features by FPGA family： ![supported_features](./assets/supported_features.jpg) For all these reasons, and because of its relatively low price the tang nano 9K has been chosen for this series. ## The Programming Process The process of programming your own core onto an FPGA goes through 3 stages: <ol><li>Synthesis</li><li>Place and Route</li><li>Bitstream Generation</li></ol> ### Synthesis The first step is to take a design written in an HDL (Hardware description language) like Verilog and convert it into primitives which make up the FPGA. In verilog you write your program in terms of modules with registers / connections and logic gates you also have abstractions like conditional statements or math operations. The job of the synthesis tool is to take all this and convert it to primitives like LUTs and flip flops. ### Place and Route Once you have a list of connections and FPGA primitives from the synthesis stage the next step like the name suggests is to map each of the primitives to their physical counterpart. Like to map each of the generated look up tables to one of the physical 8640 internal luts. This step must take into account all the routing requirements when selecting where to place each component, the output of this stage is similar to the output of the synthesis stage, except each of the components are physically mapped. ### Bitstream Generation The third and final step is generating the bits required so that the FPGA itself understands the layout the the place and route stage generated. Each FPGA manufacturer has their own internal format which open source toolchains need to reverse engineer in order to understand the exact format required to program the FPGA. After running these three stages you will have a file which can be programmed onto the FPGA which will reconfigure the internal hardware to match your design ## The Open Source Toolchain The open source toolchain is a collection of open source tools for each of the steps mentioned in the previous section. We have Yosys for synthesis, NextPnR for placing and routing and Apicula which reverse engineered the Gowin architecture and provides the bitstream generation tools. We will also be using openFPGALoader for programming the final bitstream onto the FPGA. We recommend setting up the toolchain with OSS CAD Suite and our VS code extension. OSS CAD Suite is a project maintained by the yosys team which provides pre built binaries for MacOSX, Windows and Linux. Our extensions is a wrapper around these pre built binaries allowing you to visually configure and run the OS toolchain. > If you would prefer to install and use the toolchain manually we have the instructions for that <a href \"https://learn.lushaylabs.com/os toolchain manual installation/\">here</a>. The first step to get this setup is to download and install Visual Studio Code: ### VSCode This is a popular lightweight cross platform editor with many plugins some of which specifically for FPGA development. The editor itself can be downloaded from <a href \"https://code.visualstudio.com/\">here</a>. Once installed, you can open it up and go to the Extensions tab to install plugins. To install our plugin you can search for \"Lushay Code\" or by going to the following <a href \"https://marketplace.visualstudio.com/items?itemName lushay labs.lushay code&amp;ssr false\">link</a>. Besides for that we also recommend these two plugins, although not mandatory we find these useful. 1. <a href \"https://marketplace.visualstudio.com/items?itemName mshr h.VerilogHDL\">Verilog HDL/SystemVerilog </a> provides syntax highlighting support for Verilog 2. <a href \"https://marketplace.visualstudio.com/items?itemName wavetrace.wavetrace\">WaveTrace</a> provides built in waveform viewing which can be used for debugging. With VsCode and the 3 extensions installed the next thing we need is OSS Cad Suite, you can find the latest version download from <a href \"https://github.com/YosysHQ/oss cad suite build/releases\">here</a>. On the release page there are several different versions depending on your OS and CPU architecture. For OS, linux and windows are just called windows and linux, and for MacOSX you need the darwin version. Next you have the architecture, usually either arm or x64, arm is for apple silicon or an arm based linux, x64 is for a standard intel / amd cpus. Download the file for your OS and then extract it somewhere you should now have a folder called `oss cad suite` on your computer. Place this folder wherever you want to keep the toolchain. It is worth noting on windows you don't download a zip but rather a self extracting executable, but it is the same, you just double click it to extract it as a folder called `oss cad suite`. With the folder ready open up VSCode and click on the button on the bottom right hand side called \"FPGA Toolchain\": ![fpga_toolchain_button](./assets/fpga_toolchain_button.jpg) You should receive a popup that says the OSS CAD Suite path is not setup, click on the \"Setup Now\" button and a file browser will appear, you need to select the OSS CAD Suite folder we just extracted you should select the actual folder called `oss cad suite` (the one with the `bin` folder inside). Once selected you have successfully setup the toolchain. ### Ubuntu USB Permission Fix On Ubuntu you will need to give permissions to you user so that we can run openFPGALoader without being root. To do this you need to run the following from a terminal: ```bash curl sSL https://raw.githubusercontent.com/lushaylabs/openfpgaloader ubuntufix/main/setup.sh sh` ``` And then once completed you will need to log out and log back in so that the user permissions take effect and you will need to unplug and replug in the tang nano board. ### Windows USB Driver Fix On windows the default driver does not work with `openFPGALoader` so to get it to work we need to replace the default driver. To do this you need a program called Zadig which can be downloaded <a href \"https://zadig.akeo.ie/\">here</a>. Download the tool and then open it up, once open you need to select \"Options\" &gt; \"List All Devices\" from the top menu to show all connected usb devices. Next in the dropdown you should see two devices: 1. JTAG Debugger (Interface 0) 2. JTAG Debugger (Interface 1) Interface 0 is the JTAG interface `openFPGALoader` needs to program the Tang Nano while Interface 1 is the serial interface used for the UART communication. It is important to leave interface 1 as is and only replace interface 0 here. So select \"JTAG Debugger (Interface 0)\" and underneath you should see it show that it will change the driver to \"WinUSB\" if WinUSB is not selected you can use the up/down arrows to select it. Once selected just the replace driver button and wait a minute or two, once done it should work in openFPGALoader. If you ever want to uninstall this driver and go back to the default driver (for example to use the official gowin IDE) all you have to do is go to \"Device Manager\" select the device called \"JTAG Debugger\" under \"Universal Serial Bus devices\" right click on it and press \"uninstall device\" from the popup also select the checkbox to attempt to remove the driver. Once removed right click on any item in the device manager window and press \"Scan for hardware changes\" this should reconnect the device back with the original driver. ## Other Recommended Software Besides for the toolchain itself there is some other software which can aid in the development of FPGA cores, and will be used throughout this series. ### Node.js During the course of development you may find yourself needing to prepare / convert data or even communicate with the FPGA from your computer. Node.js is just my personal preference and is what I will be using in this series, but any programming language will probably have a way to do the same things if you have a different preference. To install node.js you can either grab the official installer from the <a href \"https://nodejs.org/en/\">node.js site</a> or install using a node version manager like so: **Mac / Ubuntu / Windows WSL** ```bash curl o https://raw.githubusercontent.com/nvm sh/nvm/v0.39.1/install.sh bash nvm install v17.0.1 nvm use v17.0.1 nvm alias default v17.0.1` ``` ### Tabby Tabby is a cross platform terminal which has support for serial terminal which will allow us to communicate over UART with the tangnano9k. Here as well it is a matter of personal preference, I chose to mention tabby since it supports all operating systems and has some extra features like choosing how the data will be read / shown (ascii, hex) and each side can be configured independently. Tabby can be downloaded <a href \"https://tabby.sh/\">here</a> If you only need basic serial support, the Lushay Code extension comes with a basic built in serial console. But I still recommend Tabby since the extra features can be nice. ## Creating a New Project We should now have everything we need to effectively develop an FPGA core. To get started open up your editor (VSCode), from the explorer tab you will have a button to open a folder, click it to choose a new directory that we can use for this project. Once inside you should see your folder in the explorer tab and we can now create some files. Every FPGA project needs at least two files: 1. A file that describes your circuit (in our case a verilog `.v` file) 2. A file that describes the connection between your circuit and your physical board. (in our case a physical constraints `.cst` file) Verilog is an HDL language which is what get's synthesized. Inside the code you will usually want to use specific pins from the actual FPGA, to do this in verilog you create a name for the pin (it can be whatever you want), and then in the `.cst` file you define the mapping of pin name to pin along with other configuration for the pin. So let's start with a simple example which display a binary counter using the on board LEDs. Now onboard we have 6 leds and if each will represent one bit in our counter then it means we can count up from 0 to 63 (binary `111111`). Now our onboard clock frequency is 27 Mhz so counting up every clock pulse would mean the counter would cycle through all the options 428 million times a second, t0o fast to be able to see the counting. So let's say we want it to count once every half a second. Then we would need to wait 13,500,000 clock cycles between incrementing the counter. We can also say that our counting module will require the clock signal on board as input since we will need it to react to clock cycles and we know we want our output to be the status of the 6 leds. So now that we have a general plan, let's create a verilog file called `counter.v` and we can start off with what we know. ```v module top ( input clk, output [5:0] led ); localparam WAIT_TIME 13500000; reg [5:0] ledCounter 0; endmodule ``` This code defines a new module called top with an input called `clk` for the clock signal and 6 outputs called `led`. Again the names here for the inputs and outputs will be mapped to actual pins in the `.cst` file later, so the names can be anything you like. The format for defining an array's size or accessing a group of bits in general is `[MSB:LSB]` which is why 6 bits can be represented as `[5:0]` meaning bit 5 is the most significant bit and bit 0 is the least significant bit, totaling 6 bits. The next line defines a local constant which will be used at compile time, we have already calculated that we will need 13.5 million clock cycles per counter increment in order to reach the desired half second delay. The final line is our actual counter again using the same notation with the `[5:0]` to say it will be a 6 bit wide register. We will also need a counter for the clock cycles. Looking at the binary representation of 13,500,000 we see it needs 24 bits to contain so we can create a counter with the signature `[23:0]` for 24 bits. ```v reg [23:0] clockCounter 0; ``` The next thing we need to do is increment our counters on every clock pulse. This can be done with an `always` block: ```v always @(posedge clk) begin clockCounter < clockCounter + 1; if (clockCounter WAIT_TIME) begin clockCounter < 0; ledCounter < ledCounter + 1; end end ``` The always block starts with it's trigger list or sensitivity list. Essentially what needs to happen for the circuit defined inside to occur. In our case we are saying whenever there is a positive edge on the clock pin (a.k.a clock rise) we want the following to happen. First we will increment the clock counter and then check if we have reached the wait time defined above. If we have reached the wait time then we would like to reset the clock counter to zero and increment the led counter. We don't need to deal with ever resetting the led counter as it has exactly the number of bits as the desired counter so it will automatically roll over back to 0 once it increments 63. It is also worth noting that the `&lt; ` operator is not like a standard assignment operator from most programming languages. This operator sets the value for the input of the flip flop which will only propagate to the output on the next clock signal. This means that even though we increment it on the first line of the block, the value of `clockCounter` will only equal 1 on the next clock pulse, and for the remainder of the current block the value will still be 0. Same thing when we increment the ledCounter, The change will only be seen on the next clock signal. There is a way to immediately assign a value using the blocking ` ` operator instead, but I like to stick only with the non blocking assignment operator `&lt; ` when working with registers, both for simplicity, consistency and I think it is a better practice. The last and final thing to finish our verilog module is to connect the value of our register to the leds. ```v assign led ledCounter; ``` Outside the always block we use the `assign` and ` ` to define the value of wires. Wires (which is the default input/output type) unlike registers don't store values so we need to simply define what they are connected to and they will always equal that value (since they will be physically connected to them). The final code should look like the following: ```v module top ( input clk, output [5:0] led ); localparam WAIT_TIME 13500000; reg [5:0] ledCounter 0; reg [23:0] clockCounter 0; always @(posedge clk) begin clockCounter < clockCounter + 1; if (clockCounter WAIT_TIME) begin clockCounter < 0; ledCounter < ledCounter + 1; end end assign led ledCounter; endmodule ``` The next file we need to create is the `.cst` file where we will need to define the I/Os we used `clk` and `led`. First we will take a look at doing it manually so you can get a sense for how it works under the hood, and then we will take a look at doing it through our VScode extension. To do this manually we need to know some information about the pins. First of all we need to know the pin number. For the GPIO of the board its pretty easy, all the pins are listed in the following image: ![tang_nano_registers](./assets/tang_nano_registers.jpg) So for example the top left pin's number is 38 (IOB31B) and the top right pin (IOR5A) is pin 63, and so on. It's worth noting also that most GPIO are 3.3V but to pay attention that all the BANK3 pins (pin 79 86) are 1.8V pins and should only be used with devices or sources working with 1.8v. But with all that said, in our example we are not using any of the GPIO pins we are using pins of the FPGA which are routed to on board components (the clock and LEDs). Tang Nano 9K Schematic: [Click me](https://dl.sipeed.com/shareURL/TANG/Nano%209K/2_Schematic) Opening up the file we can see a section called \"LED x 6\" defining how the 6 LEDs are connected. ![led_pins](./assets/led_pins.jpg) A side note something thing that can be seen here is that the LEDs are common anode all being supplied power directly from the 1.8 voltage source which means we need to pull our pin down to low (0) in order for the led to light up. But back to what we are looking for. We see the names defined to the connections and then we can see where these references end up on the actual FPGA chip. Above this section we have the FPGA chip itself and we can see they end up as part of bank 3's pins: ![led_pinout](./assets/led_pinout.jpg) More specifically we can see they are pins 10,11,13,14,15,16. Using the same process we can find the clock pin in the xtal (crystal oscillator) section. ![xtal_pinout](./assets/xtal_pinout.jpg) Showing that the pin is pin 52. With that mini investigation complete we would need to create a cst file where we would define the pins like so: ```v IO_LOC \"clk\" 52; IO_PORT \"clk\" PULL_MODE UP; IO_LOC \"led[0]\" 10; IO_LOC \"led[1]\" 11; IO_LOC \"led[2]\" 13; IO_LOC \"led[3]\" 14; IO_LOC \"led[4]\" 15; IO_LOC \"led[5]\" 16; ``` IO_LOC defines a location constraint, meaning we are defining that when placing and routing our design the io called clk must be placed on a specific pin defining its specific location. IO_PORT defines port level constraints like pull ups / pull downs, logic types drive strength etc. Going through our file we define `clk` to be pin 52 with a pull up resistor, and we are defining the 6 bits of our `led` output using the pin numbers we found. It's worth noting we are adding the bit index to them only for convenience so that we can receive them all together instead of 6 separate outputs in verilog. But if we wanted we could have written `IO_LOC \"led1\" 10;` and then in verilog have each LED as a separate output. You can view a little bit more information about this format from the official physical constraints document from Gowin Appendix A. [Gowin Appendix A](http://cdn.gowinsemi.com.cn/UG289.pdf) Or more in depth by searching for the system IO and GPIO specification documents if you would like a more in depth read. To some extent you can also view some of the options in the apicula longvals documentation <a href \"https://github.com/YosysHQ/apicula/blob/master/doc/longval tables.md\">here</a>. ### Constraints with LushayCode With the extension simply create a new file in vscode for example `tangnano9k.cst` and clicking on it you should see something like the following: ![constraints_front](./assets/constraints_front.jpg) Since both the LEDs and the clock are part of the development board they have an included template, so we can simply press \"Add From Template\" and select both the clock and leds. ![selecting_clock](./assets/selecting_clock.jpg) Clicking on \"Add Constraints\" will add them to the current file and you will see them in the table: ![constraints_filled](./assets/constraints_filled.jpg) Just save the file and we are done with the constraints. You can see that the pin numbers are the same as we saw when doing the manual investigation. ## Running the Example Our project is now ready so how do we compile it with the toolchain. To do this you can click again on the \"FPGA Toolchain\" button from our VSCode extension and you should get a dropdown with the different options: ![options_toolchain](./assets/options_toolchain.jpg) Select \"Build and Program\" and if all went well you should now see the tangnano counting up over it's LEDs. ![tangnano_counter](./assets/tangnano_counter.jpg) The only thing is that the counter is inverted. This is due to the fact that the LEDs use a common anode and a value of 0 means to light up not a value of 1. To fix this we can make a small change to our code. To update the verilog code in our example invert the counter so that the leds match the bit status using the `~` operator. The final line of our module should be: ```v assign led ~ledCounter; ``` Re click on \"Build and Program\" from the \"FPGA Toolchain\" button to rebuild and program the FPGA with our fix. ## Conclusion In this article we went through a lot of different topics getting the development environment setup and running a basic example. In the next part of this series we will go more in depth on debugging FPGA projects in order to visually see what's going on internally. All the code from the example is also available on in lushaylabs github repo <a href \"https://github.com/lushaylabs/tangnano9k series examples\">here</a>. And if you have any questions or comments feel free to leave them below or contact me on twitter <a href \"https://twitter.com/LushayLabs\">@LushayLabs</a>."},"/hardware/zh/tang/Tang-Nano-9K/examples/lushaylabs/4_creating_a_text_engine/creating_a_text_engine.html":{"title":"Tang Nano 9K SSD1306 OLED 显示字符","content":" title: Tang Nano 9K SSD1306 OLED 显示字符 keywords: FPGA, Tang, Nano, 9K update: date: 2023 03 15 version: v0.1 author: wonder content: 新建文档 [原文链接](https://learn.lushaylabs.com/tang nano 9k creating a text engine/) In the previous article ([here](./../3_oled_101/oled_101.html)) we developed a screen driver core which allows us to render pixels onto an OLED screen. In this article we will be building a text engine on top of our pixel driver to give us an easy abstraction for rendering text to pixels. ## Drawing Text In order to draw text we need two things: 1. a way to map characters to screen pixel positions 2. some conversion between letters and pixels or how the letters look. For mapping characters to the screen we can decide on any arbitrary mapping, our OLED panel is 64 pixels tall and we store data in 8 bit vertical bytes so to make things easy we can say we have 8 rows to work with. Going smaller than this means that a single byte update to the screen may contain multiple rows of text which would complicate the design a bit. Even 8 rows would make the text pretty small, so for our example let's divide the screen into 4 rows of text this would mean that each character could be up to 16 pixels tall. As for the width of each character we have a total of 128 pixels so if we make each character 8 bits wide we can store a maximum of 16 characters per row. ![characters](./assets/characters.jpg) So now with the mapping decided on, if we wanted to put the letter D in the 4th character position on the first row we know the top row of the character is 8px * 4th character maps to pixel columns 31 39 and the bottom row is pixel columns 159 167 (add 128 since we need to go down one full line). Each character will be drawn in two OLED pixel rows where in each row we update 8 of the 16 vertical pixels in a column. We now know which columns to put the letter D in now but what is the actual column of pixels we would like to send to draw the letter D. We need to decide on how the characters look to know how which pixels need to light up. ## Designing the Letters A computer knows how to render letters by using font files. Fonts can either be vector fonts where the contents describe vectors to recreate the letter's shape at any size, or they can be bitmap fonts (pixel fonts) where we store a pixel representation of each character at a specific size / sizes. To keep things simple let's use the bitmap option so we don't have to calculate vectors, also we are designing for a specific OLED panel with a specific resolution so we don't need the scalability. Kind of like in the previous example where we drew an image to the screen by storing its pixels into memory here we need to store the pixels for each character into memory. The difference between the two examples is that over there our memory represented the actual screen and stored each individual pixel exactly where it should show up on the screen, we were storing an image. In the case of our font, we are storing the pixels for each character unconnected to the screen dimensions and positioning, and then the mapping logic we discussed above will be in charge of mapping it to the screen. By having this mapping disconnected we are able to dynamically decide what text to draw to the screen and for example reuse the same letter multiple times. Luckily we don't need to create these fonts ourselves and pixel font tools like <a href \"https://www.pentacom.jp/pentacom/bitfontmaker2/editfont.php?id 4677&amp;ref lushay labs\">bitfontmaker2</a> have galleries of fonts created by talented designers and artists. We will be using the amazing <a href \"https://datagoblin.itch.io/monogram?ref lushay labs\">monogram font</a> which is created by <a href \"https://twitter.com/vmenezio?ref lushay labs\">Vinícius Menézio (Twitter)</a> and made free to use by him. **monogram in bitfontmaker2:** ![bitfontmaker2](./assets/bitfontmaker2.jpg) If you choose another font while following along just make sure it fits into our constrains of 16 px height and 8px width, otherwise you will need to adjust our mapping logic. Exporting a font from bitfontmaker will provide a JSON file where for each ascii code we have an array of numbers. Each number represents a horizontal row of pixels, LSB is the left hand side of the image and starting from the top going down. So for example the bottom of this letter \"A\" from the image above would be 68 since it is 1000100 in binary again where the LSB (right most bit) is the left most pixel. ## Converting the Font We have a font JSON file, but the format is not very convenient for us to use as is. These font files store horizontal rows and we need to send the OLED vertical columns. We can create a small node.js script to remap each horizontal row into 8 vertical columns where we store 2 bytes per column giving us the full 16 pixels. ```javascript const fs require('fs'); const bitmaps fs.readFileSync('./fonts/monogram.json'); const json JSON.parse(bitmaps.toString()); const memory []; for (var i 32; i < 126; i + 1) { const key i.toString() const horizontalBytes json[key]; const verticalBytes []; for (let x 0; x < 8; x + 1) { let b1 0; let b2 0; for (let y 0; y < 8; y + 1) { if (!horizontalBytes) { continue; } const num1 horizontalBytes[y]; const num2 horizontalBytes[y+8] 0; const bit (1 << x); if ((num1 & bit) ! 0) { b1 b1 (1 << y); } if ((num2 & bit) ! 0) { b2 b2 (1 << y); } } memory.push(b1.toString(16).padStart(2, '0')); memory.push(b2.toString(16).padStart(2, '0')); } } fs.writeFileSync('font.hex', memory.join(' ')); ``` We start off by loading the JSON font file and parsing it into a javascript object. We then loop over all the characters codes we want to include, which looking at an ascii table we can see that 32 126 is all the standard visible characters including space. ![ascii_table_orig](./assets/ascii_table_orig.jpg) Inside the outer loop which is iterating over characters, we have a for loop to go over each of the 8 columns, and then a for loop for each column to calculate the two vertical bytes. Inside we focus on a specific bit and go over each horizontal row to build up the vertical column. For example we focus on the 3rd bit in each horizontal row which all together form the vertical bytes for the 3rd column. ![rows_to_columns](./assets/rows_to_columns.jpg) If each of the red boxes is the horizontal rows then the blue box is an example of the top byte for column index 2 and the green box is the second vertical byte for column index 2. After going through all the rows and completing a single column we store the 2 bytes and move onto the next vertical column again going through each of the rows just on the next bit to the right. We already store the bytes in the `memory` array in hex format so the last line simply needs to save it all to a file, in our example called `font.hex`. ## Designing the Text Engine Before we start getting into the actual verilog module, let's go over the general plan for how we can implement this. In the previous article we had a `pixelCounter` register which would go through each of the bytes we needed to update on the screen, and this would act as the address in memory to lookup the relevant byte from our image. There is nothing memory specific though about the implementation. At a high level you can think of it as the screen driver asking for a specific byte by setting the pixel counter (address) and expecting to receive back the byte it needs to send. Memory is one way of mapping an address to a byte, but in our case we will implement a custom module which will take this address and dynamically return a byte, \"dynamically\" creating the image. As we saw in the previous article in order to fully update the screen we need to send it 1024 bytes, which means our pixel counter / address needs to be 10 bits long. For each of the values between 0 1023 we need to know how to decipher: 1. which text row we are on 2. which character in the row 3. which column of the character 4. if we are on the top half of the column or bottom half (again because each vertical column is 16 pixels or 2 bytes). This can be accomplished using our mapping logic and a little understanding of binary. ## Deciphering the Address Before we start splitting characters into rows I think it is more convenient to think of all 4 rows as a single 64 character wide array. So for each OLED pixel address we need to think about which character out of the 64 possible character positions it belongs to. Looking back at the order the OLED pixel counter updates: ![](./assets/byte structure 1.jpg) We can see that we go left to right then drop down to the next row, each two rows is one character we know that the character index has to repeat the last 16 indices twice once for the top row and once for the bottom row. The pattern for character index has to be like the following: ```text 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63 ``` Where each number represents the value for 8 columns. The top row maps to the characters 0 15 then wraps around again to the same numbers to do the bottom row of those characters, then we continue counting the next 16. To accomplish this we need a sub counter for the 8 columns, which once it completes it increments the character index, then after 16 times increments it repeats the same 16 only after which it continues to the next 16. Because all the key numbers are powers of 2 we can simply use the bits of the address to accomplish this. ![address_decoding](./assets/address_decoding.jpg) In binary each bit represents a power of 2, and whenever you have a group of bits that are all 1, and you increment, it overflows to the next bit over and repeats the same cycle over. In our case we want a cycle of 8 for the columns, then for that to repeat in a second cycle of 16, then we need for the entire 16x8 cycle to happen again but without changing the character index, so the next bit after the 16 cannot be connected to character index, and finally we want that hole cycle of 2x16x8 to happen 4 times. So by dividing the bits as per the repeat pattern, we let the natural bit overflow of counting handle everything for us. Just as an example if we take the pixel address of 569 we would get the binary number: 1000111001 splitting it up based on the division above would give us: ```text columnCounter 001 or 1 in decimal characterIndex 100111 or 39 in decimal topRow 0 meaning it is the top row ``` and because there are 16 characters per row we know that character index 39 is the 8th character in the 3rd row. Another way to think of it is that the lower 16 bits of character index are the character number in a row and the top two bits are the row number. ## Implementing the Text Engine Let's start by making some changes to the current screen module to make it receive the data from an outside module instead of from `screenBuffer`. To do this we will output from the module the pixel byte address and we will input the desired pixel data for that address: ```verilog output [9:0] pixelAddress, input [7:0] pixelData ``` For the pixel address we already have the `pixelCounter` variable so we can just connect them: ```verilog assign pixelAddress pixelCounter; ``` And the only other change we need is to update the load data state to take the data from the input parameter instead of from the `screenBuffer`: ```verilog STATE_LOAD_DATA: begin pixelCounter < pixelCounter + 1; cs < 0; dc < 1; bitNumber < 3'd7; state < STATE_SEND; dataToSend < pixelData; end ``` The last line is the new change which sets the `dataToSend` to the data we receive over the new `pixelData` input. Other than that you can delete the two lines we had for the screen buffer: ```verilog reg [7:0] screenBuffer [1023:0]; initial $readmemh(\"image.hex\", screenBuffer); ``` As we no longer need it or the image we were loading. Our screen module is now ready to interface with other modules. So let's get started on the text engine module. Create a new file called `text.v` with the following: ```verilog module textEngine ( input clk, input [9:0] pixelAddress, output [7:0] pixelData ); reg [7:0] fontBuffer [1519:0]; initial $readmemh(\"font.hex\", fontBuffer); endmodule ``` Its inputs are the opposite of what we just defined so that they can connect. Here we are receiving the `pixelAddress` and need to output the data for that pixel. Inside the module we are creating a memory for our font where each index stores a single byte and we have 1520 bytes which is 16 bytes for each of the 95 characters. The next lines loads the `font.hex` file we generated at the beginning into this memory. Next we know how to split up the address from a pixel index to the desired character index column and whether or not we are on the top row: ```verilog wire [5:0] charAddress; wire [2:0] columnAddress; wire topRow; reg [7:0] outputBuffer; ``` We also need a buffer to store the output byte. Connecting these up is simple now that we understand the mapping: ```verilog assign charAddress {pixelAddress[9:8],pixelAddress[6:3]}; assign columnAddress pixelAddress[2:0]; assign topRow !pixelAddress[7]; assign pixelData outputBuffer; ``` The column address is the last 3 bits, the character address is made up of a lower 16 counter and the higher 4 counter for the rows. For the flag which indicates whether we are on the top row or bottom row we can just take a look at bit number 8 where it will be 0 if we are on the top row and 1 if it is the second iteration and we are on the bottom, so we invert it to match the flag name. Last but not least we hookup the `outputBuffer` to the `pixelData` output wires. With all the mapping out of the way let's take a look at how we now convert a letter to pixels. ### Converting a Letter to Pixels Without getting into how we will get the current letter, let's take a look at how we would convert a letter using all the mapping data we just prepared. To get started we can create some more wires to store the current char and the current char we want to display. ```verilog wire [7:0] charOutput, chosenChar; ``` We have two variables for this because our font memory only has values for the character codes 32 126 other character codes would give an undefined behavior. So `charOutput` will be the actual character we want to output, and `chosenChar` will check if it is in range and if not replace the character with a space (character code 32) so it will simply be blank: ```verilog assign chosenChar (charOutput > 32 && charOutput < 126) ? charOutput : 32; ``` If we look back at how we stored our font data, we stored the first column top byte then the first column second byte then the next column top byte and so on. So if we want the letter \"A\" in memory, we know that its ascii code is 65 and our memory starts from ascii code 32 subtracting them gives us the number of characters from the start of memory we need to skip which in this case is 33. We need to multiply this number by 16 as each character is 16 bytes long giving us 528 bytes. Next if we wanted column index 3 we know each column is 2 bytes so we would need to skip another 6 bytes. Lastly once at the column boundary we know the first byte is for the top row and the second byte is for the bottom row of the character, so depending on which we need we optionally skip another byte. In code this looks something like the following: ```verilog ((chosenChar 8'd32) << 4) + (columnAddress << 1) + (topRow ? 0 : 1) ``` We take the character we want to display, subtract 32 to get the offset from start of memory. Multiply by 16 (by shifting left 4 times) to get the start of the character. Add to this the column address multiplied by 2 (again by shifting left by 1) and optionally adding another 1 if we are on the bottom row. This can be used to access the exact byte from the font memory needed: ```verilog always @(posedge clk) begin outputBuffer < fontBuffer[((chosenChar 8'd32) << 4) + (columnAddress << 1) + (topRow ? 0 : 1)]; end ``` With this one line we are mapping the desired character to the exact pixels for the specific column and row. The only thing missing is to know which character to output, but for now if we just add: ```verilog assign charOutput \"A\"; ``` It should simply display the letter A for all character positions. ### Building the project In order to build the project we need another module which will connect our two modules together, let's create a new file called `top.v` which will be our top module: ```verilog module top ( input clk, output ioSclk, output ioSdin, output ioCs, output ioDc, output ioReset ); wire [9:0] pixelAddress; wire [7:0] pixelData; screen scr( clk, ioSclk, ioSdin, ioCs, ioDc, ioReset, pixelAddress, pixelData ); textEngine te( clk, pixelAddress, pixelData ); endmodule ``` As the new top module it needs to receive all the inputs from the constraints file. We then create wires for both the address and data so we can connect them between the two modules. The first module we are defining is an instance of our screen module, and the second is our new text engine. The order doesn't really matter you just need to pass it the parameters in the correct order. By using the same wire variable for both modules it creates the connection between them and allows them to communicate. If using the toolchain manually you can update your `Makefile` to add the new files: ```makefile BOARD tangnano9k FAMILY GW1N 9C DEVICE GW1NR LV9QN88PC6/I5 all: text.fs # Synthesis text.json: top.v text.v screen.v \tyosys p \"read_verilog screen.v text.v top.v; synth_gowin top top json text.json\" # Place and Route text_pnr.json: text.json \tnextpnr gowin json text.json freq 27 write text_pnr.json device ${DEVICE} family ${FAMILY} cst ${BOARD}.cst # Generate Bitstream text.fs: text_pnr.json \tgowin_pack d ${FAMILY} o text.fs text_pnr.json # Program Board load: text.fs \topenFPGALoader b ${BOARD} text.fs f # Generate Simulation text_test.o: text.v text_tb.v top.v screen.v \tiverilog o text_test.o s test text.v text_tb.v top.v screen.v # Run Simulation test: text_test.o \tvvp text_test.o # Generate Font font: font.hex font.hex: \tnode ./scripts/generate_font.js # Cleanup build artifacts clean: \trm text.vcd text.fs text_test.o .PHONY: load clean test .INTERMEDIATE: text_pnr.json text.json text_test.o ``` To make it compile multiple files we basically just need to add the files wherever we had the previous verilog files. So for example when compiling the JSON in the synthesis stage, `read_verilog` used to only receive the `screen.v` file, now it has all three of our verilog files. The rest of the file is as per our standard template just with the added method for generating the font hex file. Running the project now after you generated your `font.hex` file (with `node ./scripts/generate_font.js`) should give you something like the following: ![screen_aaa](./assets/screen_aaa.jpg) ### Displaying Specific Characters We are on the home stretch, we can now display any of the 95 characters, we just need a way to store which character is in each character position. We could do this with a 64 byte memory one byte for each character on the screen, but for cases where you may want multiple modules updating the screen at the same time it is sometimes better to have multiple smaller memories then one big one, allowing different parts of your project to work in parallel. So in our example let's create a module which will represent a single row of text and then we can just instantiate 4 of them to fill up the screen. ```verilog module textRow #( parameter ADDRESS_OFFSET 8'd0 ) ( input clk, input [7:0] readAddress, output [7:0] outByte ); reg [7:0] textBuffer [15:0]; assign outByte textBuffer[(readAddress ADDRESS_OFFSET)]; endmodule ``` So in the same file we can add this module which receives a character address (0 63) and needs to return a byte (representing 1 character) from the 16 bytes in the `textBuffer` for its row. We also have a parameter `ADDRESS_OFFSET` which will allow us to offset the rows by 16 characters. So the first row will output character 0 15 from the buffer for character address 0 15, but the second row needs to output 0 15 while character index will be 16 31 so we will send it 16 as the `ADDRESS_OFFSET` to subtract this difference. The final thing we need here is to initialize the memory. So far we have been loading a file into each of the memories we created, but here we don't have such a file so we need to initialize it manually. ```verilog integer i; initial begin for (i 0; i<15; i i+1) begin textBuffer[i] 48 + ADDRESS_OFFSET + i; end end ``` This will loop through all 16 characters and set an initial value allowing for the toolchain to know what to preprogram into the memory created. We can now go back to our `textEngine` module and add the following instances of our text row: ```verilog wire [7:0] charOutput1, charOutput2, charOutput3, charOutput4; textRow #(6'd0) t1( clk, charAddress, charOutput1 ); textRow #(6'd16) t2( clk, charAddress, charOutput2 ); textRow #(6'd32) t3( clk, charAddress, charOutput3 ); textRow #(6'd48) t4( clk, charAddress, charOutput4 ); ``` We create 4 instances each offset 16 from the previous and we pass each one it's own output line for the character it thinks should be on screen. We can then replace the old assignment to `charOutput` with the following: ```verilog assign charOutput (charAddress[5] && charAddress[4]) ? charOutput4 : ((charAddress[5]) ? charOutput3 : ((charAddress[4]) ? charOutput2 : charOutput1)); ``` Here we are multiplexing the 4 values and only looking at the value from the current row. We have already seen that the top two bits of the character address represent the row number. So if they equal 3 (row index 3 which means both bits are 1) then it is row 4, if the bits are 10 then it is row 3, 01 is row 2 and finally 00 is row 1. Running this now we should see all the rows filled with different characters. ![screen_text](./assets/screen_text.jpg) We can even change the initialization of `textRow` to something specific to better show that each row is handled separately: ```verilog integer i; initial begin for (i 0; i<15; i i+1) begin textBuffer[i] 0; end textBuffer[0] \"L\"; textBuffer[1] \"u\"; textBuffer[2] \"s\"; textBuffer[3] \"h\"; textBuffer[4] \"a\"; textBuffer[5] \"y\"; textBuffer[6] \" \"; textBuffer[7] \"L\"; textBuffer[8] \"a\"; textBuffer[9] \"b\"; textBuffer[10] \"s\"; textBuffer[11] \"!\"; end ``` Running this would give us: ![screen_lushay](./assets/screen_lushay.jpg) ## Conclusion In this article we created a text engine to let us dynamically write strings of text to the screen converting the desired characters to pixels using fonts and mapping the position of each character to the screen pixel positions. With all that said, as dynamic as it converts strings to pixels, the text itself we are displaying is still pretty static. In the next article we will expand on this mini project and go over some methods to dynamically create strings from values and data. Thank you for reading, I hope you enjoyed, if you have any questions or comments feel free to leave a comment below or contact us on twitter <a href \"https://twitter.com/LushayLabs?ref lushay labs\">here</a>. If you would like to purchase any of the components used in this article and support the site you can get them from our store <a href \"https://store.lushaylabs.com/collections/all products?ref lushay labs\">here</a>. And as always all the source code for this entire series can be found on github <a href \"https://github.com/lushaylabs/tangnano9k series examples?ref lushay labs\">here</a>."},"/hardware/zh/tang/Tang-Nano-9K/examples/lushaylabs/3_oled_101/oled_101.html":{"title":"Tang Nano 9K SSD1306 OLED 屏幕","content":" title: Tang Nano 9K SSD1306 OLED 屏幕 keywords: FPGA, Tang, Nano, 9K update: date: 2023 03 14 version: v0.1 author: wonder content: 新建文档 This is part 3 in our Tang Nano 9K series. In this article we will be starting a mini project creating an OLED text engine core. This series will go through the entire process from concept to implementation to demonstrate not just the code but also the design process and considerations taken when creating a multi component system. Part 1 (this part) will be an intro on the HW and creating the base driver so that we can display something to the screen. Part 2 will go over displaying text on our base OLED core including how to map ascii character codes to the screen data and using custom fonts.Part 3 will wrap up the project taking everything we did in the previous parts in order to build a reusable dynamic text engine that can be used by other cores to display their own data onto the screen. To follow along you will need a Tang Nano 9K and a 128x64 pixel screen with an SSD1306 driver using its 4 wire SPI configuration (the screen itself should have 7 pins). We will be using a 0.96\" OLED screen matching these requirements, you can get these along with a breadboard jumpers and the tang nano from our store <a href \"https://store.lushaylabs.com/collections/all products?ref lushay labs\">here</a>. ## The Plan In this part we are not going to think about the overall architecture or how the screen will communicate with the rest of the system. We will only be worried about being able to drive the screen using the FPGA building the physical driver for the OLED screen. To do this we first need to better understand how the screen works and how it expects to be communicated with. The screen we are using has an SSD1306 IC driver so we can go over its datasheet to get the information we need. [SSD1306 Datasheet](https://dl.sipeed.com/fileList/others/ssd1306/SSD1306.pdf) ## The SSD1306 Driver This driver IC is the interface between you and the actual OLED's underlying display. An OLED consists of many LEDs which need to be controlled individually to produce the desired picture. The driver is what connects to these LEDs and provides an interface where you can send it commands or data in order to update the display. Looking at the block diagram in the datasheet we can see how it works internally: ![block_diagram](./assets/block_diagram.jpg) Looking at the left side, we have a microcontroller which is what we will be communicating with. The pins we care about are the the first three and D0 and D1, the first three are reset, chip select and data/command flag and D0 is our SPI clock and D1 is our SPI data. All the other pins are used for alternate communication methods, like if interfacing with the screen over parallel connection. But since we are using the driver in it's 4 wire SPI mode we only need the 5 pins listed above. The MCU receives data from us, and then will decide whether the data is a command meant to control the display, or whether it was pixel data meant to update the contents of the display. Pixel data gets stored in the Graphics RAM which stores the contents for the entire display, the RAM propagates through the display driver to the actual pins controlling the individual OLEDs. The benefits of using a screen buffer in ram like this is that the screen can be updated independently of the device controlling it, and also you can just send an update to change a part of the image and the screen will remember the rest of the image. If the DC (data/command) flag was set to be a command, then the data will go to the command decoder to process and perform the command that you sent. Each \"transmission\" to the screen is a single byte, and if the data/command pin is set low that byte will be interpreted as a command and if set high the byte will be sent to the graphics ram to the current screen position stored in the ssd1306's memory. ### How Data is Stored The screen itself we are using has 128 x 64 pixels or 8192 individual pixels. The SSD1306 lets us configure how the ram is mapped to the display, but in general each byte controls a vertical line of 8 pixels. This means to control each of the 64 pixels in each column we need to set 8 bytes (again each byte controls 8 vertical pixels). The first byte will control the top left column, then we will increment by one and update the 8 pixels to the right and so on until we wrap around to the second row of 8 pixel columns: ![byte_structure](./assets/byte_structure.jpg) > 128 bytes per row 8 rows, each byte controlling 8 vertical pixels In the example above we sent 136 bytes with 0xFF (binary 11111111) this will result in the top row of 8 pixels being lit up across the whole screen, and in the first 8 columns we will have the top 16 pixels lit up. The least significant bit is the top pixel and the most significant bit is the bottom in each column, so a byte like 01010111 would create a column of pixels like the following: ![pixel_1](./assets/pixel_1.jpg) ### Command Bytes Like mentioned above the device has a set of commands that we can send it to do certain things. Inside the datasheet linked above we can see multiple tables including commands like the following: ![command_table](./assets/command_table.jpg) Each row contains a command and shows the byte or bytes (for multi byte commands) that need to be sent. A 1 or 0 means that bit needs to be a one or zero and when there is a parameter it will be marked with numbered letters and referenced on the right. For example to invert the screen (3rd command in the picture) we can see that we need to send 1010011x where the last bit can be either a one or zero. If we set it to a zero the command will set the display to normal mode, where a pixel set to zero will be off and a pixel set to 1 in the ram will be on. If we instead send a 1 as the last bit of the command, the screen will be inverted and a zero in RAM will cause a pixel to be lit up. We won't go through all the commands individually but by following the same approach you can decipher the rest of the command tables. In order to use the OLED display we first need to perform an initialization sequence where we send it all the commands required to setup all the configuration of the OLED. Once initialized we can start sending it pixel data and see the screen update. The last thing we need to go over before getting into the code is to go over the communication protocol itself, which in our case is SPI. ## SPI We will be communicating with the OLED screen over SPI. SPI is a serial protocol where 2 devices communicate with a data line for each direction and a common clock line. There are multiple modes in SPI, depending on whether you read on the rising / falling edge and whether the idle state of the clock is high or low. Multiple SPI devices can be connected together over the same wires and then each of the devices will have a separate chip select pin (CS) with which you can choose which device you are currently communicating with. With the SSD1306 driver we are using an extra wire to tell the device if the current byte being sent is data or a command. This is not part of the SPI protocol but is part of our communication interface we are building. From the datasheet we can see an example of how to communicate with the driver in this 4 wire SPI mode: ![spi_send](./assets/spi_send.jpg) The first line in the image is the chip select pin. Like mentioned above this pin signifies that we are currently communicating with this device, kind of like an enable pin. We pull it low at the start of our communication and put it back high when done. The next line is the Data/Command Flag, this can be either high or low, a high value means it is pixel data and a low value signifying a command. The third line just shows a combination of the data / clock pins just to show that multiple bytes can be sent without needing to change the chip select each time. Next we have a zoom in of how a single byte looks when being sent. The first of these lines is the clock pin the second is the data pin. We see here the clock pin can either be high or low while idle, but more importantly we see that the data should be updated on the falling edge and it will be read on the rising edge. We also see that the most significant bit of the byte we are sending should be sent first. With all that information we have everything we need to start building a driver core to interface with the OLED display. ## Creating the Driver core Like always to get started we can create a new project / folder in VSCode containing a constraints file with the tangnano9K pins we will be using, a verilog file for our driver core module and a Makefile to make building easier. ### Boilerplate **Constraints File** For the constraints file we can create a `tangnano9k.cst` file with the following: ![screen_contraints](./assets/screen_contraints.jpg) If creating manually it would look like this ```txt IO_LOC \"clk\" 52; IO_PORT \"clk\" PULL_MODE UP; IO_LOC \"io_cs\" 36; IO_PORT \"io_cs\" IO_TYPE LVCMOS33 PULL_MODE DOWN DRIVE 8; IO_LOC \"io_dc\" 39; IO_PORT \"io_dc\" IO_TYPE LVCMOS33 PULL_MODE DOWN DRIVE 8; IO_LOC \"io_reset\" 25; IO_PORT \"io_reset\" IO_TYPE LVCMOS33 PULL_MODE DOWN DRIVE 8; IO_LOC \"io_sdin\" 26; IO_PORT \"io_sdin\" IO_TYPE LVCMOS33 PULL_MODE DOWN DRIVE 8; IO_LOC \"io_sclk\" 27; IO_PORT \"io_sclk\" IO_TYPE LVCMOS33 PULL_MODE DOWN DRIVE 8; ``` We define the clock pin and we define the 5 pins we will need for interfacing with the OLED driver: 1. Chip Select `io_cs` 2. Data / Command `io_dc` 3. Reset Pin `io_reset` 4. SPI Data In to OLED `io_sdin` 5. SPI clock `io_sclk` I chose these pins just because they are consecutive there is no special function and any other 3.3v pins could have been chosen. ![tang_nano_oled_pins](./assets/tang_nano_oled_pins.jpg) **Makefile** This is only if you are not using the Lushay Code extension and instead run the toolchain manually. For the Makefile just create a file called `Makefile` with our standard project boilerplate: ```makefile BOARD tangnano9k FAMILY GW1N 9C DEVICE GW1NR LV9QN88PC6/I5 all: screen.fs # Synthesis screen.json: screen.v \tyosys p \"read_verilog screen.v; synth_gowin top screen json screen.json\" # Place and Route screen_pnr.json: screen.json \tnextpnr gowin json screen.json freq 27 write screen_pnr.json device ${DEVICE} family ${FAMILY} cst ${BOARD}.cst # Generate Bitstream screen.fs: screen_pnr.json \tgowin_pack d ${FAMILY} o screen.fs screen_pnr.json # Program Board load: screen.fs \topenFPGALoader b ${BOARD} screen.fs f # Generate Simulation screen_test.o: screen.v screen_tb.v \tiverilog o screen_test.o s test screen.v screen_tb.v # Run Simulation test: screen_test.o \tvvp screen_test.o # Cleanup build artifacts clean: \trm screen.vcd screen.fs screen_test.o .PHONY: load clean test .INTERMEDIATE: screen_pnr.json screen.json screen_test.o ``` For a better explanation on this makefile format you can take a look at our installation guide [here](./../1_installation_getting_started/installation_getting_started.html) where we go more in depth into this template. ## Implementing the Driver Core With the setup out of the way we can start implementing our driver with a verilog module. To use the screen like we saw above, we need to first initialize it, it is also recommended to reset the screen after its power stabilizes, this is to make sure it is in its proper reset state. So we will first wait a bit of time, then reset the screen, once reset we will send it all the initialization commands required to set it up and then the screen should be ready to start receiving and displaying pixel data. So our state machine will have the following steps: 1. Power Initialization Wait / Reset 2. Load Init Command Byte 3. Send Byte over SPI 4. Check Where to go from Sending 5. Load Pixel Data Byte The first stage will cover the power reset mentioned above, next we will have a state where we load the next command byte in the init sequence. Technically the next state would be to send the command byte over SPI, but there is no real difference between sending a command byte or sending a pixel byte so state 3 can be used for both. The only difference is which state to go to after sending the byte. In the case where there are more commands to send we would like to go to the state to load the next command otherwise we want to go to the state to load the next pixel byte. So step 4 will just check if there are more commands and if so go back to step 2 otherwise go to step 5. And step 5 just loads a pixel byte and links back to send it with step 3. ![states](./assets/states.jpg) We can create a file called `screen.v` with the following module outline: ```v module screen #( parameter STARTUP_WAIT 32'd10000000 ) ( input clk, output io_sclk, output io_sdin, output io_cs, output io_dc, output io_reset ); localparam STATE_INIT_POWER 8'd0; localparam STATE_LOAD_INIT_CMD 8'd1; localparam STATE_SEND 8'd2; localparam STATE_CHECK_FINISHED_INIT 8'd3; localparam STATE_LOAD_DATA 8'd4; endmodule ``` This is an empty module receiving the inputs we defined in the constraints file and defining the 5 states listed above. `STARTUP_WAIT` is an external parameter which is the number of clock cycles to wait before resetting the screen. It is an external parameter instead of a local parameter so that in simulation testing we don't have to wait as long. Next we can add some registers: ```v reg [32:0] counter 0; reg [2:0] state 0; reg dc 1; reg sclk 1; reg sdin 0; reg reset 1; reg cs 0; reg [7:0] dataToSend 0; reg [3:0] bitNumber 0; reg [9:0] pixelCounter 0; ``` We need a counter to count clock cycles and a register for the current state. Next we have a register for each of the inputs to drive them. Both the clock and reset pins are high on idle and `dc` we could have chosen either. Finally we have a register for the current byte we will be sending, a register to remember which bit of the current byte we are on and a register to keep track of which pixel of the screen we are on. Next let's create a register for holding all the init command bytes. We have a total of 15 init commands which take up a total of 23 bytes (some of the commands are 2 bytes). ```v localparam SETUP_INSTRUCTIONS 23; reg [(SETUP_INSTRUCTIONS*8) 1:0] startupCommands { 8'hAE, // display off 8'h81, // contast value to 0x7F according to datasheet 8'h7F, 8'hA6, // normal screen mode (not inverted) 8'h20, // horizontal addressing mode 8'h00, 8'hC8, // normal scan direction 8'h40, // first line to start scanning from 8'hA1, // address 0 is segment 0 8'hA8, // mux ratio 8'h3f, // 63 (64 1) 8'hD3, // display offset 8'h00, // no offset 8'hD5, // clock divide ratio 8'h80, // set to default ratio/osc frequency 8'hD9, // set precharge 8'h22, // switch precharge to 0x22 default 8'hDB, // vcom deselect level 8'h20, // 0x20 8'h8D, // charge pump config 8'h14, // enable charge pump 8'hA4, // resume RAM content 8'hAF // display on }; reg [7:0] commandIndex SETUP_INSTRUCTIONS * 8; ``` Besides for the init commands we also have a register which will remember which command we are currently on. Because the concat operator `{` and `}` place the most significant byte first, the first byte we write is actually placed at the end. We could have reversed the order we wrote the init commands and then started `commandIndex` at zero, but I think it is clearer to write the commands in order and then just start the current bit index at the last bit number. Next let's connect all the input wires to the registers we created for them. We could have also added the keyword `reg` to the input parameters themselves in which case it would have automatically created a register for us, but to make it more pronounced I separated it into two steps. ```v assign io_sclk sclk; assign io_sdin sdin; assign io_dc dc; assign io_reset reset; assign io_cs cs; ``` ### The State Machine For the state machine, let's work only on the rising edge of our clock to make things simpler. ```v always @(posedge clk) begin case (state) \t// states here endcase end ``` Next let's go through each of the states of our state machine one by one: **Load Init Command** ```v STATE_INIT_POWER: begin counter < counter + 1; if (counter < STARTUP_WAIT) reset < 1; else if (counter < STARTUP_WAIT * 2) reset < 0; else if (counter < STARTUP_WAIT * 3) reset < 1; else begin state < STATE_LOAD_INIT_CMD; counter < 32'b0; end end ``` Here we start with the reset set to 1 which is it's idle state and we wait a bit of time for the power to become stable. Then we wait the same period again this time reseting the screen by pulling the reset pin low. Finally we return the pin to high wait again a small amount to make sure the screen is ready to start receiving commands and move onto the next state resetting the counter to zero. The default `STARTUP_WAIT` is set to 10,000,000 so with a 27Mhz crystal we are looking at about a third of a second per step so for all three steps about a second. **Load Init Command** ```v STATE_LOAD_INIT_CMD: begin dc < 0; dataToSend < startupCommands[(commandIndex 1) :8'd8]; state < STATE_SEND; bitNumber < 3'd7; cs < 0; commandIndex < commandIndex 8'd8; end ``` Here we set the data / command bit to zero to signify that we are sending a command. We load the next command from the register we created with all the init command bytes. The syntax used here with the minus sign after the MSB tells it that we will not be placing the least significant bit but instead the length. Usually we use the syntax `[MSB:LSB]` to access memory here we are using `[MSB :LEN]` there is also the option with the a plus instead of a minus for `[LSB+:LEN]` Next we set the state to the send state as that is where we want to go next after loading a command byte. We set the bit number to the last bit as we saw from the datasheet we are sending most significant bit first in the SPI communication. Chip select is also set low to tell the screen we want to communicate with it now which essentially enables the screen to receive data over the SPI connection. The last line decrement the `commandIndex` by 8 as we have handled those 8 bits by loading them into `dataToSend`. **Sending a byte** ```v STATE_SEND: begin if (counter 32'd0) begin sclk < 0; sdin < dataToSend[bitNumber]; counter < 32'd1; end else begin counter < 32'd0; sclk < 1; if (bitNumber 0) state < STATE_CHECK_FINISHED_INIT; else bitNumber < bitNumber 1; end end ``` In order to simplify the implementation we will only be using the rising edge of our own clock, but the clock signal in SPI requires us to do things on both the rising and falling edge of the clock. So to get around this we will just use two of our clock cycles for each bit, one where the SPI clock will be pulled low and one where the SPI clock will be pulled high. In the first block we are setting the SPI clock low, and from the datasheet we saw we are supposed to change the data on the SPI data pin on the falling edge so we do that as well. On the second clock cycle of this state we will then reset the counter and pull the clock high, pulling it high will tell the screen to read the bit that we put on the data pin in the previous clock cycle. Lastly we check if we are already on the last bit, if so we go on to the next state, otherwise we decrement the `bitNumber` register to move to the next bit and continue sending in the current state. **Check Finished Init** ```v STATE_CHECK_FINISHED_INIT: begin cs < 1; if (commandIndex 0) state < STATE_LOAD_DATA; else state < STATE_LOAD_INIT_CMD; end ``` In this stage we are pulling the chip select high to tell the screen we are finished (not mandatory as we could have sent multiple bytes on the same chip select pulse). Next we check if `commandIndex` is 0 which would mean we sent all the commands and can move from here to loading the next pixel byte, otherwise go back and load the next command byte. **Load Pixel Data** ```v STATE_LOAD_DATA: begin pixelCounter < pixelCounter + 1; cs < 0; dc < 1; bitNumber < 3'd7; state < STATE_SEND; if (pixelCounter < 136) dataToSend < 8'b01010111; else dataToSend < 0; end ``` The last state loads the pixel bytes one at a time. We start by incrementing the `pixelCounter` to track which screen pixels we are. Next we set chip select to zero to re enable the screen communication. Data / Command flag is set to 1 to signify we will be sending data now not commands. Next we reset the bit number back to the last bit and the state we set back to the \"send byte\" state to send the next pixel byte. We don't currently have any image to display, so as an example to make sure everything is working we can simply use the byte example from above as a test where we send the screen 136 bytes of 01010111. We never need to reset pixelCounter since there are exactly 1024 bytes which exactly fits into 10 bits, so the `pixelCounter` register will automatically roll over back to zero on its own. That should be everything required to get the screen working, programming the Tang Nano 9K by clicking on the \"FPGA Toolchain\" button from the bottom bar and then selecting \"Build and Program\" from the menu. (Or `make load` if running manually). With our tangnano programmed you should get something like the following: ![img_5705](./assets/img_5705.jpg) ## Loading An Image In terms of Verilog, loading an image instead of our two static rows of lines is pretty easy. We first need a memory where we can store all our bytes: ```v reg [7:0] screenBuffer [1023:0]; initial $readmemh(\"image.hex\", screenBuffer); ``` Our memory has 1024 slots each of which hold a single byte. The second lines tells the toolchain to load a file called `image.hex` into this memory. And then we can change the last if / else of our load pixel state to the following: ```v dataToSend < screenBuffer[pixelCounter]; ``` So our entire state should look like this: ```v STATE_LOAD_DATA: begin pixelCounter < pixelCounter + 1; cs < 0; dc < 1; bitNumber < 3'd7; state < STATE_SEND; dataToSend < screenBuffer[pixelCounter]; end ``` Some would say the code is even simpler now. The trouble comes more in how to create the file `image.hex`. We know each byte needs to represent 8 vertical pixels and we need to scan across the image from the top left in rows of 8 pixels. So the task of loading an image is more a task of converting an image into the format we need in order to display it. Luckily we can create a simple node.js script to do the conversion for us. ### Preparing the Image Data To begin with we first need a png image with the same size as the screen 128 x 64 pixels in size. Since the screen only has a single color we will only be using the transparency value of a PNG image to determine whether or not to turn on a pixel. To convert our image we will be using a node.js library to parse the image called `pngjs`. To install the library you can run the following command from the project directory: ```javascript npm i pngjs ``` Next let's create a script called `generate_image.js` with the following: ```javascript const fs require(\"fs\"); const PNG require(\"pngjs\").PNG; fs.createReadStream(\"image.png\") .pipe(new PNG()) .on(\"parsed\", function () { const bytes []; for (var y 0; y < this.height; y+ 8) { for (var x 0; x < this.width; x+ 1) { let byte 0; for (var j 7; j > 0; j 1) { let idx (this.width * (y+j) + x) * 4; if (this.data[idx+3] > 128) { byte (byte << 1) + 1; } else { byte (byte << 1) + 0; } } bytes.push(byte); } } const hexData bytes.map((b) > b.toString('16').padStart(2, '0')); fs.writeFileSync('image.hex', hexData.join(' ')); }); ``` We start by including the library along with the filesystem package to load the file. The next line creates a read stream to load the image (named `image.png`) and then pipes it to a PNG instance from the `pngjs` library and the next block will be called once the entire image is ready and loaded in memory. Inside this `parsed` block we have three nested `for` loops, the outer one is to go over the vertical lines, as you can see from the end of the line, we skip each time by 8 lines as each 8 lines are stored in a single byte. The next `for` loop is for going through all the columns nothing special here. The final `for` loop is for incrementing through each of the 8 pixels in a vertical column. Each time we complete the inner loop it means we have gone through 8 vertical pixels and we can store a new byte moving onto the next vertical column in our row. We start the internal loop at the last bit so that we can shift each of the bits into `byte` from the right. Going through the internal loop we are simply getting the index for the current pixel. `this.data` is a long array of bytes where for each pixel we have 4 bytes, one for red, one for green, one for blue and one for the alpha channel. So the first line calculates this offset by figuring out which byte we are, this is the number of complete rows (or y offset) multiplied by 128 (the screen width) plus the current x offset. We then multiply by 4 since each pixel is 4 bytes (RGBA). Once we have the offset we check if the transparency (or 4th byte in our 4 byte pixel) is greater then 128 (out of 256) so if it is 50% or more transparent we will put a zero and the pixel will be turned off, otherwise we will put a 1 and the pixel will be highlighted. Other then that we have these two lines: ```javascript const hexData bytes.map((b) > b.toString('16').padStart(2, '0')); fs.writeFileSync('image.hex', hexData.join(' ')); ``` Where we take each of our bytes and convert them to hex (base 16) and we pad them from the left with zeros so that each byte will be exactly 2 hex characters. The final line outputs the hex data into a file called `image.hex` separating each hex byte with a space. With our hex file created and our code updated we should be able to reprogram our FPGA and get something like the following: ![screen_with_image](./assets/screen_with_image.jpg) ## Conclusion In this part we have created the physical driver core to interface with the 0.96\" OLED display and we have covered loading a simple image to it. In the next part we will take it a step further and \"generate\" the screen buffer on chip by converting ascii text into pixels implementing text and fonts into our core. Thank you for reading, if you have any questions or comments feel free to leave them below or message us on twitter <a href \"https://twitter.com/LushayLabs?ref lushay labs\">here</a>. To get any of the items used in this tutorial like the screen / tang nano or breadboard you can go to lushaylabs store <a href \"https://store.lushaylabs.com/collections/all products?ref lushay labs\">here</a> . As always all the examples can be found on github by following this <a href \"https://github.com/lushaylabs/tangnano9k series examples?ref lushay labs\">link</a>"},"/hardware/zh/tang/Tang-Nano-9K/examples/lushaylabs/6_reading_from_the_external_flash/reading_from_the_external_flash.html":{"title":"","content":""},"/hardware/zh/tang/Tang-Nano-9K/examples/lushaylabs/5_data_conversion_visualization/data_conversion_visualization.html":{"title":"","content":""},"/hardware/zh/tang/Tang-Nano-9K/examples/lushaylabs/7_generating_random_numbers/generating_random_numbers.html":{"title":"","content":""},"/hardware/zh/tang/Tang-Nano-9K/examples/lushaylabs/9_i2c_adc_and_micro_procedures/i2c_adc_and_micro_procedures.html":{"title":"","content":""},"/hardware/zh/tang/Tang-Nano-9K/examples/lushaylabs/2_debugging_uart/debugging_uart.html":{"title":"Tang Nano 9K 调试","content":" title: Tang Nano 9K 调试 keywords: FPGA, Tang, Nano, 9K update: date: 2023 02 14 version: v0.1 author: wonder content: 新建文档 [原文链接](https://learn.lushaylabs.com/tang nano 9k debugging/) > This is the second article in our series on the Tang Nano 9K, the first section on getting your development environment setup can be found [here](./../1_installation_getting_started/installation_getting_started.html). When programming FPGAs or really any embedded system you usually have a lot less visibility into whats going on, in comparison to programming for computers. When everything works its great, but more times then not you won't get your design perfect on the first try and not having this visibility can make it hard to troubleshoot. In this article we will go through some of the different ways to debug an FPGA project as well as cover some of the more common issues, so if you do run into an issue you will know how to overcome it. We will also be building a UART module which will use the on board RV debugger built into the Tang Nano 9K ([🔌🔌](https://item.taobao.com/item.htm?id 666055424174)) to communicate with a computer serially. ## Classifying the Type of Bug To efficiently debug an issue, like in most things, it works best when you use the right tool for the job. Different types of bugs have different tools which can help to find them. From my experience you can usually categorize bugs into three main categories: <ol> <li>Syntax Errors</li> <li>Logic / Implementation Errors</li> <li>Integration Errors.</li> </ol> ### Syntax Errors This is the type of error where you mistyped, forgot to close a block, misused a verilog feature etc... All these kinds of issues are the least severe in my opinion, as they are brought up during the synthesis stage while compiling your design and you will usually get an exact file and line number. So even if the error message is not that clear, you still have the exact location of the problem which makes it easy to fix. We won't go too much into this type of bugs as like I mentioned you will immediately know about this kind of bug during syntheses if not before from the editor itself. ### Logic / Implementation Errors Logic errors are the types of errors where you had a flaw in your original design, maybe you forgot to handle edge cases or had a mistake in your original plan. Implementation errors are the flip side of this, where your design was actually solid, but the code written doesn't actually do what you intended. Both these kinds of issues are a bit harder to catch, since you won't receive any error message. The only indication you will have is that your project doesn't work as intended. In these situations though, we are talking about cases where you understand and know how it is meant to perform. For these cases we can use simulations and visual logic debugging with VCD files to see what our design is doing over time and track down at which stage there is a problem. We will cover both of these method below. ### Integration Errors Integrations errors are errors that occur only when run on the actual FPGA and are usually because of misunderstanding, or not fulling knowing how to interface with another device or a specific protocol. These types of errors are the most difficult to find as they are due to a 3rd party device or from missing information. For example if we were making an FPGA core which reads from a temperature sensor that has an 8 bit temperature value, if we thought the temperature IC returned a 10 bit value and tried to read that we would get incorrect results. This is especially hard to track down, as if you thought a device was 10 bit instead of 8 bit, you would have also made it 10 bit in the simulator in which case it would have passed. To find these kinds of issues you need methods to debug the FPGA while it is running, these methods include making use of the on board LEDs, UART communication during runtime or even logic analyzers / oscilloscopes, we will go over using the on board LEDs to display data as well as sending things from the FPGA to the computer over UART. ## UART In order to use the onboard UART debugger we need to implement our own UART transmitter and receiver modules, which gives us a good test case to go through all the debugging methods listed above. But before we get into the implementation, let's go over the protocol itself so we understand what we are going to be doing. ### The Protocol With UART you send data from one device to another over a single wire. You send 1 start bit of data, then an agreed upon amount of data bits (usually 8) and finally a stop bit. There are some more complex configurations, like multiple stop bits, or adding a parity bit as a checksum. But in our case we will be looking at the simple case of 1 start bit, 8 data bits and a stop bit. The data is transferred least significant bit first. &nbsp; Example sending the byte 01010101 or 85 in decimal: ![uart_2](./assets/uart_2.jpg) There is no clock signal to synchronize both sides like in some other common protocols here both sides need to agree in advance on a frequency or \"baud rate\" which is the amount of bits per second and then each side needs to manage their own clocks to meet the desired frequency. Because there is no common clock, one side cannot react to the \"rising edge\" for example of the other sides clock, and there may be some drift between the two devices not to mention that they might have completely different clock speeds which don't exactly line up with the baud rate. So because of this we want the receiver to be able to run at least 8 16 times faster then the agreed upon baud rate. That way the \"latest\" the receiver would realize the transmission started would be an 1/8th or 1/16th of the bit rate in, and so even if there is a drift due to the different clocks, you should still be able to read all 10 bits of the transmission successfully. The UART on the Tang Nano 9K runs in full duplex mode which means it uses two lines like the one above, allowing for each to device to both send and receive data at the same time. Other than the direction, the protocol is exactly the same for both directions, there is no single side which acts as the controller or schedules when to send or receive they both can decide to send data whenever they want over the appropriate line. ### The Implementation For this project we will need to connect to the onboard debugger's UART pins, which will transfer the UART data we send it to the computer over USB. So lets start with the constraints file. In a new project let's create a file called `tangnano9k.cst` ```v IO_LOC \"clk\" 52; IO_PORT \"clk\" PULL_MODE UP; IO_LOC \"led[0]\" 10; IO_LOC \"led[1]\" 11; IO_LOC \"led[2]\" 13; IO_LOC \"led[3]\" 14; IO_LOC \"led[4]\" 15; IO_LOC \"led[5]\" 16; IO_LOC \"btn1\" 3; IO_LOC \"uart_tx\" 17; IO_PORT \"uart_tx\" IO_TYPE LVCMOS33; IO_LOC \"uart_rx\" 18; IO_PORT \"uart_rx\" IO_TYPE LVCMOS33; ``` The clock and leds are the same as in the previous article's counter example. The btn `pin` is connected to the onboard button so that we can use it for sending data and the `rx` and `tx` pins of the uart are pins 17 and 18 from bank 2 of the FPGA. We will receive data from the computer over pin 17 `rx` and we will send data over pin 18 `tx`. ![uart_pins_1](./assets/uart_pins_1.jpg) You have to follow their path a bit in the schematic, but you can see that these two pins end up going to the BL702 which is the onboard Sipeed debugger. Another thing to notice about the buttons is that it is connected to 1.8V on idle through a 10K pull up, and is pulled low when pressed. So when using it we need to remember it is an active low signal. ![button](./assets/button.jpg) Now that we have the constraints file, lets setup our verilog file `uart.v`: ```v `default_nettype none module uart #( parameter DELAY_FRAMES 234 // 27,000,000 (27Mhz) / 115200 Baud rate ) ( input clk, input uart_rx, output uart_tx, output reg [5:0] led, input btn1 ); localparam HALF_DELAY_WAIT (DELAY_FRAMES / 2); endmodule ``` Here we are declaring a new module which receives the clock pin, uart receive and transmit pins, the leds and the button we configured. The brackets that go before the inputs is an optional section where you can define parameters that can be changed by files that use this module. They are like `localparam`s that we used in the previous article just configurable from the outside. In our case we have 1 parameter of this type called `DELAY_FRAMES` which is the number of clock pulses needed to reach the desired baud rate. In our example we will use one of the standard baud rates of 115200 bits per second, dividing the 27Mhz by this number of bits gives us a number a little higher than 234. So each transmission bit should take a bit over 234 clock pulses. The thing is we don't really want to measure exactly at the bit transition, because like we saw there can be a bit of drift between the clocks, and we are also not exactly counting the correct number of pulses (we would need an extra 0.375 clock pulses for each bit). The safer option is to read the bit directly in what we consider the middle of the bit pulse, that way if we are a bit early or a bit late in terms of clock pulses we will still fall into the correct bit and read the correct value. That is why we have another `localparam` which is simply the full `DELAY_FRAMES` divided by two so we can get to the middle of these pulses. Next we will need some registers: ```v reg [3:0] rxState 0; reg [12:0] rxCounter 0; reg [2:0] rxBitNumber 0; reg [7:0] dataIn 0; reg byteReady 0; ``` The FPGA doesn't do the same thing every clock pulse like in the example of the counter from the previous article. Here we need to remember where we are in the UART cycle and react accordingly, a common way of doing this is with a state machine. That way we can start in an \"idle\" state when we see the start bit we can start receiving data and go to the \"read data\" state and then once we finish the bit we can go to the \"stop bit\" state finally returning back to \"idle\" ready to receive the next communication. The `rxState` register can hold in which state we currently are in. Next we know we need to count clock pulses (as we saw 234 clock pulses is 1 UART bit frame) so we have another register `rxCounter` for counting clock pulses. Next we have `rxBitNumber` which can keep track of how many bits we have read so far, this way we can know when the data is finished and when we will be moving to the stop bit. The next register is an 8 bit register which will store the byte received, and finally we have `byteReady` which is a flag register that will tell us when we have finished reading a byte and the value of `dataIn` is valid to use. Next let's define which states our state machine will have. ```v localparam RX_STATE_IDLE 0; localparam RX_STATE_START_BIT 1; localparam RX_STATE_READ_WAIT 2; localparam RX_STATE_READ 3; localparam RX_STATE_STOP_BIT 5; ``` Like mentioned above, we start in an idle stage, when there is a start bit we need to wait a certain amount of time, then 8 times we can alternate between reading a bit, and waiting for the next bit. Finally we have a state for the stop bit so we can again wait for it to complete and go back to being idle. I will first show the complete implementation and then we can go through each of the states to explain them: ```v always @(posedge clk) begin case (rxState) RX_STATE_IDLE: begin if (uart_rx 0) begin rxState < RX_STATE_START_BIT; rxCounter < 1; rxBitNumber < 0; byteReady < 0; end end RX_STATE_START_BIT: begin if (rxCounter HALF_DELAY_WAIT) begin rxState < RX_STATE_READ_WAIT; rxCounter < 1; end else rxCounter < rxCounter + 1; end RX_STATE_READ_WAIT: begin rxCounter < rxCounter + 1; if ((rxCounter + 1) DELAY_FRAMES) begin rxState < RX_STATE_READ; end end RX_STATE_READ: begin rxCounter < 1; dataIn < {uart_rx, dataIn[7:1]}; rxBitNumber < rxBitNumber + 1; if (rxBitNumber 3'b111) rxState < RX_STATE_STOP_BIT; else rxState < RX_STATE_READ_WAIT; end RX_STATE_STOP_BIT: begin rxCounter < rxCounter + 1; if ((rxCounter + 1) DELAY_FRAMES) begin rxState < RX_STATE_IDLE; rxCounter < 0; byteReady < 1; end end endcase end ``` ### The UART Receiver States The first state is the idle state: ```v RX_STATE_IDLE: begin if (uart_rx 0) begin rxState < RX_STATE_START_BIT; rxCounter < 1; rxBitNumber < 0; byteReady < 0; end end ``` Here we have nothing to do, we are just waiting for the UART `rx` line to be pulled low signifying a start bit. If the line has been pulled low, we set the counter to be equal to 1 to include the current \"clock pulse\" in the UART bit frame and we reinitialize the bitNumber and set the `byteReady` flag back to zero to signify that the `dataIn` register should not be used as we are in the middle of reading data to it. ```v RX_STATE_START_BIT: begin if (rxCounter HALF_DELAY_WAIT) begin rxState < RX_STATE_READ_WAIT; rxCounter < 1; end else rxCounter < rxCounter + 1; end ``` We would like to read the data in the middle of each uart bit, so during the start bit we won't wait a complete bit frame and then read, we will wait a half bit frame and then every 1 uart bit (234 clock pulses) we can read so we will be exactly in the middle. Here we are initializing the counter to 1 since registers take an extra clock pulse to update, so we account for that 1 pulse. ```v RX_STATE_READ_WAIT: begin rxCounter < rxCounter + 1; if ((rxCounter + 1) DELAY_FRAMES) begin rxState < RX_STATE_READ; end end ``` This next stage is merely waiting the 234 clock pulses for the next bit we can read. Since we are already have a half uart bit offset from the previous state we will be in the middle of the signal ready to read after this. Here we are using another method to account for the register delay, we can add 1 when comparing. ```v RX_STATE_READ: begin rxCounter < 1; dataIn < {uart_rx, dataIn[7:1]}; rxBitNumber < rxBitNumber + 1; if (rxBitNumber 3'b111) rxState < RX_STATE_STOP_BIT; else rxState < RX_STATE_READ_WAIT; end ``` In the read state we are clearing the counter to 1, shifting one bit into the dataIn register, incrementing the bitCounter so we can keep track of how many bits we have read so far. If we are already on `rxBitNumber` 7 or 111 in binary we can go to the stop bit and the entire byte has been read, if not we can go back to the read wait state and wait for the next bit. This syntax for bit shifting is actually syntax for concatenating bits. You can use it for example to set a register, the order of the bits is from most significant to least significant. So for example if we do the following: ```v reg [4:0] demo {1'b1,1'b0,2'b110} ``` It would store 10110 in binary or 22 in decimal. In our example we are doing the following: ```v dataIn < {uart_rx, dataIn[7:1]}; ``` Which means the new bit will be placed as the most significant bit, and then we will take the top 7 bits as the first seven bits, essentially moving them all one over, losing the bit at index 0. Internally this creates what is called a shift register since the output of the last bit (bit 7) is connected to the input of bit 6, and bit 6's output is connected to the input of bit 5, etc. Since UART sends the data least significant bit first, we shift the bits in from the most significant bit, so that after shifting 8 times it will end up at the other side and be the least significant bit. ```v RX_STATE_STOP_BIT: begin rxCounter < rxCounter + 1; if ((rxCounter + 1) DELAY_FRAMES) begin rxState < RX_STATE_IDLE; rxCounter < 0; byteReady < 1; end end ``` The final state is the stop bit state and like the read wait we are simply waiting 234 frames after which we are going back to the idle state and setting the `byteReady` flag bit to 1. At this point we should have a working UART receiver, but we wont be able to see that anything is being received. So let's add another `always` block which will react to the data being ready and display the data (or 6 bits at least) on the leds. ```v always @(posedge clk) begin if (byteReady) begin led < ~dataIn[5:0]; end end ``` This block runs in parallel to the UART receiver and will update the LED's register on every clock pulse that the data is ready. We are inverting because the LEDs light up when a bit is set low. ### Testing our Module Now before running this on the FPGA let's look at the first form of debugging which is simulation and visual logic debugging. The way we do this is with Icarus Verilog or iVerilog and VCD files. We already set these up along with a plugin for visual studio code allowing us to view them. To get started we need to create another verilog module known as a test bench which will define the simulation. So create another verilog file called `uart_tb.v` with a new module: ```v module test(); reg clk 0; reg uart_rx 1; wire uart_tx; wire [5:0] led; reg btn 1; uart #(8'd8) u( clk, uart_rx, uart_tx, led, btn ); endmodule ``` This is a new module named test which simply doesn't receive any outside inputs and instead creates all the inputs that the module we want to test requires and creates an instance of that module. So here we are creating a register for the clock the uart rx and tx pins the wires and the button. This isn't always true but as a general rule of thumb I use registers if it is an input into the module to drive the value and if it is an output I use a wire as the module itself will drive the value. You can also see that we are defining an override for the `DELAY_FRAMES` parameter. The `#()` is for the parameters and we don't want to actually need to look at 234 frames of clock pulses in our simulation so I lowered it to 8 clock pulses. Next we need a way to simulate the clock signal. This can be done like follows: ```v always #1 clk ~clk; ``` The `#number` (`#1`) is a special simulation syntax from iverilog that allows us to delay something by a certain number of time frames. By saying each time interval the clock alternates, we are saying the clock cycle is 2 time units (1 high cycle and 1 low cycle is 1 clock cycle). So this loop will wait 1 time unit and toggle the clock register. The next simulation specific feature I want to go over is the `$display` and `$monitor` commands. They are similar to a `printf` or `console.log` where they print out a string optionally injecting variables into it. The difference between display and monitor, is that display will only print the value out once, monitor will print it out, and then reprint it out any time the value changes. So to simulate the UART transmission we can do the following: ```v initial begin $display(\"Starting UART RX\"); $monitor(\"LED Value %b\", led); #10 uart_rx 0; #16 uart_rx 1; #16 uart_rx 0; #16 uart_rx 0; #16 uart_rx 0; #16 uart_rx 0; #16 uart_rx 1; #16 uart_rx 1; #16 uart_rx 0; #16 uart_rx 1; #1000 $finish; end ``` We start by printing a message, then we track the values of the leds and inject their value by using the `%b` which means print the binary representation of this field, we could have also used `%h` for hex representation `%d` for decimal and `%s` for string representation, among others. After that we send the start bit by pulling the line low, then send 8 data bits and finally the stop bit. We delay by 16 time frames or 8 clock cycles as that is what we set `DELAY_FRAMES` to be. `$finish` stops the simulation, so after 1000 more time frames we stop the simulation. For visually debugging the logic we can add another block to dump a VCD file. ```v initial begin $dumpfile(\"uart.vcd\"); $dumpvars(0,test); end ``` `$dumpfile` chooses the name of the file, and `$dumpvars` choosing what to save and how many levels of nested objects to save. By sending 0 as the number of layers it means we want all nested layers (which will include our uart module), and by sending the top module test it means store everything and all child wires / registers. To run this now we need to run in a terminal from the project directory: ```bash iverilog o uart_test.o s test uart.v uart_tb.v vvp uart_test.o ``` The first one generates a simulation based on the verilog files we sent it, the ` s` sets what is the `top` or main module being run and ` o` sets the simulation executables name. Ones finished we can run the simulation with the second line and it will produce the following output: ```bash Starting UART RX VCD info: dumpfile uart.vcd opened for output. LED Value xxxxxx LED Value 011110 ``` We can see it creating the VCD file as well as printed our message and the state of the led register. The initial value is `xxxxxx` because we did not initialize it, and `x` represents an unknown value. Once the full byte has been read in, the register gets updated with the inverted value of the first 6 bits. Simulation wise our program looks good, now let's take a look at the VCD file. Opening it in Visual Studio Code once you have the plugin installed will open up a UI that looks something like the following: ![uart_vcd](./assets/uart_vcd.jpg) By clicking on \"Add Signals\" you can add any of the wires or registers to the UI. In our example let's add the clock, uart_rx wire, rx state and &nbsp;led value. Once added you should have something like the following: ![debug_rx](./assets/debug_rx.jpg) If we zoom in on the start bit and first data bit: ![debug_rx_start](./assets/debug_rx_start.jpeg) We can see the state starts in idle, One clock cycle after we go to the start bit state where we wait the remainder of the first half cycle. Since we defined each uart bit to take 8 clock cycles we wait here for 4 clock cycles and move to the read wait stage. There we wait the full 8 clock cycles and move to read a bit, going back to the read wait stage one clock cycle later. From the simulation it looks like our module is working. But if we had an issue, for example we forgot to clear the counter in the read state. We would see that after the first bit was read we would never leave read wait stage. ![stuck_in_read_wait](./assets/stuck_in_read_wait.jpg) Or if we made the counter too small for example: ```v reg [1:0] rxCounter; ``` which can only store up to the number 3, if we needed it to count to 8 it wouldn't be able to: ![register_too_small](./assets/register_too_small.jpg) In both of these cases taking a look at the `rxCounter` we would see something going on, like here we can see that the register rolls over back to 0 after 3 since there are no more bits and as a result we get back stuck in the start bit state. This is also why you should also test your module with the real values. We changed DELAY_FRAMES to 8 to make it easier to follow step by step. But to make sure we don't have this problem with register sizes we would need to also test with the correct settings. Now to run it on the Tang Nano 9K, lets create a makefile to make it easier: ```makefile BOARD tangnano9k FAMILY GW1N 9C DEVICE GW1NR LV9QN88PC6/I5 all: uart.fs # Synthesis uart.json: uart.v \tyosys p \"read_verilog uart.v; synth_gowin top uart json uart.json\" # Place and Route uart_pnr.json: uart.json \tnextpnr gowin json uart.json freq 27 write uart_pnr.json device ${DEVICE} family ${FAMILY} cst ${BOARD}.cst # Generate Bitstream uart.fs: uart_pnr.json \tgowin_pack d ${FAMILY} o uart.fs uart_pnr.json # Program Board load: uart.fs \topenFPGALoader b ${BOARD} uart.fs f uart_test.o: uart.v uart_tb.v \tiverilog o uart_test.o s test uart.v uart_tb.v test: uart_test.o \tvvp uart_test.o # Cleanup build artifacts clean: \trm uart.vcd uart.fs uart_test.o .PHONY: load clean test .INTERMEDIATE: uart_pnr.json uart.json uart_test.o ``` This is very similar to the previous makefile we made, just with the added target to test using `iverilog` and also a target called `clean` which will delete some of the artifacts. So you can run `make load` to program the Tang Nano and then we should be able to view the data being sent to it over the LEDs. To open a serial terminal we can use tabby. Under the settings, if you go to \"Profiles &amp; Connections\" under the advanced tab and select \"Serial\", we can define the settings for our device: ![navigation](./assets/navigation.jpg) We need to select the serial device since the Tang Nano has two, 1 for JTAG and 1 for UART (which is usually the serial device with the higher number). Inside we need to also set the baud rate which we said is 115200 ![serial_settings](./assets/serial_settings.jpg) I also turned on Local echo so it will also print what we type, under the \"Advanced\" tab here we can see that there is 1 stop bit and 8 data bits. You can save this configuration and then under the profiles tab you can run the profile for the serial device chosen. You should see that you are connected and by pressing keys on the keyboard you should see the LEDs update. ## Transmitting Data Sending data is even more powerful in debugging since we can send things happening at runtime to a serial terminal to gain visibility. For example in our case, you can send back what you think you received over UART, if we saw bits being repeated, or bits missing we could know that the baud rate is too slow or too fast accordingly. Also very handy for dumping memory or sensor values when interfacing with other devices. The transmit side is very similar to the implementation of the receiver we did above, except that we don't want to count from the middle of the pulse, the transmit side has to change the line at the beginning of each bit frame. Let's start by adding some registers for the transmit side: ```v reg [3:0] txState 0; reg [24:0] txCounter 0; reg [7:0] dataOut 0; reg txPinRegister 1; reg [2:0] txBitNumber 0; reg [3:0] txByteCounter 0; assign uart_tx txPinRegister; localparam MEMORY_LENGTH 12; reg [7:0] testMemory [MEMORY_LENGTH 1:0]; ``` Like on the receiver side, we have a register to keep track of the tx state machine, we have a register for counting clock cycles. `dataOut` stores the byte being sent currently and `txPinRegister` is just a register to store the current value that should be attached to the `uart_tx` pin. The last two registers keep track of which bit we are currently sending, and the next is for which byte. In our example we will be sending a message from memory, so we need to keep track of the current byte. The `assign` statement connects the `uart_tx` wire to the register we created and the last two lines define a new \"memory\" where each cell is 8 bits long, and in our example we have 12 total cells. ```v initial begin testMemory[0] \"L\"; testMemory[1] \"u\"; testMemory[2] \"s\"; testMemory[3] \"h\"; testMemory[4] \"a\"; testMemory[5] \"y\"; testMemory[6] \" \"; testMemory[7] \"L\"; testMemory[8] \"a\"; testMemory[9] \"b\"; testMemory[10] \"s\"; testMemory[10] \" \"; end ``` This next code initializes the memory. There are also verilog commands that load in memory from a file, so when working on bigger memory blocks instead of initializing one byte at a time we could read it all from a binary or hex file, we will explore this more in a future article. Next let's define the states of our state machine. We don't have an extra \"wait\" stage here, again because we are not offsetting to the middle of the frame like when reading. We do have an extra stage at the end to debounce the button, since we will be using the button to determine when to send data. ```v localparam TX_STATE_IDLE 0; localparam TX_STATE_START_BIT 1; localparam TX_STATE_WRITE 2; localparam TX_STATE_STOP_BIT 3; localparam TX_STATE_DEBOUNCE 4; ``` ### The Transmit States ```v TX_STATE_IDLE: begin if (btn1 0) begin txState < TX_STATE_START_BIT; txCounter < 0; txByteCounter < 0; end else begin txPinRegister < 1; end end ``` The idle state waits for the button to be pressed (which will make it go low) at which point we will move to the start bit state. If the button is not pressed we set the `uart_tx` to be high as in UART we have a high idle state. ```v TX_STATE_IDLE: begin if (btn1 0) begin txState < TX_STATE_START_BIT; txCounter < 0; txByteCounter < 0; end else begin txPinRegister < 1; end end ``` The start bit is a low signal for `DELAY_FRAMES`, once reached we put the next byte we need to send into `dataOut` and reset the `txBitNumber` back to 0. ```v TX_STATE_WRITE: begin txPinRegister < dataOut[txBitNumber]; if ((txCounter + 1) DELAY_FRAMES) begin if (txBitNumber 3'b111) begin txState < TX_STATE_STOP_BIT; end else begin txState < TX_STATE_WRITE; txBitNumber < txBitNumber + 1; end txCounter < 0; end else txCounter < txCounter + 1; end ``` The write state is very similar, except instead of setting the tx pin to low, we set it to the current bit of the current byte. When the frame is over we check if we are already on the last bit, if so we go to the stop bit state, otherwise we increment the bit number and keep the current state of `TX_STATE_WRITE`. ```v TX_STATE_STOP_BIT: begin txPinRegister < 1; if ((txCounter + 1) DELAY_FRAMES) begin if (txByteCounter MEMORY_LENGTH 1) begin txState < TX_STATE_DEBOUNCE; end else begin txByteCounter < txByteCounter + 1; txState < TX_STATE_START_BIT; end txCounter < 0; end else txCounter < txCounter + 1; end ``` The stop bit is a high output bit, after waiting `DELAY_FRAMES` we check if there are any other bytes to send, if there are, we go back to send another start bit and the cycle will repeat for the next byte. If not we go to the debounce state. ```v TX_STATE_DEBOUNCE: begin if (txCounter 23'b111111111111111111) begin if (btn1 1) txState < TX_STATE_IDLE; end else txCounter < txCounter + 1; end ``` Here we are just waiting a minimum time (about 10 ms) on top of the sending time, and making sure the button is released after this time. This is to ensure that for each button press we only get one transmission event. Press on \"FPGA Toolchain\" > \"Build and Program\" or Run `make load` to reprogram the Tang Nano 9K and reopen the serial terminal. You should see that every time you press the button the FPGA should send the message we stored in memory over UART. <img src \"./assets/uart_transmit.jpg\" alt \"uart_transmit\"> For sending data that isn't ascii, you have a few options, the first being you can setup in tabby to print the data out in hex, and then manually decode it, or you can convert the data on device. So for example you can have another module which takes a number and converts it into text by encoding each digit into ascii. As to not make this article too long, we will cover these conversion methods in another article. ## Interacting Programmatically Serial terminal is great for quickly debugging or viewing data, but sometimes you need some processing on the data on the computer side, or you may just want to use the UART to communicate / control an application on one of the sides. To do this we need to open the serial port programmatically. We will be looking at a simple javascript example using node.js and the serialport library. To install the library run the following from a terminal in your project directory: ```bash npm i serialport ``` This will install the library we can then create a test script to print out the serial devices it sees, so create a file for example called `list devices.js`: ```javascript const {SerialPort} require('serialport'); SerialPort.list().then(console.log); ``` and then you can run it with `node list devices.js` you should see something like the following: ![uart_devices](./assets/uart_devices.jpg) With the `path` for the device we can write a simple program to interact with the tang nano: ```javascript const {SerialPort} require('serialport'); const tangnano new SerialPort({ path: '/dev/tty.usbserial 2101', baudRate: 115200, }); let counter 0; tangnano.on('data', function (data) { console.log('Data In Text:', data.toString()); console.log('Data In Hex:', data.toString('hex')); const binary data.toString().split('').map((byte) > { return byte.charCodeAt(0).toString(2).padStart(8, '0'); }); console.log('Data In Binary: ', binary.join(' ')); console.log(\"\\n\"); counter + 1; tangnano.write(Buffer.from([counter])); }); ``` We start by importing the library, then we initialize our device by sending the correct path and baud rate. Next we initialize a counter variable which we will use to count the number of transmissions. The next block will run every time there is a new message from the tang nano over the serial port. In this example we will simply print out the data in multiple formats as an example, and the final two lines increment the counter and send it to the tang nano. ![uart_program](./assets/uart_program.jpg) Running the script with you should something like the above, also see every time you press the button the LEDs count up in binary since they are connected to the byte being sent over UART and we are sending the counter. To exit the application you can press `ctrl c` which will stop the process to regain control over the terminal. ## Conclusion In this article we created our own UART module and went over some common issues and debugging methods. In the next article we will take a look at using a screen as another method of displaying data or relaying information from the FPGA. For those that made it this far I would like to thank you, and I hope you enjoyed reading. As always the code is available <a href \"https://github.com/lushaylabs/tangnano9k series examples\">here(github)</a>. And if you have any questions or comments feel free to leave them below or contact me on twitter <a href \"https://twitter.com/LushayLabs\">@LushayLabs</a>."},"/hardware/zh/tang/Tang-Nano-9K/examples/lushaylabs/10_our_first_cpu/our_first_cpu.html":{"title":"","content":""},"/hardware/zh/tang/Tang-Nano-9K/examples/LCD.html":{"title":"驱动RGB屏幕","content":" title: 驱动RGB屏幕 > 编辑于2022.04.12 ## 先介绍时序 RGB LCD 显示协议和 VGA 类似，通信都有专用的行同步、场同步信号线。它们的主要区别是前者传输用的是数字信号，后者传输走的是模拟信号。 下面就介绍 VGA 的时序 ![](./../../assets/examples/lcd_pjt_1.png) 上图分别是 VGA 在数据传输中的行同步、场同步时序 从时序图中可以看出，不论是显示一行数据还是一列数据，都需要一个同步(sync)信号，数据的传输需要在两个同步信号的脉冲之间完成 每一行的数据包括显示前沿(back porch)、有效数据(active video)、显示后沿(front porch) 其中的有效数据就是我们常说的分辨率，而显示前后沿的参数需要参考具体的分辨率与帧数进行设置，相关参数可以参考典型参数，链接在此： http://www.tinyvga.com/vga timing 这块5寸屏幕的控制时序略有不同，相关参数的设置可以查看[规格书](https://dl.sipeed.com/fileList/TANG/Nano%209K/6_Chip_Manual/CN/LCD_Datasheet/5.0inch_LCD_Datashet%20RGB.pdf) 其他尺寸的屏幕相关规格书均可以在这里下载 [点我](https://dl.sipeed.com/shareURL/TANG/Nano%209K/6_Chip_Manual/CN/LCD_Datasheet) 下面提供了 LCD 相关时序的截图 ![](./../../assets/examples/lcd_pjt_2.png) ![](./../../assets/examples/lcd_pjt_3.png) 上面一张图是时序中的参数表，下面的图是时序图 从时序图中看出，这块屏幕可以不用设置前后沿，可以只设置消影(blanking)时间，通过实际的程序证明，两种方式都是可以的 ## 新建工程 具体新建工程的方法可以参考[点灯文章](LED.html) ## 生成屏幕时钟 这里需要用到高云半导体官方的IP核 ### rPll 板载的晶振时钟为 27MHz ，但是我们的屏幕要求 33.3MHZ 的时钟，所以我们需要使用对应的ip核来生成相应的时钟 这里需要使用到 `IP Core Generate` ，位置在 Tools > IP Core Generate ![](./../../Tang Nano 1K/assets/Gowin_IP_rpll.png) 双击 `rpll` ，在弹出窗口 language 选择 Verilog ，CLKIN 为 27MHz ，CLKOUT 为 33.00MHz。 ![](./../../Tang Nano 1K/assets/lcd_rpll.png) 点击ok后提示是否需要添加到当前工程，此时应当选择确定 ![](./../../Tang Nano 1K/Nano_1K_examples/led/assets/add_ip_file_in_project.png) 接着会出现一个例化的tmp文件，用来例化所设置的ip。比如下图中例子 ![](./../../Tang Nano/examples/led/assets/ip_examples.png) ## 屏幕驱动代码 **首先新建一个额外的verilog文件来保存下面要编写的代码** ### 端口定义 首先需要先定义出驱动屏幕所需要的端口 ```verilog module VGAMod ( input CLK, input nRST, input PixelClk, output LCD_DE, output LCD_HSYNC, output LCD_VSYNC, \toutput [4:0] LCD_B, \toutput [5:0] LCD_G, \toutput [4:0] LCD_R ); ``` 本例程使用RGB565作为驱动方式； ### 时序常量 接着定义出时序图上所要求的常量 ```verilog localparam V_BackPorch 16'd6; //0 or 45 localparam V_Pluse \t 16'd5; localparam HightPixel 16'd480; localparam V_FrontPorch 16'd62; //45 or 0 localparam H_BackPorch 16'd182; \t localparam H_Pluse \t 16'd1; localparam WidthPixel 16'd800; localparam H_FrontPorch 16'd210; localparam PixelForHS WidthPixel + H_BackPorch + H_FrontPorch; \t localparam LineForVS HightPixel + V_BackPorch + V_FrontPorch; ``` 首先是设置时序相关的参数：前沿、后沿、有效像素 关于显示前沿、后沿，前面也说了，可以合并为一个消影时间，就是可以把其中一个设置为0，另一个设置为消影时间。反正前后沿的时间加起来符合表中的时间要求就可以 ### 定义变量 定义一些变量能够容易编写程序 ```verilog reg [15:0] LineCount; reg [15:0] PixelCount; reg\t[9:0] Data_R; reg\t[9:0] Data_G; reg\t[9:0] Data_B; ``` ### 同步信号 这段代码产生同步信号，需要注意的是，这块屏幕的同步信号是负极性使能 ```verilog always @( posedge PixelClk or negedge nRST )begin if( !nRST ) begin LineCount < 16'b0; PixelCount < 16'b0; end else if( PixelCount PixelForHS ) begin PixelCount < 16'b0; LineCount < LineCount + 1'b1; end else if( LineCount LineForVS ) begin LineCount < 16'b0; PixelCount < 16'b0; end else PixelCount < PixelCount + 1'b1; end always @( posedge PixelClk or negedge nRST )begin if( !nRST ) begin \t\t\tData_R < 9'b0; \t\t\tData_G < 9'b0; \t\t\tData_B < 9'b0; end else begin \t\t\tend \tend //注意这里HSYNC和VSYNC负极性 assign LCD_HSYNC (( PixelCount > H_Pluse)&&( PixelCount < (PixelForHS H_FrontPorch))) ? 1'b0 : 1'b1; assign LCD_VSYNC ((( LineCount > V_Pluse )&&( LineCount < (LineForVS 0) )) ) ? 1'b0 : 1'b1; ``` ### 使能信号 这段代码设置 LCD 使能图像显示，这块屏幕需要控制一个管脚用作显示开关，实际这个信号就是传输图像有效的那 800*480 的数据时置 1 ```verilog assign LCD_DE ( ( PixelCount > H_BackPorch )&& ( PixelCount < PixelForHS H_FrontPorch ) && ( LineCount > V_BackPorch ) && ( LineCount < LineForVS V_FrontPorch 1 )) ? 1'b1 : 1'b0; //这里不减一，会抖动 ``` ### 测试彩条 这段代码用来产生 LCD 的测试数据，产生彩条显示 ```verilog localparam Colorbar_width WidthPixel / 16; assign LCD_R ( PixelCount < ( H_BackPorch + Colorbar_width * 0 )) ? 5'b00000 : ( PixelCount < ( H_BackPorch + Colorbar_width * 1 )) ? 5'b00001 : ( PixelCount < ( H_BackPorch + Colorbar_width * 2 )) ? 5'b00010 : ( PixelCount < ( H_BackPorch + Colorbar_width * 3 )) ? 5'b00100 : ( PixelCount < ( H_BackPorch + Colorbar_width * 4 )) ? 5'b01000 : ( PixelCount < ( H_BackPorch + Colorbar_width * 5 )) ? 5'b10000 : 5'b00000; assign LCD_G ( PixelCount < ( H_BackPorch + Colorbar_width * 6 )) ? 6'b000001: ( PixelCount < ( H_BackPorch + Colorbar_width * 7 )) ? 6'b000010: ( PixelCount < ( H_BackPorch + Colorbar_width * 8 )) ? 6'b000100: ( PixelCount < ( H_BackPorch + Colorbar_width * 9 )) ? 6'b001000: ( PixelCount < ( H_BackPorch + Colorbar_width * 10 )) ? 6'b010000: ( PixelCount < ( H_BackPorch + Colorbar_width * 11 )) ? 6'b100000: 6'b000000; assign LCD_B ( PixelCount < ( H_BackPorch + Colorbar_width * 12 )) ? 5'b00001 : ( PixelCount < ( H_BackPorch + Colorbar_width * 13 )) ? 5'b00010 : ( PixelCount < ( H_BackPorch + Colorbar_width * 14 )) ? 5'b00100 : ( PixelCount < ( H_BackPorch + Colorbar_width * 15 )) ? 5'b01000 : ( PixelCount < ( H_BackPorch + Colorbar_width * 16 )) ? 5'b10000 : 5'b00000; ``` **当然在最后的驱动文件最后别忘记换行加上 endmodule** 到这里驱动模块的编写已经完成了。 ## 在顶层模块中例化 **这里也是要新建verilog文件的** 新建文件之后直接把下面的内容复制进去保存即可 ```verilog module TOP //设置顶层模块 ( \tinput\t\t\tnRST, input XTAL_IN, \toutput\t\t\tLCD_CLK, \toutput\t\t\tLCD_HYNC, \toutput\t\t\tLCD_SYNC, \toutput\t\t\tLCD_DEN, \toutput\t[4:0]\tLCD_R, \toutput\t[5:0]\tLCD_G, \toutput\t[4:0]\tLCD_B ); // 列出需要的端口 \twire\t\tCLK_SYS;\t \twire\t\tCLK_PIX; //例化pll Gowin_rPLL chip_pll( .clkout(CLK_SYS), //output clkout //200M .clkoutd(CLK_PIX), //output clkoutd //33.00M .clkin(XTAL_IN) //input clkin );\t \tVGAMod\tVGAMod_inst //例化vga驱动 \t( \t\t.CLK\t\t(\tCLK_SYS ), \t\t.nRST\t\t(\tnRST\t\t), \t\t.PixelClk\t(\tCLK_PIX\t\t), \t\t.LCD_DE\t\t(\tLCD_DEN\t \t), \t\t.LCD_HSYNC\t(\tLCD_HYNC \t), \t.LCD_VSYNC\t(\tLCD_SYNC \t), \t\t.LCD_B\t\t(\tLCD_B\t\t), \t\t.LCD_G\t\t(\tLCD_G\t\t), \t\t.LCD_R\t\t(\tLCD_R\t\t) \t); \tassign\t\tLCD_CLK\t\t \tCLK_PIX; endmodule ``` ## 综合、约束、布局布线 ### 综合 完成上面步骤后转到“Process”界面下，对编辑好的代码进行综合，即运行“Synthesize” ![](./../nano_9k/nano_9k_synthsize.png) 运行的结果如下图出现 ![](./../../Tang Nano/assets/LED.png) 且下方结果栏不出现任何从报错，说明前面编辑的代码无误，如果有错，根据错误提示进行改正即可。 ### 约束 此处仅管脚约束 对应的管脚约束如下表格所示； 关于管脚约束方法可以参考[点灯文章(点我)](./LED.html)里面的约束方法。 感觉麻烦的话也可以直接复制准备好的[文件(点我)](./lcd_constrains.html)，将页面里的内容复制到工程目录里 .cst 文件中（如果没有.cst 文件那么自己新建一个**物理管脚约束文件**） 即可。 PORT I/O PIN PORT I/O PIN LCD_B[4] output 41 LCD_B[3] output 42 LCD_B[2] output 51 LCD_B[1] output 53 LCD_B[0] output 54 LCD_G[5] output 55 LCD_G[4] output 56 LCD_G[3] output 57 LCD_G[2] output 68 LCD_G[1] output 69 LCD_G[0] output 70 LCD_R[4] output 71 LCD_R[3] output 72 LCD_R[2] output 73 LCD_R[1] output 74 LCD_R[0] output 75 LCD_DEN output 33 LCD_SYNC output 34 LCD_HYNC output 40 LCD_CLK output 35 XTAL_IN input 52 nRST input 4 ### 布局布线 管脚约束之后需要在设置里面开启引脚复用才能完成布局布线。 具体位置在 软件顶部菜单栏 Project > Configuration > Place&Route > Dual Purpose Pin ![](./../../Tang Nano/examples/led/assets/enable_io_mux.png) 设置完上面的之后。 就可以进行布局布线(Place&Route)了。 结束后就可以给开发板验证代码内容了。 ## 烧录 布局布线结束后生成比特流，就可以烧录开发板了。 ## 结束 上面差不多叙述了所有代码。 整个工程可以在参考 [这里](https://github.com/sipeed/TangNano 9K example) ，对应在lcd_led目录下。 <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano-9K/examples/LED.html":{"title":"点灯LED","content":" title: 点灯LED > 编辑于2022年7月13日 这里我们用点亮板子上的LED来作为例程来快速熟悉一下高云半导体 IDE 的使用流程 ## 创建工程 新建工程：File >NEW >FPGA Dsign Project >OK ![创建工程](./../../Tang Nano/assets/LED 1.png) 弹出的选项框设置工程名称和路径（路径和文件名称要求是英文路径） ![设置名称](./../../Tang Nano/assets/LED 2.png) 选择正确的型号： ![选择设备](./../nano_9k/Tang_nano_9k_Device_choose.png) ## 准备代码 新建好工程之后接下来进行代码编辑，可以在下图箭头指示的地方新建 “Verilog File” ![](./../../Tang Nano/assets/LED 5.png) 给文件命名（要求写英文名，不然后续综合很容易报错） ![](./../../Tang Nano/assets/LED 6.png) 双击文件，可以在右侧的编辑框中进行代码的编写。 ![](./../../Tang Nano/assets/LED 7.png) 以流水灯为例，将下方的 “LED例程代码” 复制并粘贴到自己创建的文件中，也可以自己编写代码，例程代码地址： <https://github.com/sipeed/TangNano 9K example> 使用 git clone 后可以在 led/src/LED.v 文件夹内找到代码 ```verilog module led ( input sys_clk, // clk input input sys_rst_n, // reset input output reg [5:0] led // 6 LEDS pin ); reg [23:0] counter; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) counter < 24'd0; else if (counter < 24'd1349_9999) // 0.5s delay counter < counter + 1'b1; else counter < 24'd0; end always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) led < 6'b111110; else if (counter 24'd1349_9999) // 0.5s delay led[5:0] < {led[4:0],led[5]}; else led < led; end endmodule ``` 上面代码完成后需要在 Project >Configuration >Place&Route >Dual Purpose Pin 中将 `Use DONE as regular IO` 勾选上，不然下面的综合会报错。 ![img_configuration](./../nano_9k/LED_Configuration.png) ## 综合、约束、布局布线 ### 综合 保存编辑的代码后转到 “Process” 界面，双击 “Synthesize” 来对我们所编写的代码进行综合。也可以鼠标右键点击看看有啥功能 ![Synthesize](./../nano_9k/nano_9k_synthsize.png) 运行的结果如下图一样 ![Finish_Synthesize](./../../Tang Nano/assets/LED.png) 且下方结果栏不出现任何从报错，说明前面编辑的代码无误，如果有错，根据错误提示进行改正即可。 ### 约束 此处没有涉及时钟约束 想让 Fpga 实现代码的功能，必须将代码中涉及的端口绑定到 Fpga 实际的引脚上。 如下图，在左边的工作区点击 process，然后双击 FloorPlanner （前面的综合如果运行失败，这一步无法进行） ![FloorPlanner](./../../assets/examples/led_pjt_2.png) 第一次打开会弹出缺少 .cst 文件.选择 “OK” 即可； ![.cst_file](./../../Tang Nano/assets/LED 9.png) 可以在这里下载到 Nano 9K 的原理图 [这里](https://dl.sipeed.com/shareURL/TANG/Nano%209K/2_Schematic) Nano 9K 的 led 部分的原理图如下所示 ![led原理图](./../nano_9k/LED_Pins.png \"nano 9k led pins\") 对于交互式管脚约束有两种方法 将对应的端口拖拽到芯片引脚上 在 IO 约束中输入端口对应的引脚编号 管教绑定的具体方法可以参考 [SUG935 1.3_Gowin设计物理约束用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG935 1.3_Gowin%E8%AE%BE%E8%AE%A1%E7%89%A9%E7%90%86%E7%BA%A6%E6%9D%9F%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf)。 当然别忘了对着原理图把晶振引脚和全局复位按键引脚也绑定一下 下图是本例程管脚约束示例 ![引脚约束](./../nano_9k/LED_FloorPlanner.png) ### 布局布线 > 未开启管脚复用会提示 error2017， 前文提到过启用方法 [准备代码](#准备代码) 到 Process 下运行布局布线，即双击 `Place&Route` ，结果将如下所示： ![Place&Route](./../nano_9k/LED_Place&Route.png) ## 下载到设备 ### 开始下载 双击 Program Device 打开下载软件 ![Programmer](./../../Tang Nano 4K/assets/Open_Programmer.png) 接下来是连接芯片型号，烧录固件，可参照下图选择芯片(注意这里是9C)： ![选择](./../nano_9k/nano_9k_device_scan.png) 以烧录进SRAM为例进行说明，如下图： 设置下载方式： ![设置sram下载方式](./../nano_9k/nano_9k_sram_program.png \"设置sram下载方式\") 进行下载： ![进行sram下载](./../nano_9k/nano_9k_sram_download.png \"进行sram下载\") ### 结果展示 结果显示： ![流水灯](./../nano_9k/blink.gif) ## 其他 有固化需求的话设置下载到 flash 即可 ![固化](./../nano_9k/access_mode.png) 有问题可以前往[相关问题](./../../Tang Nano Doc/questions.html) 当然也欢迎在下面留言 <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano-9K/examples/softcore-1/softcore-2.html":{"title":"使用PicoRV32软核在lcd屏幕上绘制图形","content":"# 使用PicoRV32软核在lcd屏幕上绘制图形 > 编辑于2022.06.22 原文链接:https://bbs.sipeed.com/thread/1483 有改动 ## 摘要 此工程在 LCD 屏幕绘制了两个长方形——一个实心的；另一个空心的。其中空心的边框宽度作为参数可调，并且绘图的颜色还可以通过按钮调整，现已支持红、绿、蓝和白，共四种颜色。 整体的硬件设计基于半导体提供的 PicoRV32 软核IP，在 OPEN AHB INTERFACE 的处，挂载了 128Kbits 的 BSRAM 用作显存。 该 128Kbits 的显存，本质上是一颗双端口的 SRAM ，使得 CPU 和自定义的 LCD IP 共同使用该“显存”。LCD IP 独立于CPU工作，节省 CPU 资源，达到 FPGA 加速的效果。 ## 设计 ### AHB 接口例化 AHB接口用于与CPU交互，LCD接口与LCD IP交互。代码接口如下： ```verilog ahb2bram ahb2bram( .clk_i(clk50), .reset_i(~sys_rstn), .hrdata_o(hrdata), .hresp_o(hresp), .hready_o(hready), .haddr_i(haddr), .hwrite_i(hwrite), .hsize_i(hsize), .hburst_i(hburst), .hwdata_i(hwdata), .hsel_i(hsel), .htrans_i(htrans), .lcd_clk_i(clk10), .lcd_rd_i(lcd_rd), .lcd_addr_i(lcd_addr), .lcd_data_o(lcd_data) ); ``` ### 生成长方形 在这个系统中，CPU主要负责图形的“渲染”，这个在大型系统中常常是GPU来做的。 这里描述有点夸张了，其实所谓的“渲染”就是画个长方形，CPU 根据 C代码中的顶点坐标，把对应的显存地址填入1或者0。所封装的画实心的API如下 ```c void draw_rectangle(uint8_t top_x, uint8_t top_y, uint8_t btm_x, uint8_t btm_y) { uint8_t i,j; uint8_t calc_x; uint8_t calc_y; calc_x top_x/32; calc_y top_y/32; for(i 0; i<Y_MAX; i++) for(j 0; j<X_MAX; j++) { if(j> calc_x && j< calc_y && i> top_y && i< btm_y) PCIO_AHBSRAM >SRAM[i*X_MAX+j] RGB; } } ``` ### 例化 LCD CPU 运行起来后，会根据 C代码 访问 AHB总线，发出读写命令。自定义的 AHB2BRAM 模块，会将总线地址转换成显存地址进行数据读写。将绘制的图形保存在显存中，只要不掉电，就不会丢失。同时，LCD IP 只负责从显存中取数据，按照行场扫描的时序，就可以完完整整的将图形显示在LCD屏幕上了，LCD IP 的接口如下。 ```verilog VGAMod VGAMod ( .nRST(sys_rstn), .PixelClk(clk10), .lcd_rd_o(lcd_rd), .lcd_addr_o(lcd_addr), .lcd_data_i(lcd_data), .LCD_DE(LCD_DE), .LCD_HSYNC(LCD_HSYNC), .LCD_VSYNC(LCD_VSYNC), .LCD_B(LCD_B_t), .LCD_G(LCD_G_t), .LCD_R(LCD_R_t) ); ``` ### 结语 受限于资源，此文实现的系统只有 128Kbits 的显存，而笔者使用的 LCD 的分辨率是480*272，RGB565。如果需要存一幅完整图形需要将显存扩大16倍，似乎超过了Nano 9K板载的这颗FPGA极限。因此，选择折中，不去保存RGB565，而是简单的复制扩展保存的1bit信息到RGB565中，这样颜色深度无法达到65536，只支持红、绿、蓝和白四种颜色。 其实FPGA内封的PSRAM有 64Mbits，足够这块LCD的显存了。以后有机会可以尝试着用这些内存来运行一下 lvgl。 !"},"/hardware/zh/tang/Tang-Nano-9K/examples/softcore-1/softcore-1.html":{"title":"移植FatFS，为RISCV添加FAT32文件系统","content":"# 移植FatFS，为RISCV添加FAT32文件系统 > 编辑于2022.05.26 原文链接:https://bbs.sipeed.com/thread/1482 搬运有改动。 首先新建一个项目工程，选型时不要选错型号。 ## Gowin 相关设置 在 IP generator 生成中选择 Gowin_PicoRV32，软核最大可以跑到50MHz，这个频率做一些基本控制是绰绰有余的。 打开IP后，双击要修改的模块进行设置。 此处去掉了 RV32C 和 RV32M 指令集的扩展，关闭了Jtag debug功能。 然后是定制ITCM和DTCM，由于我选择将程序编译后直接放到ITCM中运行（MCU boot and run in ITCM），并且编译后的文件大约需要22KB，所以分给了ITCM 32KB的空间，DTCM保持默认16KB。 外设方面，启用UART来输出打印信息，SPI Master用于与SD卡通信，GPIO用来点灯。我还打开了AHB扩展，并在上面挂载了一片内存用于后续LCD的显存。 还需要调用PLL，为CPU提供50MHz的时钟，SD卡的读写速度也是50MHz，最后绑定好pin脚，生成FPGA的下载文件。 ## GMD 相关的操作 接下去的工作就要转到[GMD](http://www.gowinsemi.com.cn/prodshow.aspx)中了。参考半导体官方文档[IPUG910](http://cdn.gowinsemi.com.cn/IPUG910 1.4_Gowin_PicoRV32_IDE%E8%BD%AF%E4%BB%B6%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C.pdf)进行开发环境搭建和程序编译，外设的驱动编写可以参考[IPUG911](http://cdn.gowinsemi.com.cn/IPUG911 1.3_Gowin_PicoRV32%E8%BD%AF%E4%BB%B6%E7%BC%96%E7%A8%8B%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C.pdf)，最后程序的下载可以参考[IPUG913](http://cdn.gowinsemi.com.cn/IPUG913 1.4_Gowin_PicoRV32%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C.pdf)。 C的开发环境搭建完成后，就开始进行SD卡驱动和fatfs的移植，这里我将SD卡作为只读设备，编写了相应的驱动。 ### SD Command SD卡的通信，主要是通过Matser发送CMD命令进行的，驱动见下面代码。 ```c #define SPI_ID 0 uint8_t sd_sendcmd(uint8_t cmd, uint32_t arg, uint8_t crc) { uint8_t r1, cnt; cnt 0; wbspi_master_select_slave(PICO_WBSPI_MASTER,SPI_ID); wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); wbspi_master_txdata(PICO_WBSPI_MASTER,(cmd 0x40)); wbspi_master_txdata(PICO_WBSPI_MASTER,arg>>24); wbspi_master_txdata(PICO_WBSPI_MASTER,arg>>16); wbspi_master_txdata(PICO_WBSPI_MASTER,arg>>8); wbspi_master_txdata(PICO_WBSPI_MASTER,arg); wbspi_master_txdata(PICO_WBSPI_MASTER,crc); do{ r1 wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); cnt++; if(cnt > 50) break; }while(r1 0xFF); return r1; } ``` ### SD Init 基于上面这个函数，就开始编写SD卡初始化函数，初始化的流程为： 1、发送大于74个周期的时钟信号，等待SD卡内部逻辑稳定； 2、发送CMD0，让SD卡进入IDLE状态； 3、发送CMD8，查询卡的型号是不是支持SD 2.0协议； 4、这里只处理支持SD 2.0协议的卡，发送CMD55+ACMD41进行初始化； 5、发送CMD58，查询卡支不支持SDHC； 6、发送CMD9，CMD10，获取SD卡的CID和OCR信息 ```C uint8_t sd_init(void) { uint32_t i; uint8_t r1; uint8_t buff[16]; uint8_t cnt 0; wbspi_master_select_slave(PICO_WBSPI_MASTER,SPI_ID); for(i 0; i<1000; i++); for(i 0; i<10; i++) wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); r1 sd_sendcmd(0,0,0x95); r1 sd_sendcmd(8,0x1aa,0x87); if(r1 0x01) { buff[0] wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); buff[1] wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); buff[2] wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); buff[3] wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); do{ r1 sd_sendcmd(55,0,0); if(r1 ! 0x01) return 1; r1 sd_sendcmd(41,0x40000000,1); cnt++; if(cnt>100) return 1; }while(r1! 0); } r1 sd_sendcmd(58,0,0); if(r1 ! 0x00) return 1; buff[0] wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); buff[1] wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); buff[2] wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); buff[3] wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); if(buff[0]&0x40) printf(\"sdhc rdy\\r\\n\"); else printf(\"sd2.0 rdy\\r\\n\"); r1 sd_sendcmd(9,0,0xFF); if(r1 ! 0x00) return 1; do{ r1 wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); }while(r1 ! 0xFE); for(i 0; i<16; i++) { r1 wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); } r1 sd_sendcmd(10,0,0xFF); if(r1 ! 0x00) return 1; do{ r1 wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); }while(r1 ! 0xFE); for(i 0; i<16; i++) { r1 wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); } return 0; } ``` ### SD Read Block 下面是SD卡读单块和多块的驱动。 ```C BYTE SD_ReadSingleBlock(UINT sector, BYTE *buffer) { BYTE r1; WORD i; i 512; r1 sd_sendcmd(17, sector, 1); //发送CMD17 读命令 if(r1 ! 0x00) return r1; do{ r1 wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); }while(r1 ! 0xFE); while(i! 0) { *buffer wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); buffer++; i ; } wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); return 0; //读取正确，返回0 } BYTE SD_ReadMultiBlock(UINT sector, BYTE *buffer, BYTE count) { BYTE r1; WORD i; r1 sd_sendcmd(18, sector, 1); //读多块命令 if(r1 ! 0x00) return r1; while(count ! 0){ i 512; do{ r1 wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); }while(r1 ! 0xFE); while(i! 0) { *buffer wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); buffer++; i ; } buffer+ 512; count ; wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); } sd_sendcmd(12, 0, 1); //全部传输完成，发送停止命令 wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); if(count ! 0) return count; //如果没有传完，返回剩余个数 else return 0; } ``` ### FatFs File system SD卡驱动完成后，开始移植FatFs文件系统 源码下载：http://elm chan.org/fsw/ff/archives.html 选择最新的FatFs R0.14b ，并添加到工程。 FFConf.h用于FatFs的定制，这里需要将FF_FS_READONLY的宏改为1，将SD卡作为只读设备。 还需要改写diskio.c文件，适配SD卡。这里只做了最简单的适配，完成了初始化和读，查询状态和获取时间都是空函数。由于宏设置，这两个函数disk_ioctl和disk_write就不管了 ```C #define SD_CARD 0 DSTATUS disk_initialize ( BYTE pdrv /* Physical drive nmuber (0..) */ ) { DRESULT status STA_NOINIT; switch(pdrv) { case SD_CARD://SD卡 status sd_init(); break; default: status STA_NOINIT; } return status; } //获得磁盘状态 DSTATUS disk_status ( BYTE pdrv /* Physical drive nmuber (0..) */ ) { return 0; } //读扇区 //drv:磁盘编号0~9 //*buff:数据接收缓冲首地址 //sector:扇区地址 //count:需要读取的扇区数 DRESULT disk_read ( BYTE pdrv, /* Physical drive nmuber (0..) */ BYTE *buff, /* Data buffer to store read data */ DWORD sector, /* Sector address (LBA) */ UINT count /* Number of sectors to read (1..128) */ ) { DRESULT status RES_PARERR; if (!count)return RES_PARERR; //count不能等于0，否则返回参数错误 switch(pdrv) { case SD_CARD://SD卡 if(count 1) status SD_ReadSingleBlock(sector, buff); else status SD_ReadMultiBlock(sector, buff, count); break; default: status RES_PARERR; } return status; } DWORD get_fattime (void) { return 0; } ``` 最后进行测试，在SD卡的根目录放一个txt文件，然后RV32 CPU通过串口，将文件大小和内容打印出来。 ```C res f_mount(&fs, \"\", 1); res f_open(&file, \"top.txt\", FA_READ); printf(\"\\r\\nfile size:%d\\r\\n\", file.obj.objsize); f_read(&file, fbuff, file.obj.objsize, &br); printf(\"%s\\r\\n\",fbuff); f_close(&file); ```"},"/hardware/zh/tang/Tang-Nano-9K/examples/spi_lcd.html":{"title":"Spi_lcd","content":"# Spi_lcd 感谢群友提供的代码，前往 https://github.com/sipeed/TangNano 9K example/tree/main/spi_lcd 查看详情，相关说明会在整理之后展示。 ![spi_lcd](./../nano_9k/spi_lcd.jpg)"},"/hardware/zh/tang/Tang-Nano-9K/examples/lcd_constrains.html":{"title":"LCD Pin Constrain content","content":"# LCD Pin Constrain content 直接把下面的内容复制进\".cst\"文件即可 Copt the following content into the \".cst\" file ``` IO_LOC \"LCD_B[4]\" 41; IO_PORT \"LCD_B[4]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_B[3]\" 42; IO_PORT \"LCD_B[3]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_B[2]\" 51; IO_PORT \"LCD_B[2]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_B[1]\" 53; IO_PORT \"LCD_B[1]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_B[0]\" 54; IO_PORT \"LCD_B[0]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_G[5]\" 55; IO_PORT \"LCD_G[5]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_G[4]\" 56; IO_PORT \"LCD_G[4]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_G[3]\" 57; IO_PORT \"LCD_G[3]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_G[2]\" 68; IO_PORT \"LCD_G[2]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_G[1]\" 69; IO_PORT \"LCD_G[1]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_G[0]\" 70; IO_PORT \"LCD_G[0]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_R[4]\" 71; IO_PORT \"LCD_R[4]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_R[3]\" 72; IO_PORT \"LCD_R[3]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_R[2]\" 73; IO_PORT \"LCD_R[2]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_R[1]\" 74; IO_PORT \"LCD_R[1]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_R[0]\" 75; IO_PORT \"LCD_R[0]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_DEN\" 33; IO_PORT \"LCD_DEN\" IO_TYPE LVCMOS33; IO_LOC \"LCD_SYNC\" 34; IO_PORT \"LCD_SYNC\" IO_TYPE LVCMOS33; IO_LOC \"LCD_HYNC\" 40; IO_PORT \"LCD_HYNC\" IO_TYPE LVCMOS33; IO_LOC \"LCD_CLK\" 35; IO_PORT \"LCD_CLK\" IO_TYPE LVCMOS33; IO_LOC \"XTAL_IN\" 52; IO_PORT \"XTAL_IN\" IO_TYPE LVCMOS33 PULL_MODE NONE; IO_LOC \"nRST\" 4; ```"},"/hardware/zh/tang/Tang-Nano-9K/Tang-nano-9k.html":{"title":"Tang nano 9k 一些例程","content":" title: Tang nano 9k 一些例程 对于Programmer(下载程序)建议使用 https://dl.sipeed.com/shareURL/TANG/programmer 里面的文件。 下载后解压替换掉Gowin对应安装目录的Programmer文件夹即可。 不会替换的话可以在下载解压后的Programmer程序中手动添加对应下载文件来进行烧录。 [点灯例程](./examples/LED.html) [驱RGB屏教程](./examples/LCD.html) [PicoRV 在9K上运行的示例](./examples/picorv.html) litex在9K上使用示例：即将更新 使用软核驱动SPI屏幕：待更新 ~~FPGA驱动1.14寸SPI屏幕：待更新~~ HDMI显示例程：即将更新 驱动MIPI接口屏幕：待更新 其他（有什么想法可以提出来，可行的话或许会被采纳）"},"/hardware/zh/tang/Tang-Nano-9K/Nano-9K.html":{"title":"Tang Nano 9K","content":"# Tang Nano 9K > 编辑时间 2022年1月13日 ## 简介 Tang Nano 9K 是基于高云半导体 GW1NR 9 FPGA芯片设计的精简型开发板。它搭载的HDMI连接器、RGB接口屏幕连接器、SPI屏幕连接器、SPI FLASH和6个LED使得用户可以方便且快速地进行FPGA验证，RISC V软核验证和功能样机验证。GW1NR 9拥有的8640 LUT4 逻辑单元除了可以用来设计各种复杂的逻辑电路，还可以运行完整的PicoRV软核，满足了用户学习FPGA、验证软核和深度设计的各种需求。 ## 产品参数 类别 数值 逻辑单元(LUT4) 8640 寄存器(FF) 6480 分布式静态随机存储器 <br>SSRAM(bits) 17280 块状静态随机存储器 <br>B SRAM(bits) 468K 块状静态随机存储器数目<br>BSRAM（个） 26 用户闪存(bits) 608K PSRAM(bits) 64M 高性能DSP模块 支持9x9,18x18,36x36bit的乘法运算和54bit累加器 乘法器 <br>(18 x 18 Multiplier) 20 SPI FLASH 32M bits 灵活的PLL资源 2个锁相环（PLLs） 显示屏幕接口 HDMI接口, SPI屏幕接口和RGB屏幕接口 调试器 板载BL702芯片，为GW1NR 9提供USB JTAG下载和USB UART串口打印功能 IO • 支持4mA、8mA、16mA、24mA等驱动能力 <br>• 对每个I/O提供独立的Bus Keeper、上拉/下拉电阻及Open Drain输出选项 连接器 TF卡座子, 2x24P 2.54mm 排针焊盘 按键 2个用户可编程按键 LED 板载6个可编程LED ### 板载功能框图 ![Generated](./assets/clip_image008.jpg) ### 板子引脚图 ![Generated](./assets/clip_image010.gif) ## 前代对比 Tang Nano 9K 是 Sipeed 所推出的第五款 FPGA 开发板，与在售前代产品参数对比如下： 版型 Tang Nano 1K Tang Nano 4K Tang Nano 9K : : : : 外观图 <img src \"./../../../zh/tang/Tang Nano/assets/clip_image002.gif\" width \"180\" > <img src \"./../../../zh/tang/Tang Nano/assets/clip_image004.gif\" width \"180\" > <img src \"./../../../zh/tang/Tang Nano/assets/clip_image006.gif\" width \"180\" > 逻辑单元 (LUT4) 1152 4608 8640 硬核处理器 Cortex M3 板载晶振 27MHZ 27MHZ 27MHZ 屏幕接口 RGB 屏幕接口 HDMI 接口 HDMI 接口, <br>RGB 屏幕接口,<br>SPI 屏幕接口 摄像头接口 默认 OV2640 外部存储 仅预留焊盘 32Mbits SPI flash 32Mbits SPI flash TF 卡槽 有 下载器 板载 USB JTAG 板载 USB JTAG 板载 USB JTAG & USB UART ## 适用人群 用法 FPGA MCU FPGA+MCU : : : : 语言 Verilog HDL/Verilog C/C++ Verilog HDL/Verilog ， C/C++ 简介 上板验证用户HDL 用户将软核的比特流文件下载到芯片后可将<br>GW1NR 9当做普通的MCU来使用 烧入软核后可以进行双核开发 适用人群 初学者，FPGA开发者 RISC V开发者，Cortex M开发者 资深软硬件工程师 ## 上手指引 1. 安装IDE和填写正确的License：[点击这里](https://wiki.sipeed.com/soft/Tang/zh/Tang Nano Doc/get_started/install the ide.html) 2. 阅读：[SUG100 2.6_Gowin云源软件用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG100 2.5_Gowin%E4%BA%91%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) 3. 阅读这个[教程](./examples/LED.html)完成点灯实验。 建议新手在完成这一步之后，自己重新独立新建项目、编写代码，完成这个实验，并且按自己的想法修改点灯程序，增强对FPGA和硬件描述语言的理解。 建议在这个过程阅读以下内容，阅读完才进入下一步： Verilog代码规范（自行搜索，从初学就培养良好的代码规范是非常必要的） 下面的这些内容对于初学者来说是非常有用的，对未来深入学习 FPGA 很有帮助。 [SUG100 2.6_Gowin云源软件用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG100 2.6_Gowin%E4%BA%91%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) [SUG949 1.1_Gowin_HDL编码风格用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG949 1.1_Gowin_HDL%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) <a href \"http://cdn.gowinsemi.com.cn/UG286 1.9.1_Gowin%E6%97%B6%E9%92%9F%E8%B5%84%E6%BA%90(Clock)%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf\">UG286 1.9.1_Gowin时钟资源(Clock)用户指南.pdf</a> [SUG940 1.3_Gowin设计时序约束用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG940 1.3_Gowin%E8%AE%BE%E8%AE%A1%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) [SUG502 1.3_Gowin_Programmer用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG502 1.3_Gowin_Programmer%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) [SUG114 2.5_Gowin在线逻辑分析仪用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG114 2.5_Gowin%E5%9C%A8%E7%BA%BF%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90%E4%BB%AA%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) 上面的都已经打包进了下载站[点我跳转](https://dl.sipeed.com/shareURL/TANG/Nano%209K/6_Chip_Manual/CN/%E9%80%9A%E7%94%A8%E6%8C%87%E5%BC%95)。可以点击压缩包全都下载下来 其他学习链接： + 在线免费教程：[菜鸟教程](https://www.runoob.com/w3cnote/verilog tutorial.html)（学习Verilog） + 在线免费FPGA教程：[Verilog](https://www.asic world.com/verilog/index.html) + 在线高云半导体官方视频教程：[点击这里](http://www.gowinsemi.com.cn/video_complex.aspx?FId n15:15:26) 1. 按照这个[教程](./examples/LCD.html)进行5寸RGB屏驱动实验（其他尺寸屏幕自行修改一下）。 如果用户自行无法完成这个实验，可以下载我们[9K例程](https://github.com/sipeed/TangNano 9K example)（适配9K板子+5寸屏）查看哪个步骤没做正确 注意：屏幕接线时需要注意排线的1脚对应连接器旁的1脚丝印 需要阅读的文档： rPLL IP核的说明文档：在IDE里>Tools>IP Core Generator>Hard Module>CLOCK>rPLL>点击弹出界面右下角的Help按键就会弹出说明文档 <details> <summary><font color \"#4F84FF\">点开查看说明位置</font></summary> <img src \"./../assets/ip reference.png\"> </details> SUG284 2.1E_Gowin IP Core Generator User Guide.pdf [5寸屏规格书](https://dl.sipeed.com/fileList/TANG/Nano%209K/6_Chip_Manual/EN/LCD_Datasheet/5.0inch_LCD_Datashet%20_RGB_.pdf)：(主要是获取CLK是33.3Mhz这个信息) ## 例程汇总 访问 [相关例程](./../Tang Nano Doc/examples.html) 查看所有说明 ## 硬件资料 [规格书](https://dl.sipeed.com/shareURL/TANG/Nano%209K/1_Specification) [原理图](https://dl.sipeed.com/shareURL/TANG/Nano%209K/2_Schematic) [位号图](https://dl.sipeed.com/shareURL/TANG/Nano%209K/3_Bit_number_map) [尺寸图](https://dl.sipeed.com/shareURL/TANG/Nano%209K/4_Dimensional_drawing) [3D 模型文件](https://dl.sipeed.com/shareURL/TANG/Nano%209K/5_3D_file) [部分手册](https://dl.sipeed.com/shareURL/TANG/Nano%209K/6_Chip_Manual) 硬件资料总链接：[点击这里](https://dl.sipeed.com/shareURL/TANG/Nano%209K) ## 注意事项 1. 如果有什么疑问，欢迎加群 `834585530`, 或者直接在本页下方留言讨论。 2. 有问题的话先去 [常见问题](https://wiki.sipeed.com/hardware/zh/tang/Tang Nano Doc/questions.html) 自查。 3. 避免使用JTAG、MODE、DONE等引脚。如果一定要使用这些引脚，请查看 [UG292 1.0原理图指导手册](http://cdn.gowinsemi.com.cn/UG293 1.0_GW1NZ%E7%B3%BB%E5%88%97FPGA%E4%BA%A7%E5%93%81%E5%8E%9F%E7%90%86%E5%9B%BE%E6%8C%87%E5%AF%BC%E6%89%8B%E5%86%8C.pdf) 4. 请注意避免静电打到PCBA上；接触PCBA之前请把手的静电释放掉 5. 每个GPIO的工作电压已经在原理图中标注出来，请不要让GPIO的实际工作的电压超过额定值，否则会引起PCBA的永久性损坏 6. 在连接FPC软排线的时候，请确保排线无偏移、完整地插入到排线中，且线序正确没有接反 7. 请在上电过程中，避免任何液体和金属触碰到PCBA上的元件的焊盘，否则会导致短路，烧毁PCBA 8. 使用途中需要注意复用的 IO，比如 HDMI 的 IO 默认被外部上拉，因此在排针上使用相关引脚的时候可能会与自己想要的结果不符。 ![nano_9k_hdmi_io](./assets/nano_9k_hdmi_io.png)"},"/hardware/zh/tang/Tang-Nano-4K/examples/HDMI.html":{"title":"","content":""},"/hardware/zh/tang/Tang-Nano-4K/examples/LED.html":{"title":"Nano 4K 点灯","content":" title: Nano 4K 点灯 > 编辑于2022年3月31日 点灯简单示例 ## 新建项目 新建工程：File >NEW >FPGA Design Project >OK ![](./../../Tang Nano/assets/LED 1.png) 弹出的选项框选择存储路径和工程名称（路径和文件名称要求是英文路径） ![](./../../Tang Nano/assets/LED 2.png) 选择对应的型号： ![Tang_nano_4k_device_choose](./../assets/Nano_4K_device_choose.png) 可能有部分板子主控芯片型号为 C7/I6 ，用户自行选择一下即可 ## 编写代码 新建工程之后接下来进行代码编辑，在Design工作栏内新建“Verilog File”,如下图所示： ![](./../../Tang Nano/assets/LED 5.png) 为文件命名（要求写英文名，不然后续综合很容易报错）； 一般来说文件名称应该和文件内容模块名称相同 ![](./../../Tang Nano/assets/LED 6.png) 双击文件，可以在右侧的编辑框中进行代码的编写。 ![](./../../Tang Nano/assets/LED 7.png) 以点灯为例，将下方的 示例代码 粘贴到自己的文件中，也可以自己编写自己的代码。 ```verilog module led ( input sys_clk, input sys_rst_n, // reset input output reg led // LED ); reg [23:0] counter; //定义一个变量来计数 always @(posedge sys_clk or negedge sys_rst_n) begin // Counter block if (!sys_rst_n) counter < 24'd0; else if (counter < 24'd1349_9999) // 0.5s delay counter < counter + 1'b1; else counter < 24'd0; end always @(posedge sys_clk or negedge sys_rst_n) begin // Toggle LED if (!sys_rst_n) led < 1'b1; else if (counter 24'd1349_9999) // 0.5s delay led < ~led; // ToggleLED end endmodule ``` ## 综合、约束、布局布线 ### 综合 保存编辑的代码后转到“Process”界面下，对编辑好的代码进行综合，即双击“Synthesize” ![](./../../Tang Nano 9K/nano_9k/nano_9k_synthsize.png) 运行之后如没有报错而且 Synthesize 变成下图里的图标 ![](./../../Tang Nano/assets/LED.png) 说明前面编辑的代码无误；如果有错，根据错误提示进行改正即可。 ### 约束 此处未涉及时钟约束 想让 Fpga 实现代码的功能，必须将代码中涉及的 端口 绑定到 Fpga 实际的引脚上。 如下图，在左边的工作区点击 process，然后双击 FloorPlanner ![](./../../assets/examples/led_pjt_2.png) 在工程中第一次点击，可能会提示说创建文件，点击确定即可 ![](./../../Tang Nano/assets/LED 9.png) nano 4k的rgb led电路图如下所示 ![](./../assets/LED_Pin.png \"nano 4k rgb pins\") port I/O pin desc sys_clk input 45 时钟输入脚 sys_rst_n input 15 系统复位脚 led output 10 红灯 对于交互式管脚约束有下图中的两种方法 将对应的端口拖拽到芯片引脚上 在IO约束中输入端口对应的引脚编号 因此对应在管脚约束里的内容应该如下图 ![Led floorplanner](./../assets/LED_FloorPlanner.png) 关于 FloorPlanner 更多的相关说明，可以参考 [SUG935 1.3_Gowin设计物理约束用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG935 1.3_Gowin%E8%AE%BE%E8%AE%A1%E7%89%A9%E7%90%86%E7%BA%A6%E6%9D%9F%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf)。里面的内容都很有用 完成之后记得保存一下 LED对应的IO10默认是mode Pin，无法直接约束，需要在顶部菜单栏 Project > Configuration >Palse&Route > Dual Purpose Pin, 勾选 Use MODE as regular IO,如下图 <img src \"./../tang/assets/../../../assets/Nano 4K/4K led 2.png\" alt \"image 20210810161934170\" style \"zoom:50%;\" /> ### 布局布线 完成脚约束后，接下来进行布局布线操作。 ![Place&&Route](./../assets/Place&Route.png) > 失败的话请从头再来一遍 ## 烧录到开发板 成功完成上面步骤后就已经生成高云半导体的比特流文件了，可以进行下面的步骤来将文件烧录到板子了。 接下来是连接板子，烧录固件，可参照下图选择版型： ![](./../assets/nano_4k_device_scan.png) 在Process界面双击`Program Device` 后打开烧录工具 ![](./../assets/Open_Programmer.png) 接下来选择 SRAM下载 即可验证程序。有固化需求的自行选择烧录到flash ![](./../assets/Programmer_device.png) <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano-4K/Nano-4K.html":{"title":"Tang Nano 4K ","content":"# Tang Nano 4K ## Tang Nano 4K 开发板 Tang Nano 4K是基于[高云半导体](http://www.gowinsemi.com.cn/)的小蜜蜂系列 GW1NSR LV4C 设计的简约型开发板。开发板设计小巧精致，将芯片的所有资源都引出，板载Type C、USB JTAG、DVP、HDMI座子及其电路等，并把所有IO资源引出，方便开发者拓展使用，非常适用于小型数字逻辑的设计和实验。 ![Tang Nano 4K](./../Tang Nano/assets/4k 1.jpg) ![Tang Nano 4K](./../Tang Nano/assets/4k 2.jpg) ## 产品参数 Tang Nano 4K开发板板载的GW1NSR LV4C，是一款系统级封装芯片，内部集成了GW1NS系列可编辑逻辑器件产品和PSRAM存储芯片。 下表为与前代同系列产品对比图 型号 Tang Nano Tang Nano 4K FPGA芯片 GW1N 1 LV GW1NSR LV4C 逻辑单元 1152 4608 寄存器 864 3456 硬核处理器 无 Coetex M3 Block SRAM(bits) 72K 180K 用户闪存(bits) 96K 256K 锁相环PLL 1 2 I/O Bank 总数 4 4 最多用户I/O数 41 44 显示屏接口 标准40P RGB LCD接口 HDMI接口 摄像头接口 None 常见的DVP顺序接口 尺寸 58.4mm\\*21.3mm 60mm\\*22.86mm 下载接口 USB Type C接口 USB Type C接口 ### 引脚图 ![Pinmap](./../Tang Nano/assets/Tang_nano_4K_0813.png) ## 开发环境 安装 IDE [点我](https://wiki.sipeed.com/hardware/zh/tang/Tang Nano Doc/get_started/install the ide.html) ## 下载方式 Tang Nano 4K 开发板板载 BL702 芯片，为 GW1NSR 4C 提供 JTAG 调试功能，可以直接使用 IDE 里面的 Programmer 软件来下载固件到 FPGA。 ## 资料 [规格书](https://dl.sipeed.com/shareURL/TANG/Nano%204K/HDK/01_Specification) [原理图](https://dl.sipeed.com/shareURL/TANG/Nano%204K/HDK/02_Schematic) [点位图](https://dl.sipeed.com/shareURL/TANG/Nano%204K/HDK/03_Bit%20number%20map) [尺寸图](https://dl.sipeed.com/shareURL/TANG/Nano%204K/HDK/04_Dimensional%20drawing) [3D 文件](https://dl.sipeed.com/shareURL/TANG/Nano%204K/HDK/05_3D%20file) [芯片手册](https://dl.sipeed.com/shareURL/TANG/Nano%204K/HDK/06_Chip%20Manual) [相关例程](https://wiki.sipeed.com/hardware/zh/tang/Tang Nano Doc/examples.html) ## 补充 1. 如果有什么疑问，欢迎加群 `834585530`, 或者直接在本页下方留言讨论。 2. 有问题的话先去 [常见问题](https://wiki.sipeed.com/hardware/zh/tang/Tang Nano Doc/questions.html) 自查。 3. 对于 Cortex M3 硬核建议使用串口来打印调试信息来纠错，或者有能力的可以选择其他方式。 4. 对于板子上面的 IO 引脚使用，需要注意与 HDMI 引脚复用的 IO，可能因为外部上拉而导致排针上与 HDMI 复用的 IO 所表现的实际结果与自己想要的不符合。 ![nano_4k_hdmi_io](./assets/nano_4k_hdmi_io.png)"},"/hardware/zh/tang/Tang-Nano-4K/Tang-nano-4k.html":{"title":"Tang nano 4k 一些例程","content":" title: Tang nano 4k 一些例程 对于Programmer(下载程序)建议使用 https://dl.sipeed.com/shareURL/TANG/programmer 里面的文件。 下载后解压替换掉Gowin对应安装目录的Programmer文件夹即可。 不会替换的话可以在下载解压后的Programmer程序中手动添加对应下载文件来进行烧录。 参考工程[git仓库](https://github.com/sipeed/TangNano 4K example) 接好摄像头和HDMI显示器之后，将这个工程烧录到开发板上可以看到相应的现象。 [点灯例程](./examples/LED.html) HDMI显示工程：https://github.com/sipeed/TangNano 4K example/tree/main/camera_hdmi/project 摄像头内容显示在HDMI工程：https://github.com/sipeed/TangNano 4K example/tree/main/camera_hdmi/project Cortex m3点灯：待更新 Cortex m3串口通信：待更新 其他（有什么想法可以提出来，合适的话会被采纳）"},"/hardware/zh/longan/index.html":{"title":"Longon 开发板","content":"# Longon 开发板 龙眼系列开发板是sipeed基于国产mcu芯片来设计的板子。方便与MCU开发者快速上手使用免于设计板子的麻烦。"},"/hardware/zh/longan/Zero/index.html":{"title":"","content":"敬请期待"},"/hardware/zh/longan/One/index.html":{"title":"","content":"敬请期待"},"/hardware/zh/longan/Nano/examples/printf.html":{"title":"串口打印","content":"串口打印 很多时候，串口打印都是一个非常方便的调试手段，通过串口打印的信息，可以方便的定位程序错误位置 本文基于 longan nano 演示如何实现 printf 通过串口打印 本文选择串口0作为串口打印信息的端口，外设使用前，自然需要进行初始化 ```c void init_uart0(void) {\t \t/* enable GPIO clock */ rcu_periph_clock_enable(RCU_GPIOA); /* enable USART clock */ rcu_periph_clock_enable(RCU_USART0); /* connect port to USARTx_Tx */ gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_9); /* connect port to USARTx_Rx */ gpio_init(GPIOA, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_10); \t/* USART configure */ usart_deinit(USART0); usart_baudrate_set(USART0, 115200U); usart_word_length_set(USART0, USART_WL_8BIT); usart_stop_bit_set(USART0, USART_STB_1BIT); usart_parity_config(USART0, USART_PM_NONE); usart_hardware_flow_rts_config(USART0, USART_RTS_DISABLE); usart_hardware_flow_cts_config(USART0, USART_CTS_DISABLE); usart_receive_config(USART0, USART_RECEIVE_ENABLE); usart_transmit_config(USART0, USART_TRANSMIT_ENABLE); usart_enable(USART0); usart_interrupt_enable(USART0, USART_INT_RBNE); } ``` 这里首先的开启了端口时钟和串口时钟，在初始化完管脚后，就进行了串口的功能配置 我们一般比较关心的就是串口的波特率，这里设置成了 115200 然后我们还需要重新实现 _put_char ，将 printf 重映射 ```c int _put_char(int ch) { usart_data_transmit(USART0, (uint8_t) ch ); while ( usart_flag_get(USART0, USART_FLAG_TBE) RESET){ } return ch; } ``` 这样就可以快乐的使用 printf 了"},"/hardware/zh/longan/Nano/examples/badapple.html":{"title":"Bad Apple 演示视频","content":"Bad Apple 演示视频 本文目的是使用板载的 160*80 分辨率的 OLED 屏幕播放 bad apple 视频 ## 主要工作介绍 + 移植 OLED 屏幕的驱动 + 移植 tf 卡驱动和 fatfs 文件系统 + 将视频按自己需要的帧率转换为一帧帧的图片然后打包到 tf 卡 + 在 gd32v 上读取 tf 卡中的图片并进行显示 ### 屏幕驱动 使用硬件 SPI 驱动屏幕，首先需要初始化 SPI ```c void spi_config(void) { spi_parameter_struct spi_init_struct; /* deinitilize SPI and the parameters */ OLED_CS_Set(); spi_struct_para_init(&spi_init_struct); /* SPI0 parameter config */ spi_init_struct.trans_mode SPI_TRANSMODE_FULLDUPLEX; spi_init_struct.device_mode SPI_MASTER; spi_init_struct.frame_size SPI_FRAMESIZE_8BIT; spi_init_struct.clock_polarity_phase SPI_CK_PL_HIGH_PH_2EDGE; spi_init_struct.nss SPI_NSS_SOFT; spi_init_struct.prescale SPI_PSC_8; spi_init_struct.endian SPI_ENDIAN_MSB; spi_init(SPI0, &spi_init_struct); \tspi_crc_polynomial_set(SPI0,7); \tspi_enable(SPI0); } ``` 初始化完成后就可以实现数据指令的发送 ```c void LCD_Writ_Bus(u8 dat) { \tOLED_CS_Clr(); \twhile(RESET spi_i2s_flag_get(SPI0, SPI_FLAG_TBE)); spi_i2s_data_transmit(SPI0, dat); \twhile(RESET spi_i2s_flag_get(SPI0, SPI_FLAG_RBNE)); spi_i2s_data_receive(SPI0); \tOLED_CS_Set(); } void LCD_WR_DATA8(u8 dat) { \tOLED_DC_Set();//写数据 \tLCD_Writ_Bus(dat); } void LCD_WR_DATA(u16 dat) { \tOLED_DC_Set();//写数据 \tLCD_Writ_Bus(dat>>8); \tLCD_Writ_Bus(dat); } void LCD_WR_REG(u8 dat) { \tOLED_DC_Clr();//写命令 \tLCD_Writ_Bus(dat); } ``` `LCD_Writ_Bus` 完成了 SPI 的收发，通过控制命令数据线，完成命令和数据的发送 OLED 屏幕在使用前还需要设置它的一些参数，比如屏幕开启、数据帧的格式等等，这些在参数在屏幕初始化的时候，通过写命令再写数据的方式写入。想修改这些参数需要依靠屏幕配套的数据手册，不过一般可以参数屏幕生产商提供的例程中的参数。 ### tf 卡驱动和 fatfs 文件系统 tf 卡在 longan 上也是使用 SPI 驱动的。为了更快的访问速率，也是使用硬件 SPI 驱动。使用前也需要初始化，方式和屏幕的 SPI 初始化类似，就不再累述。 fatfs 是一个专为小型嵌入式设备设计的文件系统。fatfs 符合 ANSI C(C89)规范，并且和磁盘 I/O 层完全分离。 具体的移植也很简单，直接参照 fatfs 提供的 stm32 的工程移植进行 这里提供该工程的[下载地址](http://dl.sipeed.com/LONGAN/Nano/Firmware/badapple_demo_tools/ffsample.7z)，完整版可以去 fatfs 的[官网下载](http://elm chan.org/fsw/ff/ffsample.zip) 主要的工作在于实现 fatfs 的几个基本函数 `disk_initialize` `disk_status` `disk_read` `disk_ioctl` 这些函数又是基于 SPI 通信的，还需要修改 SPI 接收发送的实现 ```c static BYTE xchg_spi ( \tBYTE dat\t/* Data to send */ ) { \twhile(RESET spi_i2s_flag_get(SPI1, SPI_FLAG_TBE)); spi_i2s_data_transmit(SPI1, dat); \twhile(RESET spi_i2s_flag_get(SPI1, SPI_FLAG_RBNE)); return(spi_i2s_data_receive(SPI1)); /* Return received byte */ } static void rcvr_spi_multi ( \tBYTE *buff,\t\t/* Pointer to data buffer */ \tUINT btr\t\t/* Number of bytes to receive (even number) */ ) { \tdo \t{ \t\t*buff xchg_spi(0xff); \t\tbuff++; \t} while (btr ); } ``` ### 视频预解码 mp4 格式的视频，单片机因为没有硬件的加速，无法胜任解码播放的工作，所以只能靠手工预解码，相当于按照一定的帧率对原视频进行截图 这里需要使用到 PotPlayer XnViewMP 首先使用 PotPlayer 打开视频，快捷键 ctrl+G 打开连续截图 打开后如图 ![](./../assets/examples/potplayer.png) 其中格式一定要 BMP，尺寸按照屏幕的尺寸设置，时间我这里设置的是 100ms 也就是 1s 十帧的样子，采集数量就自己计算一下视频总时间再乘每秒帧数，我这里就是 219s * 10 2190 最后得到的图片是 32位 的 BMP，转换起来不方便，就用 XnViewMP 转换为 24位 的 BMP 打开 XnViewMP ，选择要转换的图片，快捷键 ctrl+U 打开批量转换，在动作中选择 24位 进行转换，如图 ![](./../assets/examples/XnViewMP.png) 然后就是将这些图片打包到 tf 卡，这里为了方便，修改了网上的一个开源项目 [bmp2hex](https://github.com/robertgallup/bmp2hex)，重新整理了一个工具，可以[点击下载](http://dl.sipeed.com/LONGAN/Nano/Firmware/badapple_demo_tools/tools_bmp2hex.zip) 使用方法很简单，把下载的这个压缩包放到之前生成的图片集中，进行解压 使用工具前需要确保所有图片的名字是 数字.bmp ，不是的话可以先运行一遍 rename.py 这个脚本，直接在命令行输入 `python rename.py` 即可 根据自己图片总数修改 genhex.py 这个脚本的第4行中的数字，比如我有 2190张 图片，这里的数字就写 2190 然后就运行这个脚本，在命令行输入 `python genhex.py`，时间可能比较久，需要耐心等待 最后运行完毕后会生成一个 bmp.bin 文件，将这个文件放入到 tf 卡中即可 ### 读取图片 最后的读取图片并显示其实很简单了，主要涉及到的就是文件操作，关于 fatfs 的 API [可以点击这里阅读](http://elm chan.org/fsw/ff/doc/open.html) 首先需要将 tf 卡挂载到文件系统，这里需要使用到 f_mount 这个函数 ```c fr f_mount(&fs, \"\", 1); ``` 挂载上后，就找到对应的文件然后打开，这里涉及到 f_open ```c fr f_open(&fil, \"bmp.bin\", FA_READ); ``` 文件打开后，就可以读取图片信息并显示了，这里 160*80 尺寸的 16位真彩图片，一张有 25600 字节，longan 上的处理器无法直接创建一个这么大的数组，所以只能分两次进行读取，每次读取完进行一次偏移，最后通过循环读取总共的 2189 张图片，这里涉及到 f_read f_lseek ```c for (int i 0; i<2189;i++) { fr f_read(&fil, image, sizeof(image), &br); LCD_ShowPicture(0,0,159,39); offset + 12800; f_lseek(&fil, offset); LEDB_TOG; fr f_read(&fil, image, sizeof(image), &br); LCD_ShowPicture(0,40,159,79); offset + 12800; f_lseek(&fil, offset); LEDB_TOG; } ``` 最后，本工程可以到 github 下载体验，[点击进行传送](https://github.com/sipeed/Longan_GD32VF_examples)"},"/hardware/zh/longan/Nano/Longan_nano.html":{"title":"Longan nano ","content":"# Longan nano ## 介绍 Longan Nano是基于兆易创新(GigaDevice)的GD32VF103CBT6(RISC V架构)芯片设计的极简开发板。开发板将芯片所有IO引出，设计小巧精致，板载Type C、LCD、SD卡、JTAG等接口，方便广大学生、工程师、极客爱好者们接触学习最新一代的 RISC V处理器。 ![Longan_nano_pin](./../../../assets/Longan/nano/Longan_nano.124.jpg) ## 参数 项目 参数 CPU 基于 RISC V 32 位内核的 GD32VF103CBT6 内核功耗 仅传统 Cortex M3 的 1/3 存储 128KB Flash, 32KB SRAM 外设 4 x general purpose 16 bit timer, 2 x basic 16 bit timer, 1 x advanced 16 bit timer,<br>Watchdog, RTC, Systick<br>3 x USART, 2 x I2C, 3 x SPI, 2 x I2S, 2 x CAN, 1 x USBFS (OTG), 2 x ADC (10 channel), 2 x DAC 按键 1 个复位按键和 1 个 BOOT 按键（连接到 GPIO） 屏幕接口 SPI 接口（标配 0.96 寸 160x80 RGB IPS LCD） 存储接口 板载 TF 卡座子 调试接口 2x4 排针引出 JTAG 调试接口和串口 晶振 8MHz 无源晶振 + 32.768KHz RTC 无源晶振 LED 板载 1 个 RGB LED GPIO 数量 2 引出 28 个 GPIO 到排针 ### 新版照片 ![](./../../../assets/Longan/nano/Longan nano_PINOUT.svg) ![](./../../../assets/Longan/nano/longan nano 1.png) ### 旧版照片 ![](./../../../assets/Longan/nano/longan_nano_pinout_old.png) ![](./../../../assets/Longan/nano/longan nano old.png) ## 使用 [Longan使用](/soft/longan/zh/readme.md) ## 产品技术支持 Longan Nano 开发板可以在多种场景实现客户不同方面的需要，在 AIoT 上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务 <support@sipeed.com>。"},"/hardware/zh/longan/Nano/get_started/rv-link.html":{"title":"使用 RV-LINK","content":"使用 RV LINK ## 什么是 RV LINK **RV LINK** 是一个基于 RISC V 开发板的仿真器固件，通过烧写 **RV LINK** 固件， 可以将 **Sipeed Longan Nano** 开发板变成一个 `jtag` 调试器，用来调试另一块 Longan 或者其他支持 jtag 调试的开发板。 RV LINK 项目地址: [https://gitee.com/zoomdy/RV LINK](https://gitee.com/zoomdy/RV LINK) ## 烧写 RV LINK 固件 ### 使用 PlatformIO 工程一键烧录 * 下载 RV LINK 源码 项目源码下载地址：[http://dl.sipeed.com/LONGAN/Nano/Tools/RV LINK pio src v0.1.zip](http://dl.sipeed.com/LONGAN/Nano/Tools/RV LINK pio src v0.1.zip) 也可以从RV LINK官方项目下载: [https://gitee.com/zoomdy/RV LINK](https://gitee.com/zoomdy/RV LINK) * 使用 VSCODE 打开工程目录 将上面下载的源码解压到单独的文件夹 然后使用 VSCODE 打开源码文件夹 如下图所示： ![](./../assets/pio_open_rvlink.png) 通常使用 DFU 方式烧录固件，**不需要**修改配置文件。(使用 DFU 方式下载请安装 libusb 驱动, 参考[使用Zadig安装驱动](blink.md/#使用zadig安装驱动)) 如果需要更改烧录方式，可以通过修改 `platformio.ini` 文件来修改， 具体配置方式请参考：[修改工程配置文件](blink.md/#工程配置文件) * 使用 PIO 烧录固件 连接开发板，使开发板进入烧录模式后，点击左下角的箭头符号即可进行烧录。 烧录成功后，可以看到开发板上的绿灯闪烁，将开发板连接到电脑USB口之后，可以在设备管理器中看到多出了一个串口设备。此时 Longan 板子就成功变成了 RV LINK 调试器。 ### 其他烧录方式 参考文档： [将 Longan Nano 开发板变成 RISC V 仿真器](https://gitee.com/zoomdy/RV LINK/wikis/%E5%B0%86%20Longan%20Nano%20%E5%BC%80%E5%8F%91%E6%9D%BF%E5%8F%98%E6%88%90%20RISC V%20%E4%BB%BF%E7%9C%9F%E5%99%A8) ## 使用 RV LINK 调试 ### 连接开发板 将刷好 RV LINK 固件的开发板与待调试开发板 jtag 连线按下表连接 RV LINK 待调试开发板 : : : : JTDO JTDO JTDI JTDI JTCK JTCK JTMS JTMS 3V3 3V3 GND GND #### WIN7 用户安装 GD 串口驱动 见此链接[安装 USB 串口驱动](https://gitee.com/zoomdy/RV LINK/wikis/GDB%20%E4%BD%BF%E7%94%A8%20RV LINK%20%E4%BB%BF%E7%9C%9F%E5%99%A8%E8%B0%83%E8%AF%95%20RISC V%20%E7%A8%8B%E5%BA%8F?sort_id 1667650#%E5%AE%89%E8%A3%85 usb %E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8) ### 在 PlatformIO IDE 中使用 RV LINK RV LINK 在 PlatformIO IDE 可以和其他调试器一样，支持一键启动调试。 只需要在工程的 `platformio.ini` 配置文件中，指定调试器选项和调试器端口选项。 示例代码 ```ini [env:sipeed longan nano] platform gd32v framework gd32vf103 sdk board sipeed longan nano monitor_speed 115200 upload_protocol rv link ; rv link下载选项 debug_tool rv link ; rv link调试选项 debug_port COM2 ; 使用rv link 必填此项 调试器串口 ``` ### 在其他平台使用 RV LINK 参考 [RV LINK WIKI](https://gitee.com/zoomdy/RV LINK/wikis/)"},"/hardware/zh/longan/Nano/get_started/pio.html":{"title":"PIO 配置","content":"PIO 配置 ## 安装 VS CODE VS CODE 是一款比较常用的开发工具。前往[VScode官网](https://code.visualstudio.com/ \"VScode官网\")，下载安装对应操作系统版本的安装包即可。 ## 安装 PIO 插件 打开 VSCode > 点击左侧扩展 > 搜索 PlatformIO > 点击安装插件 > 等待安装完成 > 重启 VSCODE ![](http://blog.sipeed.com/wp content/uploads/2019/04/0d501a8515a735fba54e2f5de908cd1e.png) ## 安装 GD32V 平台定义 PIO 目前提供**命令行**与**图形界面**两种方式来安装。下面将分别介绍： （PS : 推荐命令行，因为能看到下载进度条。） ### 命令行 点击PIO图标 > 点击左下方的New Terminal > 在终端窗口中执行下面的安装指令 * 发布版 （稳定版本） ``` platformio platform install gd32v ``` * 开发版（与Github同步） ``` platformio platform install https://github.com/sipeed/platform gd32v ``` ![](./../assets/pio_install_gd32v.png) 注：受国内网络环境影响，安装过程需要较长时间，请耐心等待。 ### 图形界面 打开VS CODE > 点击左侧 PIO 图标 > 点击左下方的 Open 选项 > 点击 Platforms 页面 > 点击 Advanced Installation 打开添加窗口 ![](./../assets/pio_install_add_gd32v_step1.png) 在打开的窗口中输入下面的网址 ``` https://github.com/sipeed/platform gd32v.git ``` 点击 Install 即可添加完成。 ![](./../assets/pio_install_add_gd32v_step2.png) 耐心等待即可安装成功。 （安装失败多为网络原因， 请更换网络环境后再次尝试） ![](./../assets/pio_install_add_gd32v_step3.png)"},"/hardware/zh/longan/Nano/get_started/debug.html":{"title":"Debug 调试","content":"Debug 调试 ## 连接调试器 开发板 调试器 : : : : JTDO TDO JTDI TDI JTCK TCK JTMS TMS 3V3 3V3 GND GND ## 修改配置文件 修改工程配置文件 `platformio.ini`， 在下面添加 ```ini debug_tool jlink ``` 根据实际调试器型号选择。目前支持的调试器列表 * `jlink` * `gd link` * `ft2232` * `sipeed rv debugger` * `altera usb blaster` * `um232h` * `rv link` ## 一键调试 切换到 VS CODE 左侧的 `DEBUG` 界面， 点击绿色箭头即可进行调试。 ![](./../assets/pio_debug_longan.png)."},"/hardware/zh/longan/Nano/get_started/sipeed-debugger.html":{"title":"使用 Sipeed 调试器","content":" title: 使用 Sipeed 调试器 ## Sipeed rv debugger ## Sipeed rv debugger lite"},"/hardware/zh/longan/Nano/get_started/blink.html":{"title":"Blink 闪灯程序","content":" title: Blink 闪灯程序 ## 创建 Blink 工程 * 打开 PIO 主页 选择 `Project Examples` ![](http://blog.sipeed.com/wp content/uploads/2019/04/d977e844490e6ccc4625f701883a29f5.png) * 选择 `arduino blink` 点击 `Import` 导入示例程序 （初次导入需要下载架构文件及工具，需要等待较长时间） ![](http://blog.sipeed.com/wp content/uploads/2019/04/82943a6b74077e6210e2d9421cb5438f.png) * 导入成功后即可见到示例工程 ![](http://blog.sipeed.com/wp content/uploads/2019/04/1262373ca7b0b483e30dac1124adaabf.png) ## 工程配置文件 * 我们首先需要编辑工程配置文件 `platformio.ini` 根据自己的开发板型号，删掉其他开发板环境。 ![](./../assets/pio_ini_cfg.png) 配置示例 ```ini [env:sipeed longan nano] platform gd32v ;平台，选择gd32v framework arduino ;可选 gd32vf103 sdk 或 arduino board sipeed longan nano ; 开发板 monitor_speed 115200 ; 串口监视器波特率 upload_protocol serial ; 下载工具 默认串口， 可选 dfu、jlink、gd link 等 debug_tool jlink ; 调试工具 默认jlink ，可选 sipeed rv debugger 等 ``` PIO 可以在配置文件中实现设置宏定义， 控制编译流程等自定义功能，高级用法请参阅 [PIO 官方文档](https://docs.platformio.org/en/latest/projectconf.html). ## 一键编译 点击左下角的 `Build` 即可构建项目 ![](./../assets/pio_complie.png) ## 连接开发板 ### 串口 ISP 下载 * 准备 USB 转 串口下载器 * 连接开发板与下载器 * 修改 `platformio.ini` 文件， 添加下面一行内容： ```ini upload_protocol serial ``` * 开发板按住 `BOOT` 键，再按 `RESET` 键重启开发板后再松开 `BOOT` 键，进入下载模式。 ### JTAG 下载 * 准备J link 或 Sipeed RV 调试器 * 连接开发板 * 修改 `platformio.ini` 文件， 添加下面一行内容： ```ini upload_protocol jlink ``` 或者 ```ini upload_protocol sipeed rv debugger ``` ### USB DFU 下载 * **首次** 使用需要安装 libusb 驱动程序， 请参考此步骤 [使用 Zaidig 安装驱动](###使用zadig安装驱动). * 准备 USB Type c 数据线 * 使用数据线连接电脑与开发板 * 修改 `platformio.ini` 文件， 添加下面一行内容： ```ini upload_protocol dfu ``` * 开发板按住 `BOOT` 键，再按 `RESET` 键重启开发板后再松开 `BOOT` 键，进入 DFU 模式。 ## 一键下载 按照上面步骤选择好下载方式后，即可使用 PIO 内置工具一键下载。 点击左下角的 `Upload` 即可向开发板上传程序。 ![](./../assets/pio_upload.png) ### 使用Zadig安装驱动 PIO 内置 dfu util 下载工具，使用此工具需要为开发板安装 libusb 驱动。（注意： 与 GD 官方驱动不同） 建议通过 Zadig 安装 winusb 驱动。[下载地址](https://github.com/pbatard/libwdi/releases/download/b721/zadig 2.4.exe) 下载成功后打开 Zadig 在下拉栏中选择 GD32V， 替换驱动选择 WinUSB, 点击替换按钮，即可替换成功。 ![](./../assets/dfu_zadig.png) ### DFU 图形界面下载 下载DFU工具：<https://dl.sipeed.com/shareURL/LONGAN/Nano/Tools> 在里面找到 `GD32_MCU_Dfu_Tool_V3.8.1.5784_1.rar` 文件并下载 解压出两个文件夹： GD32 MCU Dfu Drivers_v1.0.1.2316 GD32 MCU Dfu Tool_v3.8.1.5784 先进入driver文件夹，安装对应的驱动文件，注意使用管理员权限运行 ![](./../assets/examples/how_to_install_dfu.png) 再回到Tools目录下运行 GD32 MCU Dfu Tool.exe 将 Longan Nano 插到电脑，按住板子上 Boot0 键的时候按下 reset 键。 就可以看到 DFU 工具中识别到了 GD32VF 芯片 选择对应的固件文件，并勾选烧录后校验，点击OK，即可进行烧录 烧录完成之后不会自动复位，需要自己手工按下复位按键(按下reset)。 ![](./../assets/examples/how_to_use_dfu.png)"},"/hardware/zh/modules/debugger_and_uart.html":{"title":"施工中","content":" title: 施工中 Sipeed RV Debugger Lite JTAG /串口调试 Sipeed RV debugger plus JTAG+UART Sipeed USB JTAG/TTL Sipeed 双串口转USB模块"},"/hardware/zh/modules/camera_summary.html":{"title":"施工中","content":" title: 施工中 GC0328 双摄像头模块(GC0328) OV7740 OV2640 OV2640 M12 双摄像头模块(OV2640)"},"/hardware/zh/modules/Gamepad.html":{"title":"Sipeed Gamepad","content":"# Sipeed Gamepad ## 概述 ![](./../../assets/spmod/spmod_amigo_hendle/Gamepad141.jpg) 采用主控芯片： GD32F150G 通信接口：IIC（8P座子或者Grove 4P 2.0mm座子） 板载10个按键（每个按键都连接到独立的GPIO） 板载指示灯 ## 硬件参数 项目 参数 MCU GD32F150G（Arm Cortex M3） 主频 72Mhz 存储 64KB Flash, 8KB SRAM 按键 10个按键（每个按键都连接到独立的GPIO） 下载接口 SWD下载 晶振 24MHz无源晶振 LED 板载1个电源指示灯和2个LED USB接口 板载1个USB TYPE C 母座（连接到MCU的USB） ![](./../../assets/spmod/spmod_amigo_hendle/amigo_handle_5.png) ## 手柄接口 ![](./../../assets/spmod/spmod_amigo_hendle/amigo_handle_3.jpg) ![](./../../assets/spmod/spmod_amigo_hendle/amigo_handle_4.jpg) 引脚序号 引脚名称 类型 引脚说明 1 GND G 模块电源地 2 NC NC 悬空引脚，无功能 3 NC NC 悬空引脚，无功能 4 SDA I/O 模块I2C串行数据引脚 5 3V3 V 模块电源输入正 6 NC NC 悬空引脚，无功能 7 NC NC 悬空引脚，无功能 8 SCL I 模块I2C串行时钟引脚 链接方式 单手柄： ![](./../../assets/spmod/spmod_amigo_hendle/Gamepad.143.jpg) 双手柄： ![等待完善](./../../assets/spmod/spmod_amigo_hendle/amigo_handle_6.png) ## 软件描述 项目 参数 开发环境 Maixpy IDE、 PlatformIO IDE 开发语言 C语言、 python 通讯协议 IIC > GD32F150G源码和例程 [https://github.com/sipeed/GD32F150 I2C Handle](https://github.com/sipeed/GD32F150 I2C Handle) ### 手柄测试 单手手柄输入测试 ```python from machine import I2C import nes, lcd from sound import CubeAudio import sys, time from fpioa_manager import fm from Maix import FPIOA, GPIO # B A SEL START UP DOWN LEFT RIGHT X Y # 1 2 4 8 16 32 64 128 254 253 i2c I2C(I2C.I2C2, freq 400*1000, sda 27, scl 24) lcd.init(freq 15000000) lcd.register(0x36, 0x20 state 0 import time i 0 while True: dev i2c1.scan() print(dev) dev i2c2.scan() print(dev) time.sleep(0.5) try: #i2c.writeto(0x4A, b'0') tmp (i2c1.readfrom(0x4A, 2)) print('{} {}'.format(int(tmp[0]), int(tmp[1]))) except Exception as e: print(e) ``` 双手柄输入测试 ```python from machine import I2C import nes, lcd from sound import CubeAudio import sys, time from fpioa_manager import fm from Maix import FPIOA, GPIO # B A SEL START UP DOWN LEFT RIGHT X Y # 1 2 4 8 16 32 64 128 254 253 i2c I2C(I2C.I2C2, freq 400*1000, sda 27, scl 24) lcd.init(freq 15000000) lcd.register(0x36, 0x20 state 0 import time i 0 while True: dev i2c1.scan() print(dev) dev i2c2.scan() print(dev) time.sleep(0.5) try: #i2c.writeto(0x4A, b'0') tmp (i2c1.readfrom(0x4A, 2)) print('{} {}'.format(int(tmp[0]), int(tmp[1]))) except Exception as e: print(e) try: #i2c.writeto(0x42, b'0') tmp (i2c2.readfrom(0x42, 2)) print('{} {}'.format(int(tmp[0]), int(tmp[1]))) except Exception as e: print(e) ``` 测试代码输出 ```python 0 252 #没有输出 1 252 #按下 B 键 2 252 #按下 A 键 4 252 #按下 SEL 键 8 252 #按下 START 键 16 252 #按下 UP 键 32 252 #按下 DOWN 键 64 252 #按下 LEFT 键 128 252 #按下 RIGHT 键 0 254 #按下 X 键 0 253 #按下 Y 键 ``` ### 游戏测试 [MaixPy NES](/soft/maixpy/zh/api_reference/media/nes.md) ## 资料下载 [Gamepad](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Gamepad)"},"/hardware/zh/modules/micarray.html":{"title":"MicArray 麦克风阵列","content":"# MicArray 麦克风阵列 ## 产品介绍 <img src \"./../../assets/spmod/spmod_micarray/spmod_micarray.png\" width 55%> 麦克风阵列模块是 Sipeed 基于 MSM261S4030H0 数字麦克风芯片设计的，模块声音识别灵敏度、信噪比高，由沿板的六个麦克风和一个中心的麦克风组成，阵列板上的 12 颗 LED 可以用来可视化识别声源方位，基于 `GCC PHAT` 算法实现声源定位、语音识别、波束成形等需求场合。 >购买链接： > [淘宝](https://item.taobao.com/item.htm?id 591820993474) > [Aliexpress](https://www.aliexpress.com/item/1005002687541143.html) ## 相关参数资料 ### 数据手册 [点我下载 MSM261S4030H0 数据手册](https://dl.sipeed.com/fileList/MAIX/HDK/Chip_DS/%E9%BA%A6%E5%85%8B_MSM261S4030H0(%E4%BD%BF%E7%94%A8%E7%9A%84).pdf) [点我下载 SK9822 数据手册](https://dl.sipeed.com/fileList/MAIX/HDK/Chip_DS/sk9822_micarray_led.PDF) ### 硬件资料 [点我前往硬件资料合集](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed R6+1_MicArray) [点我下载产品规格书](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed R6+1_MicArray/Specifications/Sipeed%20R6+1%20%E9%BA%A6%E5%85%8B%E9%A3%8E%E9%98%B5%E5%88%97%20%E8%A7%84%E6%A0%BC%E4%B9%A6%20V1.0.pdf) [点我下载产品原理图](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed R6+1_MicArray/Sipeed R6+1_MicArray_11.16/Sipeed R6+1_MicArray_11.16(Schematic).pdf) [点我下载点位图](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed R6+1_MicArray/Sipeed R6+1_MicArray_11.16/Sipeed R6+1_MicArray_11.16(Assembly%20drawing).pdf) ### 相关参数 功能特点 参数 声压级 140 dB SPL 灵敏度 26(dB,dBFS @1kHz 1Pa) 信噪比 57 dB (20kHz bandwidth,A weighted) <br>THD<1% (100dB SPL @1kHz S Nom,Rload>2k ) 时钟频率 1.0 4.0Mhz(正常模式) <br>150 800khz(低功耗模式) MEMS 麦克风 7 个 MSM261S4030H0 组成阵列 连接器 支持 2*5P 2.54mm 端子和 10P 0.5mm FPC 连接器 灯光 12 个 SK9822 LED 组成一个环形 LED 阵列 多个 LED 通过双信号线级联 / 8 Bit（256 级）可调颜色 / 5 Bit（32 级）亮度调节 尺寸 78.1*88.8mm ## 使用方法 在进行上手使用麦克风阵列前，我们需要先完成一些准备工作。 ### 准备工作 **烧录固件** 前往 [下载站](https://dl.sipeed.com/shareURL/MAIX/MaixPy/release/master) 下载固件，下载 [固件说明](https://wiki.sipeed.com/soft/maixpy/zh/get_started/upgrade_maixpy_firmware.html#%E5%9B%BA%E4%BB%B6%E5%91%BD%E5%90%8D%E8%AF%B4%E6%98%8E) 里面的默认固件即可使用。 **掌握 K210 系列开发板的基础使用（使用开发板为前提）** 前往 [K210 上手（避坑）指南](https://wiki.sipeed.com/news/MaixPy/K210_usage.html) 学习相关基础使用，下一步操作开始默认会运行代码会使用开发板。 ### 模块引脚定义 因麦克风阵列需与开发板进行搭配才能使用，连接方式有两种（**2.54mm 杜邦线及 10P 0.5mm FPC 排线**） 如适配板卡上无 FPC 排线接口需使用杜邦线进行连接，需使用下列引脚的定义信息。 引脚序号 引脚名称 类型 引脚说明 1 VIN VCC 模块电源输入正 2 GND GND 模块电源地 3 MIC_D0 I/O 0 号麦克风和1号麦克风的 I²S 接口的串行数据输出 4 MIC_D1 I/O 2 号麦克风和3号麦克风的 I²S 接口的串行数据输出 5 MIC_D2 I/O 4 号麦克风和5号麦克风的 I²S 接口的串行数据输出 6 MIC_D3 I/O 中心麦克风的 I²S 接口的串行数据输出 7 MIC_WS I/O I²S 接口的串行数据字选择 8 MIC_CK I/O I²S 接口的串行数据时钟 9 LED_CK I/O LED 的串行数据时钟 10 LED_DA I/O LED 的的串行数据输出 <img src \"./../../assets/spmod/spmod_micarray/MicArray.png\" width 55%> ### 接线参考 >文档以杜邦线接法为示例，接线前参照自己所用板卡原理图，确定自己选择的引脚没有被其他外设使用。 >**（比如不应该与 LCD 引脚或者摄像头的引脚等外设引脚复用）** 麦克风阵列 开发板上的对应管脚 代码中所对应的参数 VIN 3.3v/5v —— GND GND —— LED_CK I/O 口 sk9822_clk LED_DA I/O 口 sk9822_dat MIC_D0 I/O 口 i2s_d0 MIC_D1 I/O 口 i2s_d1 MIC_D2 I/O 口 i2s_d2 MIC_D3 I/O 口 i2s_d3 MIC_WS I/O 口 i2s_ws MIC_CK I/O 口 i2s_sclk **注意**：因为 K210 的 FPIOA 的特性, 支持每个外设随意映射到任意引脚；所以将上面的表格中的 `I/O 口` 与（自行使用）开发板上带有数字标识的引脚连起来即可，类似于标有 GND 这种特殊标识（参考板子原理图）的就不算所谓的数字标识引脚，连接完后可以查看（例程代码下方）关于代码中引脚的说明。 ### Micropython 代码 > 以下是声源定位实现的代码，运行即可在开发板上体验声源定位的效果。 ```python from Maix import MIC_ARRAY as mic import lcd lcd.init() mic.init()#默认配置 #mic.init(i2s_d0 23, i2s_d1 22, i2s_d2 21, i2s_d3 20, i2s_ws 19, i2s_sclk 18, sk9822_dat 24, sk9822_clk 25)#可自定义配置 IO while True: imga mic.get_map() # 获取声音源分布图像 b mic.get_dir(imga) # 计算、获取声源方向 a mic.set_led(b,(0,0,255))# 配置 RGB LED 颜色值 imgb imga.resize(160,160) imgc imgb.to_rainbow(1) # 将图像转换为彩虹图像 a lcd.display(imgc) mic.deinit() ``` **注意**：请自行根据自己的连接的引脚号，对应着修改 `mic.init(i2s_d0 23, i2s_d1 22, i2s_d2 21, i2s_d3 20, i2s_ws 19, i2s_sclk 18, sk9822_dat 24, sk9822_clk 25)` 里面的参数（**示例：将麦克风阵列上的 `MIC_D0` 与 K210 板子上标号为 25 的引脚相连，那么代码中的相关参数需要修改为 `i2s_d0 25`**）其他引脚同理修改，因用户自行配置的不同无固定杜邦线连接说明，个人自行修改引脚参数，并且不要忘记删掉 `mic.init(...)` 前面的注释（删掉`#`就行）。 ### C 语言代码 #### SK9822 驱动代码 仅供参考用，来源：[github](https://github.com/sipeed/MaixPy/blob/master/components/kendryte_sdk/src/sipeed_sk9822.c) ;需要分析代码的话建议复制代码到电脑本地编辑器中查看。 <details> <summary>sipeed_sk9822.c</summary> <pre class \"language none line numbers language c\"><code class \"language c\">#include \"sipeed_sk9822.h\" #define LED_NUM 12 #define SK9822_DAT_SET() \\ { \\ gpiohs >output_val.bits.b27 1; \\ } #define SK9822_DAT_CLR() \\ { \\ gpiohs >output_val.bits.b27 0; \\ } #define SK9822_CLK_SET() \\ { \\ gpiohs >output_val.bits.b28 1; \\ } #define SK9822_CLK_CLR() \\ { \\ gpiohs >output_val.bits.b28 0; \\ } static void sk9822_init(void) { gpiohs_set_drive_mode(SK9822_DAT_GPIONUM, GPIO_DM_OUTPUT); gpiohs_set_drive_mode(SK9822_CLK_GPIONUM, GPIO_DM_OUTPUT); gpiohs_set_pin(SK9822_DAT_GPIONUM, 0); gpiohs_set_pin(SK9822_CLK_GPIONUM, 0); } void sk9822_send_data(uint32_t data) { for (uint32_t mask 0x80000000; mask > 0; mask >> 1) { SK9822_CLK_CLR(); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); // usleep(1); if (data & mask) { SK9822_DAT_SET(); } else { SK9822_DAT_CLR(); } SK9822_CLK_SET(); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); // usleep(2); } } //32bit 0 void sk9822_start_frame(void) { sk9822_send_data(0); } //32bit 1 void sk9822_stop_frame(void) { sk9822_send_data(0xffffffff); } //1 1 1 1 gray b g r void sk9822_data_one_led(uint8_t gray, uint8_t r, uint8_t g, uint8_t b) { uint32_t tosend; gray & 0x1f; //for make sure no error data in tosend ((0xe0 gray) << 24) (b << 16) (g << 8) r; sk9822_send_data(tosend); } uint32_t sk9822_gen_data_one_led(uint8_t gray, uint8_t r, uint8_t g, uint8_t b) { uint32_t tosend; gray & 0x1f; //for make sure no error data in tosend ((0xe0 gray) << 24) (b << 16) (g << 8) r; return tosend; } //first color1, then msleep interval, then color2, last msleep interval void sk9822_flash(uint32_t color1, uint32_t color2, uint32_t interval) { uint8_t index; color1 0xe0000000; color2 0xe0000000; sk9822_start_frame(); for (index 0; index < LED_NUM; index++) { sk9822_send_data(color1); } sk9822_stop_frame(); msleep(interval); sk9822_start_frame(); for (index 0; index < LED_NUM; index++) { sk9822_send_data(color2); } sk9822_stop_frame(); msleep(interval); } static void arraymove(uint32_t array[], uint8_t len) { uint8_t index; uint32_t tmp; tmp array[0]; for (index 0; index < len 1; index++) { array[index] array[index + 1]; } array[len 1] tmp; } //呼吸 //跑马灯 //方位 void sk9822_horse_race(uint8_t r, uint8_t g, uint8_t b, uint32_t interval, uint8_t times) { uint32_t led_frame[LED_NUM] {0}; uint8_t i, index; for (index 0; index < 12; index++) { led_frame[index] 0xff000000; } for (index 0; index < 6; index++) { // led_frame[index] sk9822_gen_data_one_led((0xe0(index*4)),r 40*index,g 30*index,b 20*index); led_frame[index] sk9822_gen_data_one_led((0xe0 (32 index * 4)), r, g, b); } for (index 0; index < times; index++) { while (1) { sk9822_start_frame(); for (i 0; i < 12; i++) { sk9822_send_data(led_frame[i]); } sk9822_stop_frame(); arraymove(led_frame, LED_NUM); msleep(interval); } } } void sk9822_breath(uint8_t r, uint8_t g, uint8_t b, uint32_t interval) { uint8_t index, cnt, dir; uint32_t color sk9822_gen_data_one_led(0xff, r, g, b); cnt 0; dir 1; while (1) { if (cnt > 30) { dir !dir; cnt 0; } cnt++; color sk9822_gen_data_one_led((0xe0 (dir ? cnt : 31 cnt)), r, g, b); sk9822_start_frame(); for (index 0; index < LED_NUM; index++) { sk9822_send_data(color); } sk9822_stop_frame(); msleep(interval); } } void sipeed_init_mic_array_led(void) { sk9822_init(); //flash 3 times sk9822_flash(0xffeec900, 0xffff0000, 200); sk9822_flash(0xffeec900, 0xff00ff00, 200); sk9822_flash(0xffeec900, 0xff0000ff, 200); } // void sipeed_calc_voice_strength(uint8_t voice_data[]) // { // uint32_t tmp_sum[12] {0}; // uint32_t led_color[12]; // uint8_t i, index, tmp; // for (index 0; index < 12; index++) // { // tmp_sum[index] 0; // for (i 0; i < voice_strength_len[index]; i++) // { // tmp_sum[index] + voice_data[voice_strength[index][i]]; // } // tmp (uint8_t)tmp_sum[index] / voice_strength_len[index]; // led_brightness[index] tmp > 15 ? 15 : tmp; // } // sk9822_start_frame(); // for (index 0; index < 12; index++) // { // led_color[index] (led_brightness[index] / 2) > 1 ? (((0xe0 (led_brightness[index] * 2)) << 24) 0xcd3333) : 0xe0000000; // sk9822_send_data(led_color[index]); // } // sk9822_stop_frame(); // } </code> </pre> </details> #### Micarray 代码 仅供参考用，来源：[github](https://github.com/sipeed/MaixPy/blob/master/components/micropython/port/src/Maix/Maix_mic_array.c)；需要分析代码的话建议复制代码到电脑本地编辑器中查看。 ## 更多拓展用法 >这里收集了社区小伙伴们贡献的关于麦克风阵列更多的拓展用法，供大家进行参考实现。 ### 如何获取数据格式 麦克风阵列与 K210 是通过 I2S 协议进行通信的，可通过麦克风的通信协议手册查询接收的数据格式。 ### 如何获取声音的强度及角度 [点灯鼠教程](https://bbs.sipeed.com/thread/68) [Github 原文教程](https://github.com/USTHzhanglu/Maixpy/tree/master/code/script/mic) ### 声源定位 [K210——声源定位、声音识别](https://qichenxi.blog.csdn.net/article/details/126022738?spm 1001.2101.3001.6661.1&utm_medium distribute.pc_relevant_t0.none task blog 2%7Edefault%7ECTRLIST%7ERate 1 126022738 blog 129727127.235%5Ev33%5Epc_relevant_default_base3&depth_1 utm_source distribute.pc_relevant_t0.none task blog 2%7Edefault%7ECTRLIST%7ERate 1 126022738 blog 129727127.235%5Ev33%5Epc_relevant_default_base3&utm_relevant_index 1) [2022 年电赛 E 题声源定位跟踪系统](https://blog.csdn.net/qq_53357019/article/details/126982978) ## 常见问题 ### 出现报错信息 ![报错信息](./../../assets/spmod/spmod_micarray/spmod_micarray_err.png) 更换其他IO管脚即可"},"/hardware/zh/modules_spmod/spmod_lora.html":{"title":"SPMOD - LoRa","content":"# SPMOD LoRa ## 概述 <img src \"../../assets/spmod/spmod_lora/sp_lora.png\" width \"\" height \"300\" /> SPMOD_LoRa(LoRa 模块)采用 M XL8 模块。 ## SPMOD LoRa 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 利用 SP MOD SPI 和 LoRa 模块通讯 LoRa 模块：M XL8 SX1276 模块是一个 SPI 接口，内置 LoRaTM 调制解调器和可调功率放大器的 LoRa 模块，它具有高性能和可靠性 370MHz 1200MHz, 最大20dBm (100mW)持续发射功率 模块尺寸：25.0\\*10.0\\*4.3mm ### M XL8 SX1276 LoRa 模块 介绍 功能特点： 参数 工作频段 370MHz 1200Mhz 发射功率 20dBm（最大） 通信接口 SPI 工作电压 1.8V~6.3V 工作温度 40℃ 80℃ 天线 外置天线，IPEX或焊接 接收灵敏度 148dbm RSSI动态范围 127dB 最大链路预算 168dB 收发状态电流 9.9mA 睡眠状态电流 50nA 调制方式 FSK, GFSK, MSK, GMSK, LoRaTM及OOK > 内置LoRaTM调制解调器，内置CRC，继承+12dBm可调PA+LNA ### SPMOD_lora 模块引脚定义： 引脚序号 引脚名称 类型 引脚说明 1 GND G 模块电源地 2 CS I/O SPI片选引脚 3 SO I/O MISO数据引脚，主机输入从机输出 4 RST I 模块复位引脚，低有效 5 3V3 V 模块电源输入正 6 SCK I SPI串行时钟引脚 7 SI I/O MOSI数据引脚，主机输出从机输入 8 IRQ I 连接至模块DIO0，可编程决定功能 <img src \"../../assets/spmod/spmod_lora/back.png\" width \"300\" /> 接线方式: MCU:FUN(IO) SP_LCD : : : : GPIOHS7(IO_7) RST SPI:MISO(IO_15) SO SPI:SS0(IO_20) CS SPI:SCK(IO_21) SCK SPI:MOSI(IO_8) SI GPIOH(IO_6) IRQ 1.8 6.3V 3.3V GND GND <img src \"../../assets/spmod/spmod_lora//connection.png\" height \"250\"> ## 使用例程 * 流程 1. 创建 LoRa 对象并初始化 2. 发送或者接收数据 ### C 示例： ```c fpioa_set_function(SPI_LoRa_SX127X_CS_PIN_NUM, FUNC_SPI1_SS0); // CS: 20 fpioa_set_function(SPI_LoRa_SX127X_SCK_PIN_NUM, FUNC_SPI1_SCLK); // SCLK: 21 fpioa_set_function(SPI_LoRa_SX127X_MOSI_PIN_NUM, FUNC_SPI1_D0); // MOSI: 8 fpioa_set_function(SPI_LoRa_SX127X_MISO_PIN_NUM, FUNC_SPI1_D1); // MISO: 15 fpioa_set_function(SPI_LoRa_SX127X_IRQ_PIN_NUM, FUNC_GPIOHS0 + SPI_LoRa_SX127X_IQR_GPIO_NUM); // IQR: 6 fpioa_set_function(SPI_LoRa_SX127X_RST_PIN_NUM, FUNC_GPIOHS0 + SPI_LoRa_SX127X_RST_GPIO_NUM); // RST: 7 spi_init(SPI_DEVICE_1, SPI_WORK_MODE_0, SPI_FF_STANDARD, DATALENGTH, 0); sx1278_begin(&SX1278, SX1278_433MHZ, SX1278_POWER_17DBM, SX1278_LoRa_SF_8, SX1278_LoRa_BW_20_8KHZ, 10); if (master 1) { printf(\" MASTER \\r\\n\"); ret sx1278_LoRaEntryTx(&SX1278, 16, 2000); } else { printf(\" SALAVE \\r\\n\"); ret sx1278_LoRaEntryRx(&SX1278, 16, 2000); } ``` ### MaixPy 例程： ```python fm.register(20, fm.fpioa.GPIOHS20, force True) # RST fm.register(7, fm.fpioa.GPIOHS7, force True) # CS # set gpiohs work mode to output mode cs GPIO(GPIO.GPIOHS20, GPIO.OUT) rst GPIO(GPIO.GPIOHS7, GPIO.IN) # The other pins are configured at SPI initialization time spi1 SPI(SPI.SPI1, mode SPI.MODE_MASTER, baudrate 100 * 1000, polarity 0, phase 0, bits 8, firstbit SPI.MSB, sck 21, mosi 8, miso 15) lora SX127x(spi spi1, pin_ss cs) lora.init() #######receiver########### receive(lora) ########sender########### # send(lora) ``` ### 运行环境 语言 开发板 SDK/固件版本 : : : : : : C MaixCube kendryte standalone sdk v0.5.6 MaixPy MaixCube maixpy v0.5.1 *MaixPy固件建议自行从最新源码编译* ### 运行结果 * C <center class \"third\"> \t <img src \"../../assets/spmod/spmod_lora/lora_send_log_c.png\" height \"250\"/><img src \"../../assets/spmod/spmod_lora/lora_recv_log_c.png\" height \"250\"/> </center> * MaixPy <center class \"third\"> \t <img src \"../../assets/spmod/spmod_lora/lora_send_log.png\" height \"250\"/><img src \"../../assets/spmod/spmod_lora/lora_recv_log.png\" height \"250\"/> </center> ### 移植 修改以下参数即可适配其他 K210 开发板. * C ```c // board_config.h #define SPI_INDEX 1 #define SPI_SCLK_RATE 600*1000 #define SPI_CHIP_SELECT_NSS 0//SPI_CHIP_SELECT_0 #define SPI_LoRa_SX127X_CS_PIN_NUM 20 #define SPI_LoRa_SX127X_SCK_PIN_NUM 21 #define SPI_LoRa_SX127X_MOSI_PIN_NUM 8 #define SPI_LoRa_SX127X_MISO_PIN_NUM 15 #define SPI_LoRa_SX127X_IRQ_PIN_NUM 6 #define SPI_LoRa_SX127X_RST_PIN_NUM 7 #define SPI_LoRa_SX127X_IQR_GPIO_NUM 6 #define SPI_LoRa_SX127X_RST_GPIO_NUM 7 ``` * MaixPy ```python ################### config ################### LoRa_RST const(20) LoRa_CS const(7) LoRa_SPI_SCK const(21) LoRa_SPI_MOSI const(8) LoRa_SPI_MISO const(15) LoRa_SPI_NUM SPI.SPI1 LoRa_SPI_FREQ_KHZ const(100) ############################################## ``` ## 参考设计 SPMOD_LoRa 尺寸图： <img src \"../../assets/spmod/spmod_lora/sipeed_spmod_lora.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（六群） 636551897 "},"/hardware/zh/modules_spmod/spmod_lcd1.14.html":{"title":"SPMOD - LCD 1.14","content":"# SPMOD LCD 1.14 ## 概述 ![](../../assets/spmod/spmod_lcd1.14/sp_lcd.png) SPMOD_LCD1.14(1.14寸 LCD 屏幕模块)采用 ST7735S TFT LCD屏。 ## SPMOD LCD1.14 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 采用常见 LCD 驱动 IC ST7735S(4 线 SPI 通讯) 分辨率：240\\*135 模块尺寸：35.0\\*20.0mm ### ST7735S TFT LCD屏 介绍 功能特点： 参数 工作电压 2.5V~4.8V 工作电流 <20mA 工作温度 30℃ ~ 85℃ 休眠电流 <0.1mA 屏幕大小 1.14英寸 有效显示区域 1.7mm * 10.8mm 分辨率 160*80 色彩 132个RGB通道 对外接口 8P FPC (0.5mm间距) > 内部集成电路包含DC / DC转换器、可调VCOM生成器、非易失性（NV）存储器（用于存储初始寄存器设置）、显示时钟的振荡器以及时序控制器 ### SPMOD_LCD1.14 模块引脚定义： 引脚序号 引脚名称 类型 引脚说明 1 GND G 模块电源地 2 CS I SPI片选引脚 3 D/C I 数据/命令输入切换引脚 4 RST I 模块复位引脚，低有效 5 3V3 V 模块电源输入正 6 SCK I SPI串行时钟引脚 7 SI I/O MOSI数据引脚，主机输出从机输入 8 BL I 背光控制引脚，低电平关闭背光 <img src \"../../assets/spmod/spmod_lcd1.14/back.png\" width \"300\" /> 接线方式: MCU:FUN(IO) SP_LCD : : : : GPIOHS7(IO_7) RST GPIOHS15(IO_15) D/C SPI:SS0(IO_20) CS SPI:SCK(IO_21) SCK SPI:MOSI(IO_8) SI GPIOHS6(IO_6) BL 2.5~4.8V 3.3V GND GND <img src \"../../assets/spmod/spmod_lcd1.14//connection.png\" height \"250\"> ## 使用例程 * 流程 1. 初始化配置 2. 创建 Image 并填充 3. 发送图像并刷新 ### C 示例： ```c fpioa_set_function(SPI_IPS_LCD_CS_PIN_NUM, FUNC_SPI1_SS0); // SPI_IPS_LCD_CS_PIN_NUM: 20; fpioa_set_function(SPI_IPS_LCD_SCK_PIN_NUM, FUNC_SPI1_SCLK); // SPI_IPS_LCD_SCK_PIN_NUM: 21; fpioa_set_function(SPI_IPS_LCD_MOSI_PIN_NUM, FUNC_SPI1_D0); // SPI_IPS_LCD_MOSI_PIN_NUM: 8; fpioa_set_function(SPI_IPS_LCD_DC_PIN_NUM, FUNC_GPIOHS0 + SPI_IPS_LCD_DC_GPIO_NUM); // SPI_IPS_LCD_DC_PIN_NUM: 15; SPI_IPS_LCD_DC_GPIO_NUM: 15; fpioa_set_function(SPI_IPS_LCD_RST_PIN_NUM, FUNC_GPIOHS0 + SPI_IPS_LCD_RST_GPIO_NUM); // SPI_IPS_LCD_RST_PIN_NUM: 7; SPI_IPS_LCD_RST_GPIO_NUM: 7; fpioa_set_function(SPI_IPS_LCD_BL_PIN_NUM, FUNC_GPIOHS0 + SPI_IPS_LCD_BL_GPIO_NUM); // SPI_IPS_LCD_BL_PIN_NUM: 6; SPI_IPS_LCD_BL_GPIO_NUM: 6; // set gpiohs work mode to output mode gpiohs_set_drive_mode(SPI_IPS_LCD_DC_GPIO_NUM, GPIO_DM_OUTPUT); gpiohs_set_drive_mode(SPI_IPS_LCD_RST_GPIO_NUM, GPIO_DM_OUTPUT); gpiohs_set_drive_mode(SPI_IPS_LCD_BL_GPIO_NUM, GPIO_DM_OUTPUT); spi_init(1, SPI_WORK_MODE_0, SPI_FF_STANDARD, DATALENGTH, 0); ips_lcd_init(); // init LCD_ShowPicture(0, 0, LCD_W, LCD_H, gImage_nanke); // display ``` ### MaixPy 例程： ```python # 20: SPI_LCD_CS_PIN_NUM; fm.register(SPI_LCD_CS_PIN_NUM, fm.fpioa.GPIOHS20, force True) # 15: SPI_LCD_DC_PIN_NUM; fm.register(SPI_LCD_DC_PIN_NUM, fm.fpioa.GPIOHS15, force True) # 6: SPI_LCD_BUSY_PIN_NUM; fm.register(SPI_LCD_BUSY_PIN_NUM, fm.fpioa.GPIOHS6, force True) # 7: SPI_LCD_RST_PIN_NUM; fm.register(SPI_LCD_RST_PIN_NUM, fm.fpioa.GPIOHS7, force True) # set gpiohs work mode to output mode cs GPIO(GPIO.GPIOHS20, GPIO.OUT) dc GPIO(GPIO.GPIOHS15, GPIO.OUT) busy GPIO(GPIO.GPIOHS6, GPIO.OUT) rst GPIO(GPIO.GPIOHS7, GPIO.OUT) # 21: SPI_LCD_SCK_PIN_NUM; 8: SPI_LCD_MOSI_PIN_NUM; spi1 SPI(SPI_LCD_NUM, mode SPI.MODE_MASTER, baudrate SPI_LCD_FREQ_KHZ * 1000, polarity 0, phase 0, bits 8, firstbit SPI.MSB, sck SPI_LCD_SCK_PIN_NUM, mosi SPI_LCD_MOSI_PIN_NUM) ips SPLCD114(spi1, cs, dc, rst, busy, IPS_WIDTH, IPS_HEIGHT, IPS_MODE) # create an 'image' and fill it img image.Image() img.draw_rectangle(80, 80, 30, 30) # display ips.display(img) ``` ### 运行环境 语言 开发板 SDK/固件版本 : : : : : : C MaixCube kendryte standalone sdk v0.5.6 MaixPy MaixCube maixpy v0.5.1 *MaixPy固件建议自行从最新源码编译* ### 运行结果 * C <img src \"../../assets/spmod/spmod_lcd1.14//sp_lcd1.14_c.png\" height \"250\" /> * MaixPy <img src \"../../assets/spmod/spmod_lcd1.14//sp_lcd1.14_py.png\" alt \"sp_lcd1.14_py\" height \"250\" /> ### 移植 修改以下参数即可适配其他 K210 开发板. * C ```c // board_config.h #define SPI_INDEX 1 #define SPI_SCLK_RATE 600*1000 #define SPI_CHIP_SELECT_NSS 0 // SPI_CHIP_SELECT_0 #define SPI_IPS_LCD_CS_PIN_NUM 20 #define SPI_IPS_LCD_SCK_PIN_NUM 21 #define SPI_IPS_LCD_MOSI_PIN_NUM 8 #define SPI_IPS_LCD_DC_PIN_NUM 15 #define SPI_IPS_LCD_BL_PIN_NUM 6 #define SPI_IPS_LCD_RST_PIN_NUM 7 #define SPI_IPS_LCD_DC_GPIO_NUM 15 #define SPI_IPS_LCD_BL_GPIO_NUM 6 #define SPI_IPS_LCD_RST_GPIO_NUM 7 #define USE_HORIZONTAL 3 // 0/1 is horizontal, and 2/3 is vertical. ``` * Maixpy ```python ################### config ################### SPI_LCD_NUM SPI.SPI1 SPI_LCD_DC_PIN_NUM const(15) SPI_LCD_BUSY_PIN_NUM const(6) SPI_LCD_RST_PIN_NUM const(7) SPI_LCD_CS_PIN_NUM const(20) SPI_LCD_SCK_PIN_NUM const(21) SPI_LCD_MOSI_PIN_NUM const(8) SPI_LCD_FREQ_KHZ const(600) ############################################## ``` ## 参考设计 SPMOD_LCD1.14 尺寸图： <img src \"../../assets/spmod/spmod_lcd1.14/sipeed_spmod_lcd1.14.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maixhub.com](https://maixhub.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群 878189804 "},"/hardware/zh/modules_spmod/spmod_joystick.html":{"title":"SPMOD - JoyStick","content":"# SPMOD JoyStick ## 概述 <img src \"../../assets/spmod/spmod_joystick/sp_joystick.png\" width \"\" height \"300\" /> SPMOD_JoyStick (JoyStick模块)。 ## SPMOD JoyStick 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 通过SP MOD SPI接口连接 可通过外部适配器单独连接7.2V~9V DC，为手柄的振动马达供电 内置升压电路，轻松驱动手柄 PSX/PS2兼容 模块尺寸：35.0\\*20.0\\*13.3mm ### SPMOD_JoyStick 模块引脚定义： 引脚序号 引脚名称 类型 引脚说明 1 GND G 模块电源地 2 CS I SPI片选引脚 3 SO I/O MISO数据引脚，手柄信号输出 4 NC NC 悬空引脚，无功能 5 3V3 V 模块电源输入正 6 SCK I SPI串行时钟引脚 7 SI I/O MOSI数据引脚，手柄信号输入 8 ACK O 确认信号输出引脚 <img src \"\" width \"500\" /> ## 使用例程 待更新 ## 参考设计 SPMOD_JoyStick 尺寸图： <img src \"../../assets/spmod/spmod_joystick/sipeed_spmod_joystick.png\" height \"250\" /> ## 资源链接 资源 链接 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（六群） 636551897 "},"/hardware/zh/modules_spmod/spmod_tof.html":{"title":"SPMOD - TOF","content":"# SPMOD TOF ## 概述 <img src \"../../assets/spmod/spmod_tof/sp_tof.png\" style \"padding right:100px;\" width \"\" height \"300\" /> SPMOD_TOF(TOF 模块) 采用 VL53L0X 模块。 ## SPMOD TOF 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 利用SP MOD I2C 和 TOF 模块通讯 ToF模块：VL53L0X模块是一个I2C接口，长距离单点飞行时间测定（ToF）模块，它具有高性能和可靠性 最远测量距离4000mm，最高50Hz的测量刷新率。典型前方测量角度27° 可选配红色激光器瞄准头，通过XSHUT引脚控制激光器开关 模块尺寸：25.0\\*10\\*3.15mm ### VL53L0X 介绍 VL53L0X 功能特性： 测量距离 最大 4000mm(4m) 工作刷新率 50Hz 测量角度（正面） 27° 通信接口 I2C 工作电压 2.6V~3.5V (选用红色激光时： 2.8V~3.3V) 工作状态电流 18mA (选用红色激光时： 20mA) 工作温度 40℃ 80℃ 睡眠状态电流 5uA ### SPMOD_TOF 模块引脚定义： 引脚序号 引脚名称 类型 引脚说明 1 GND G 模块电源地 2 IRQ I 模块中断输入引脚，连接至 VL53L0X 的GPIO1 3 NC NC 悬空引脚，无功能 4 SDA I/O 模块 I2C 串行数据引脚 5 3V3 V 模块电源输入正 6 NC NC 悬空引脚，无功能 7 SHT I 模块休眠&激光头控制引脚 #注释 8 SCL I 模块 I2C 串行时钟引脚 > SHT 低电平时，模块休眠 &激光头关闭 <img src \"../../assets/spmod/spmod_tof/back.png\" height \"300\" /> 接线方式: MCU:FUN(IO) SP_RFID : : : : I2C:SDA(IO_7) SDA NC(IO_15) NC NC(IO_20) IRQ NC(IO_21) NC GPIOHS(IO_8) SHT I2C:SCL(IO_6) SCL 2.8~3.5V 3.3V GND GND <img src \"../../assets/spmod/spmod_tof/connection.png\" height \"250\"> ## 使用例程 * 流程 1. 初始化 2. 校准(可选) 3. 读取距离(多种模式可选) ### C 示例： ```c //set io mux fpioa_set_function(VL53L0X_SCL, FUNC_I2C0_SCLK + VL53L0X_I2C_DEVICE * 2); fpioa_set_function(VL53L0X_SDA, FUNC_I2C0_SDA + VL53L0X_I2C_DEVICE * 2); fpioa_set_function(VL53L0X_SHT, FUNC_GPIOHS0 + VL53L0X_SHT); gpiohs_set_drive_mode(VL53L0X_SHT, GPIO_DM_OUTPUT); //i2c init maix_i2c_init(VL53L0X_I2C_DEVICE, 7, VL53L0X_I2C_FREQ_KHZ * 1000); while (vl53l0x_init(&vl53l0x_dev)) { printf(\"VL53L0X init error!!!\\r\\n\"); msleep(500); } printf(\"VL53L0X init success!\\r\\n\"); // adjusting printf(\"VL53L0X adjusting\\r\\n\"); vl53l0x_calibration_test(&vl53l0x_dev); // get distance printf(\"VL53L0X start work\\r\\n\"); vl53l0x_general_test(&vl53l0x_dev); ``` ### MaixPy 例程： ```python fm.register(VL53L0X_SHT, fm.fpioa.GPIOHS0, force True) XSHUT GPIO(GPIO.GPIOHS0, GPIO.OUT) i2c I2C(VL53L0X_I2C_NUM, freq VL53L0X_FREQ, scl VL53L0X_SCL, sda VL53L0X_SDA) # create obj and read distance \t tof VL53L0X(i2c) \t while True: mm tof.read() utime.sleep_ms(100) print(mm) ``` ### 运行环境 语言 开发板 SDK/固件版本 : : : : C MaixCube kendryte standalone sdk v0.5.6 MaixPy MaixCube maixpy v0.5.1 ### 运行结果 * C <img src \"../../assets/spmod/spmod_tof/log_c.png\" height \"200\" /> * MaixPy [None] ## 移植 修改以下参数即可适配其他 K210 开发板. * C ```c // board_config.h #define VL53L0X_I2C_DEVICE 0 // i2c device number #define VL53L0X_I2C_FREQ_KHZ 100 // i2c frequence #define VL53L0X_SCL 6 // scl #define VL53L0X_SDA 7 // sda #define VL53L0X_SHT 8 // sht ``` * MaixPy ```python ################### config ################### VL53L0X_I2C_NUM const(I2C.I2C0) VL53L0X_FREQ const(100000) VL53L0X_SCL const(6) VL53L0X_SDA const(7) VL53L0X_SHT const(8) ############################################## ``` ## 参考设计 SPMOD_TOF 尺寸图： <img src \"../../assets/spmod/spmod_tof/sipeed_spmod_tof.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（六群） 636551897 "},"/hardware/zh/modules_spmod/spmod_micarray.html":{"title":"SPMOD - MicArray","content":"# SPMOD MicArray ## 概述 <img src \"../../assets/spmod/spmod_micarray/sp_micarray.png\" width \"\" height \"300\" /> SPMOD_MicArray(麦克风阵列模块)采用 RY3708(DC DC)升压模块 ## SPMOD MicArray 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 将SP MOD转至FPC，利用FPC与麦克风阵列板相连。 板载3.3V至5V升压DC DC (RY3708)，轻松驱动麦克风阵列。 利用Grove接口控制麦克风阵列板上的LED。 需要配合SIPEED MICARRAY一起使用。 模块尺寸：35.0\\*10.0\\*11.2mm ### BOOST DC DC RY3708 模块 介绍 功能特点： 参数 输出电压 5.1V ±0.2V 外部供电电压 \t3.3V ±0.2V 外部供电电流 视麦克风阵列板的工作情况而定，通常小于500mA 工作温度范围 40℃ ~ 85℃ > 1.2MHz固定开关频率,内部4A开关电流限制,高温自动切断,集成80mΩ内部功率MOSFET ### SPMOD_MicArray 模块引脚定义： 引脚序号 引脚名称 类型 引脚说明 1 GND G 模块电源地 2 D2 I Mic_D0 3 D3 I Mic_D2 4 D0 I Mic_WS 5 3V3 V 模块电源输入正 6 D4 I Mic_D1 7 D5 I Mic_D3 8 D1 I Mic_BCK 9 CK I LED控制串行时钟引脚 (相当于I2C SCL) 10 DA I LED控制串行数据引脚 (相当于I2C SDA) <img src \"\" width \"300\" /> ## 使用例程 ```python from Maix import MIC_ARRAY as mic import lcd lcd.init() mic.init() #mic.init(i2s_d0 23, i2s_d1 22, i2s_d2 21, i2s_d3 20, i2s_ws 19, i2s_sclk 18, sk9822_dat 24, sk9822_clk 25) while True: imga mic.get_map() b mic.get_dir(imga) a mic.set_led(b,(0,0,255)) imgb imga.resize(160,160) imgc imgb.to_rainbow(1) a lcd.display(imgc) mic.deinit() ``` > 需要根据自己接板子上的管脚号来进行修改mic.init()中参数 ## 参考设计 SPMOD_MicArray 尺寸图： <img src \"../../assets/spmod/spmod_micarray/sipeed_spmod_micarray.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（六群） 636551897 "},"/hardware/zh/modules_spmod/spmod_weather.html":{"title":"SPMOD - Weather","content":"# SPMOD Weather ## 概述 <img src \"../../assets/spmod/spmod_weather/sp_weather.png\" SPMOD Weather (气象站模块), 集成三轴传感器 QMC7983,与温湿度气压传感器 BME280。 <img src \"../../assets/spmod/spmod_weather/demo.gif\" width \"500\" > ## SPMOD Weather 介绍 特性： 采用 **Sipeed SPMOD** 接口(2*4PIN 2.54mm 排针)，统一 MaixPy 开发板接口 通过SP MOD I2C接口连接 磁性传感器：QMC7983是一个内置灵敏度补偿与NTC的三轴磁性传感器，I2C接口输出（最高频率400KHz），具有出色的动态范围和精度以及超低的功耗 磁感应量程：±30 高斯 温湿度气压传感器：BME280是同时集成了温湿度与气压传感器的数字传感器 模块尺寸：25.0\\*10\\*2.9mm ## 传感器特性： 磁性传感器 QMC7983 工作电压 2.6V~3.6V 工作电流 70uA 休眠电流 <1uA 磁感应量程 ±30 高斯 精度 每 LSB 1mG RMS 噪声 2 mG 对外接口 I2C，默认地址 0x2C,可通过选择电阻调节 温湿度气压传感器 BME280 工作电压 1.71V~3.6V 工作电流 <633uA 休眠电流 <5uA 湿度传感器的关键参数： 响应时间（𝜏63％） 1s 精度公差 ±3％ 相对湿度 磁滞 < 2％ 相对湿度 气压力传感器的关键参数： RMS 噪声 0.2 Pa（等效 到海拔 1.7 厘米） 偏移温度系数 ±1.5 Pa/K（等效温度变化 1°C 时，达到海拔 ±12.6 cm1s） 对外接口 I2C，默认地址 0x76, 可通过选择电阻调节 ### SPMOD_Weather 模块引脚定义： 引脚序号 引脚名称 类型 引脚说明 1 GND G 模块电源地 2 NC NC 悬空引脚，无功能 3 NC NC 悬空引脚，无功能 4 SDA I/O 模块I2C串行数据引脚 5 3V3 V 模块电源输入正 6 NC NC 悬空引脚，无功能 7 NC NC 悬空引脚，无功能 8 SCL I 模块I2C串行时钟引脚 <img src \"../../assets/spmod/spmod_weather/back.png\" width \"300\" /> ## 接线方式 <img src \"../../assets/spmod/spmod_weather/connection.png\" height \"250\"> MCU:FUN(IO) SP_RFID : : : : I2C:SDA(IO_7) SDA NC(IO_15) NC NC(IO_20) IRQ NC(IO_21) NC GPIOHS(IO_8) SHT I2C:SCL(IO_6) SCL 2.8~3.5V 3.3V GND GND ## 使用例程 * 流程 1. 初始化 weather SPWeather(i2c i2c_bus) # create sp_weather while 1: time.sleep_ms(500) print(weather.qmc_read_xyz) # QMC7983 read data print(weather.bme_values) # BME280 read data 2. 校准(可选) 3. 读取距离(多种模式可选) ### C 示例： ```c fpioa_set_function(Weather_SCL, FUNC_I2C0_SCLK + Weather_I2C_DEVICE * 2); // Weather_SCL: 6; fpioa_set_function(Weather_SDA, FUNC_I2C0_SDA + Weather_I2C_DEVICE * 2); // Weather_SDA: 7; maix_i2c_init(Weather_I2C_DEVICE, 7, 400000); // Weather_I2C_DEVICE: 0; rslt qmc_init(); // Magnetic sensor QMC7983 init rslt bme280_init(&dev); // Temperature, humidity and pressure sensors BME280 init stream_sensor_data_normal_mode(&dev); // read and print sensor data ``` ### MaixPy 例程： ```python i2c_bus I2C(I2C.I2C0, freq 100*1000, scl 6, sda 7) # scl: io_6, sda: io_7 weather SPWeather(i2c i2c_bus) # create sp_weather while 1: time.sleep_ms(500) print(weather.qmc_read_xyz) # QMC7983 read data print(weather.bme_values) # BME280 read data ``` ## 运行环境 语言 开发板 SDK/固件版本 : : : : : C MaixCube kendryte standalone sdk v0.5.6 MaixPy MaixCube maixpy v0.5.1 ## 运行结果 * C <img src \"../../assets/spmod/spmod_weather/log_c.png\" height \"200\"> * MaixPy <img src \"../../assets/spmod/spmod_weather/log_py.png\" height \"200\"> ## 参考设计 SPMOD_Weather 尺寸图： <img src \"../../assets/spmod/spmod_weather/sipeed_spmod_weather.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（六群） 636551897 "},"/hardware/zh/modules_spmod/spmod_fpc.html":{"title":"SPMOD - FPC","content":"# SPMOD FPC ## 概述 ![](../../assets/spmod/spmod_fpc/sp_fpc.png) SPMOD_FPC(FPC 转接线模块) ## SPMOD FPC 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 作为延长套件，轻松的将SP MOD接口用FPC延长至另一端。您将有更大的自由连接模块构建系统。 提供一对SP MOD至FPC转换板（一公一母），一条FPC排线, 10P规格。 模块尺寸：15.0\\*10.0\\*3.3mm ## 概括 功能特点： 参数 SP MOD至FPC10转换器器(公母一对)\t 用于将SP MOD接口和FPC的双向转换 FPC排线\t 用于连接两个转换器 外部供电电压 视连接的模块而定 外部供电电流 视模块工作情况而定，通常小于1000mA 工作温度 30℃ ~ 85℃ ## 参考设计 SPMOD_FPC 尺寸图： <img src \"../../assets/spmod/spmod_fpc/sipeed_spmod_fpc.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（六群） 636551897 "},"/hardware/zh/modules_spmod/spmod_bt.html":{"title":"SPMOD - BT","content":"# SPMOD BT ## 概述 ![](./../../assets/spmod/spmod_bt/sp_bt.png) SPMOD BT(蓝牙 模块)采用 YDJ 23。 ## SPMOD BT 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 利用 SP MOD UART 和蓝牙模块通讯 JDY 23蓝牙模块：支持BLE 5.0（兼容 BLE4.0、BLE4.2）。具有UART接口。模块支持AT指令控制。具备超低功耗特性和高可靠性 板载两个状态指示LED，模块状态一目了然 模块尺寸：25.6\\*20.2\\*3.2mm ### JDY 23 蓝牙介绍： 功能特点： 参数 工作频段： 2.4G 发射功率： 4db（最大） 通信接口： UART 工作电压： 1.8V~3.6V 工作温度： 40℃ 80℃ 天线： 板载PCB天线 接收灵敏度： 97dbm 主从支持： 从机 蓝牙版本： BLE 5.0（兼容 BLE4.0、BLE4.2） 唤醒状态电流： 800uA（广播模式） 浅睡状态电流： <50uA (广播模式) 深度睡眠电流： 9uA （无广播） 默认串口波特率： 9600 ### SPMOD_BT 模块引脚定义： 引脚序号 引脚名称 类型 引脚说明 1 GND G 模块电源地 2 AWK I/O 模块休眠唤醒引脚，低有效 3 STA I/O 蓝牙连接状态连接，连接成功时输出高电平 4 RX I 模块UART数据接受引脚，连接上位机TX 5 3V3 V 模块电源输入正 6 NC 悬空引脚，无功能 7 RST I/O 模块复位引脚，低电平有效 8 TX O 模块UART数据发送引脚，连接上位机的RX <img src \"../../assets/spmod/spmod_bt/back.jpg\" height \"250\" /> 接线方式： MCU:FUN(IO) SP_BT : : : : UART:TX(IO_7) RX USRT:RX(IO_6) TX 1.8 3.3V 3.3V GND GND <img src \"../../assets/spmod/spmod_bt/connection.png\" height \"250\"> ### 主要 AT 指令列表： 指令 描述 AT+POWR 显示模块发送功率 AT+RST\t 软复位 AT+MAC\t 显示MAC 地址 AT+NAME 显示广播名 AT+HOSTEN 从模式或 IBEACON 工作模式 AT+IBUUID IBEACON 的 UUID AT+DISC 指令断开连接 AT+SLEEP 睡眠 AT+MTU 设置模块发送的发包数长 *更多AT指令请参考[JDY 23 V2.1.pdf](https://cn.dl.sipeed.com/shareURL/MAIX/HDK/sp_mod/sp_bt)* ## 使用例程 * 流程 1. 发送 AT 指令 2. 接收数据 3. 判断是否设置成功 ### C 示例： ```c // set uart rx/tx func to io_6/7 fpioa_set_function(6, FUNC_UART1_RX + UART_NUM * 2); fpioa_set_function(7, FUNC_UART1_TX + UART_NUM * 2); uart_init(UART_DEVICE_1); uart_configure(UART_DEVICE_1, 9600, 8, UART_STOP_1, UART_PARITY_NONE); //change the name of sp_bt module to MAIXCUBE uart_send_data(UART_NUM, \"AT+NAMEMAIXCUBE\\r\\n\", strlen(\"AT+NAMEMAIXCUBE\\r\\n\")); //send AT order msleep(100); ret uart_receive_data(UART_NUM, rcv_buf, sizeof(rcv_buf)); //receive response if(ret ! 0 && strstr(rcv_buf, \"OK\")) { printk(LOG_COLOR_W \"set name success!\\r\\n\"); } // get the name of sp_bt module uart_send_data(UART_NUM, \"AT+NAME\\r\\n\", strlen(\"AT+NAME\\r\\n\")); //send AT order msleep(100); ret uart_receive_data(UART_NUM, rcv_buf, sizeof(rcv_buf)); //receive response if(ret ! 0 && strstr(rcv_buf, \"NAME\")) { printk(LOG_COLOR_W \"get name success!\\r\\n\"); } ``` ### MaixPy 例程： ```python # set uart rx/tx func to io_6/7 fm.register(6,fm.fpioa.UART1_RX) fm.register(7,fm.fpioa.UART1_TX) uart UART(UART.UART1,9600,8,1,0,timeout 1000, read_buf_len 4096) #change the name of sp_bt module to MAIXCUBE uart.write(\"AT+NAMEMAIXCUBE\\r\\n\") #send AT order time.sleep_ms(100) read_data uart.read() #receive response if read_data: read_str read_data.decode('utf 8') count read_str.count(\"OK\") if count ! 0: uart.write(\"set name success\\r\\n\") # get the name of sp_bt module uart.write(\"AT+NAME\\r\\n\") #send AT order time.sleep_ms(100) read_data uart.read() #receive response if read_data: read_str read_data.decode('utf 8') count read_str.count(\"NAME\") if count ! 0: uart.write(\"get name success\\r\\n\") ``` *注意发送AT指令后一定要加上\\r\\n* ### 运行结果: 使用[BLE Utility](../../tools/bledebugger.apk)连接设备后进行收发测试结果如下: <center class \"third\"> <img src \"../../assets/spmod/spmod_bt/res.png\" height \"250\"/><img src \"../../assets/spmod/spmod_bt/res1.png\" height \"250\"/> </center> ### 运行环境: 语言 开发板 SDK/固件版本 : : : : : C MaixCube kendryte standalone sdk v0.5.6 MaixPy MaixCube maixpy v0.5.1 ## 参考设计 SPMOD_BLE 尺寸图： <img src \"../../assets/spmod/spmod_bt/sipeed_spmod_bt.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/shareURL/MAIX/SDK](https://dl.sipeed.com/shareURL/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/shareURL/MAIX/HDK](https://dl.sipeed.com/shareURL/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（六群） 636551897 "},"/hardware/zh/modules_spmod/spmod_psram.html":{"title":"SPMOD - PSRAM","content":"# SPMOD PSRAM ## 概述 <img src \"../../assets/spmod/spmod_psram/sp_psram.png\" width \"\" height \"300\" /> SPMOD_PSRAM(PSRAM模块)采用 IPS6404L SQ 芯片。 ## SPMOD PSRAM 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 通过SP MOD SPI/QPI接口连接 Pseudo−SRAM芯片：IPS6404L SQ是一个容量为64Mbit，SPI/QPI接口，具有出色的可靠性的和响应时间的伪随机动态存储器芯片。 工作频率：104MHz SPI读取响应时间：30.3ns 模块尺寸：15.0\\*10.0\\*13.3mm ### IPS6404L SQ 迫真静态随机存储器介绍 功能特点： 参数 工作电压 2.7V~3.6V 工作电流 10mA 工作温度 30℃~85℃ 休眠电流 <250μA 工作频率 104Mhz SPI读取响应时间 30.3ns 其他操作响应时间 9.3ns 对外接口 PI/QPI可选，默认SPI ### SPMOD_PSRAM 模块引脚定义： 引脚序号 引脚名称 类型 引脚说明 1 GND G 模块电源地 2 CS I SPI片选引脚 3 D1 I/0 MISO数据引脚，模块数据输出 4 D3 I/O 无功能 (QSPI模式下为IO3) 5 3V3 V 模块电源输入正 6 SCK I SPI串行时钟引脚 7 D0 I/0 MOSI数据引脚，模块数据输入 (QSPI模式下为IO0) 8 D2 I/O 无功能 (QSPI模式下为IO2) <img src \"\" width \"300\" /> ## 使用例程 待更新 ## 参考设计 SPMOD_PSRAM 尺寸图： <img src \"../../assets/spmod/spmod_psram/sipeed_spmod_psram.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（六群） 636551897 "},"/hardware/zh/modules_spmod/spmod_eink.html":{"title":"SPMOD - Eink","content":"# SPMOD Eink ## 概述 <img src \"../../assets/spmod/spmod_eink/sp_eink.png\" alt \"XXX\" style \"zoom:40%;\" /> SPMOD_Eink(墨水屏模块)采用 GDEW0154M09 电子墨水屏。 ## SPMOD Eink 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 通过SP MOD SPI接口与屏幕底板相连 电子墨水屏：GDEW0154M09是一款1.54”，SPI接口控制，拥有24P FPC(0.5mm间距)接口的电子墨水屏。拥有超广可视角。 支持 1 bit 黑/白显示 分辨率：200x200 模块尺寸：35*30*3.8mm ### GDEW0154M09 电子墨水屏介绍 功能特点： 参数 工作电压 2.3V~3.6V 工作电流 1~3mA 工作温度范围 40℃~85℃ 休眠电流 <5uA 屏幕大小 1.54英寸 有效显示区域 27.6mm 分辨率 200*200 色彩 1 bit 黑/白显示 对外接口 24P FPC (0.5mm间距) > 内部集成电路包含门缓冲器、源缓冲器，接口，时序控制逻辑，振荡器，DC DC，SRAM，LUT，VCOM ### SPMOD_Eink 模块引脚定义： 引脚序号 引脚名称 类型 引脚说明 1 GND G 模块电源地 2 CS I SPI片选引脚 3 D/C I 数据/命令输入切换引脚 4 RES I 模块复位引脚，低有效 5 3V3 V 模块电源输入正 6 SCK I SPI串行时钟引脚 7 SI I/O MOSI数据引脚，主机输出从机输入 8 BSY O BUSY状态输出引脚 <img src \"../../assets/spmod/spmod_eink/sp_eink_back.png\" height \"300\" /> 接线方式： MCU:FUN(IO) SP_Eink : : : : GPIOHS(IO_7) RES SPIOHS(IO_15) D/C SPIOHS(IO_20) CS SPI:SCK(IO_21) SCK SPI:MOSI(IO_8) SI GPIOHS(IO_6) BSY 2.3 3.6V 3.3V GND GND <img src \"../../assets/spmod/spmod_eink/connection.png\" height \"250\"> ### 基本指令列表 指令 功能 : : : : 0x10 开始发送黑白图像 0x13 开始发送红白图像 0x12 刷新图像到屏幕 *更多指令信息参考[GDEW0154M09.pdf](https://dl.sipeed.com/shareURL/MAIX/HDK/Spmod_CN/sp_eink)* ## 使用例程 * 流程 1. 初始化配置 2. 创建 Image 并填充 3. 发送图像并刷新 ### C 示例： ```c spi_init(1, SPI_WORK_MODE_0, SPI_FF_STANDARD, DATALENGTH, 0); fpioa_set_function(SPI_Eink_CS_PIN_NUM, FUNC_SPI1_SS0); // SPI_Eink_CS_PIN_NUM: 20; fpioa_set_function(SPI_Eink_SCK_PIN_NUM, FUNC_SPI1_SCLK); // SPI_Eink_SCK_PIN_NUM: 21; fpioa_set_function(SPI_Eink_MOSI_PIN_NUM, FUNC_SPI1_D0); // SPI_Eink_MOSI_PIN_NUM: 8; fpioa_set_function(SPI_Eink_DC_PIN_NUM, FUNC_GPIOHS0 + SPI_Eink_DC_GPIO_NUM); // SPI_Eink_DC_PIN_NUM: 21; fpioa_set_function(SPI_Eink_RST_PIN_NUM, FUNC_GPIOHS0 + SPI_Eink_RST_GPIO_NUM); // SPI_Eink_RST_PIN_NUM: 7; fpioa_set_function(SPI_Eink_BL_PIN_NUM, FUNC_GPIOHS0 + SPI_Eink_BL_GPIO_NUM); // SPI_Eink_BL_PIN_NUM: 6; gpiohs_set_drive_mode(SPI_Eink_DC_GPIO_NUM, GPIO_DM_OUTPUT); gpiohs_set_drive_mode(SPI_Eink_RST_GPIO_NUM, GPIO_DM_OUTPUT); gpiohs_set_pin(SPI_Eink_DC_GPIO_NUM, GPIO_PV_HIGH); gpiohs_set_pin(SPI_Eink_RST_GPIO_NUM, GPIO_PV_HIGH); gpiohs_set_drive_mode(SPI_Eink_BL_PIN_NUM, GPIO_DM_INPUT_PULL_UP); gpiohs_set_pin_edge(SPI_Eink_BL_PIN_NUM, GPIO_PE_BOTH); EPD_DisplayInit(); //EPD init //Paint initialization Paint_NewImage(BlackImage, EPD_WIDTH, EPD_HEIGHT, 270, WHITE); //Set screen size and display orientation Paint_SelectImage(BlackImage); //Set the virtual canvas data storage location Paint_Clear(WHITE); //clear paint Paint_DrawString_EN(0, 0, \"sipeed\", &Font8, WHITE, BLACK); //5*8 Paint_DrawString_EN(0, 10, \"sipeed\", &Font12, WHITE, BLACK); //7*12 Paint_DrawString_EN(0, 25, \"sipeed\", &Font16, WHITE, BLACK); //11*16 Paint_DrawString_EN(0, 45, \"sipeed\", &Font20, WHITE, BLACK); //14*20 Paint_DrawString_EN(0, 80, \"sipeed\", &Font24, WHITE, BLACK); //17*24 EPD_FullDisplay(BlackImage, BlackImage, 0); //display image ``` ### MaixPy 例程： ```python spi1 SPI(SPI.SPI1, mode SPI.MODE_MASTER, baudrate 600 * 1000, polarity 0, phase 0, bits 8, firstbit SPI.MSB, sck 21, mosi 8) fm.register(20, fm.fpioa.GPIOHS20, force True) # SPI_Eink_SS_PIN_NUM: 20; fm.register(15, fm.fpioa.GPIOHS15, force True) # SPI_Eink_DC_PIN_NUM: 15; fm.register(6, fm.fpioa.GPIOHS6, force True) # SPI_Eink_BUSY_PIN_NUM: 6; fm.register(7, fm.fpioa.GPIOHS7, force True) # SPI_Eink_RST_PIN_NUM: 7; cs GPIO(GPIO.GPIOHS20, GPIO.OUT) dc GPIO(GPIO.GPIOHS15, GPIO.OUT) busy GPIO(GPIO.GPIOHS6, GPIO.IN, GPIO.PULL_DOWN) rst GPIO(GPIO.GPIOHS7, GPIO.OUT) epd SPEink(spi1, cs, dc, rst, busy, SPEink_WIDTH, SPEink_HEIGHT, SPEink_ROTATION) epd.init() img image.Image() img img.resize(200, 200) img.draw_line(0, 0, 100, 100) epd.display(img) ``` ### 运行环境 语言 开发板 SDK/固件版本 : : : : : : C MaixCube kendryte standalone sdk v0.5.6 MaixPy MaixCube maixpy v0.5.1 *MaixPy固件建议自行从最新源码编译* ### 运行结果 * C <img src \"../../assets/spmod/spmod_eink/sp_eink_c.png\" height \"250\" /> * MaixPy <img src \"../../assets/spmod/spmod_eink/sp_eink_py.png\" height \"250\" /> ### 移植 修改以下参数即可 * C ```c // board_config.h #define SPI_INDEX 1 #define SPI_SCLK_RATE 600 * 1000 #define SPI_CHIP_SELECT_NSS 0 //SPI_CHIP_SELECT_0 #define SPI_Eink_CS_PIN_NUM 20 #define SPI_Eink_SCK_PIN_NUM 21 #define SPI_Eink_MOSI_PIN_NUM 8 #define SPI_Eink_DC_PIN_NUM 15 #define SPI_Eink_BL_PIN_NUM 6 #define SPI_Eink_RST_PIN_NUM 7 #define SPI_Eink_DC_GPIO_NUM 15 #define SPI_Eink_BL_GPIO_NUM 6 #define SPI_Eink_RST_GPIO_NUM 7 ``` * MaixPy ```python ################### config ################### SPI_Eink_NUM SPI.SPI1 SPI_Eink_DC_PIN_NUM const(15) SPI_Eink_BUSY_PIN_NUM const(6) SPI_Eink_RST_PIN_NUM const(7) SPI_Eink_CS_PIN_NUM const(20) SPI_Eink_SCK_PIN_NUM const(21) SPI_Eink_MOSI_PIN_NUM const(8) SPI_Eink_FREQ_KHZ const(600) ############################################## ``` ## 参考设计 SPMOD_Eink 尺寸图： <img src \"../../assets/spmod/spmod_eink/sipeed_spmod_eink.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maixhub.com](https://maixhub.com) SDK 相关信息 [https://dl.sipeed.com/shareURL/MAIX/SDK](https://dl.sipeed.com/shareURL/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/shareURL/MAIX/HDK](https://dl.sipeed.com/shareURL/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群 878189804 "},"/hardware/zh/modules_spmod/spmod_servo.html":{"title":"SPMOD - SERVO","content":"# SPMOD SERVO ## 概述 <img src \"../../assets/spmod/spmod_servo/sp_servo.png\" width \"\" height \"300\" /> SPMOD_SERVO (SERVO模块)。 ## SPMOD SERVO 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 利用SP MOD控制多达6个独立的PWM 9g舵机 舵机接口采用3P 2.54间距排针 独立的外部5V供电，通过USB Type C或者KF螺钉接线柱，不会从SP MOD取电 板载电源指示灯，通电状态一目了然 模块尺寸：35.0\\*20\\*1.6mm 功能特点： 参数 PWM 9g舵机接口*6 外接4.8 6V电源的情况下，可连接6个PWM 9g舵机并分别控制 外部供电电压 4.8V 6.0V 外部供电电流 视模块工作情况而定，通常小于1500mA 工作温度 40℃ ~ 85℃ ### SPMOD_SERVO 模块引脚定义： <img src \"../../assets/spmod/spmod_servo/sp_servo_pin.png\" width \"500\" /> ## 使用例程 待更新 ## 参考设计 SPMOD_SERVO 尺寸图： <img src \"../../assets/spmod/spmod_servo/sipeed_spmod_servo.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（六群） 636551897 "},"/hardware/zh/modules_spmod/spmod_template.html":{"title":"SPMOD - XXX","content":"# SPMOD XXX ## 概述 <img src \"../../assets/spmod/sipeed_spmod_xxx.jpg\" alt \"XXX\" style \"zoom:60%;\" /> SPMOD_XX(XX 模块)采用XXX。 ## SPMOD XXX 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 XXX 模块尺寸：X.XX\\*XX.X\\*XX.Xmm ### XXXX 介绍 XXXXX XXXX XXXX 功能特点： ### SPMOD_XXX 模块引脚定义： 引脚序号 引脚名称 类型 引脚说明 1 GND G XX 2 XXX I XX 3 MISO O XX 4 XXX I XX 5 XXX O XX 6 SCK I XX 7 MOSI I XX 8 VCC G XX ## 使用例程 MaixPy 例程： > NOTE: 待更新 STM32 例程： ## 参考设计 SPMOD_XXX 原理图： ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（六群） 636551897 "},"/hardware/zh/modules_spmod/spmod_grove.html":{"title":"SPMOD - Grove","content":"# SPMOD Grove ## 概述 <img src \"../../assets/spmod/spmod_grove/sp_grove.png\" width \"\" height \"400\" /> SPMOD_Grove(GROVE 模块) ## SPMOD Grove 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 作为拓展版，提供三个标准的Grove接口。方便您将Grove模块与SP MOD一起使用。 每条数据线均提供外部上拉。 提供高达1000mA的供电能力。 模块尺寸：35.0\\*10.0\\*2.1mm ## 概括 功能特点： 参数 Grove 连接器 (HY 2.0mm 4P连接器)*3 用于连接Grove线缆 排针4*2，间距2.54mm *1 用于和SP MOD接口连接 外部供电电压 视连接的模块而定 外部供电电流 视模块工作情况而定，通常小于1000mA 工作温度 30℃ ~ 85℃ ## 参考设计 SPMOD_Grove 尺寸图： <img src \"../../assets/spmod/spmod_grove/sipeed_spmod_grove.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群 （六群） 636551897 "},"/hardware/zh/modules_spmod/spmod_ethernet.html":{"title":"SPMOD - Ethernet","content":"# SPMOD Ethernet ## 概述 ![](../../assets/spmod/spmod_ethernet/sp_ethernet.png) SPMOD_Ethernet(网络扩展模块)采用 W5500 以太网主控芯片。 ## SPMOD Ethernet 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 通过SP MOD SPI接口连接 主控芯片：W5500 是一款集成全硬件 TCP/IP 协议栈的嵌入式以太网控制器。 SPI 速率理论上可达80MHz \t集成以太网数据链路层（MAC）和10BaseT/100BaseTX 以太网物理层（PHY），支持自动协商（10/100 Based全双工/半双工） 模块尺寸：35.76\\*19.74\\*8.7mm ### W5500 以太网主控芯片介绍 功能特点： 参数 工作电压 2.97V~3.63V 工作电流 <132mA 工作温度 40℃~85℃ 休眠电流 <15mA SPI 时钟 最高80MHz 全硬件TCP/IP协议栈 支持TCP、UDP、ICMP、IPv4、ARP、IGMP、PPPoE协议 > 支持8路独立硬件 Socket 同时通信 ,通信效率互不影响 ,内部32K字节收发缓存供TCP/IP包处理 ,支持掉电模式、网络唤醒 ,集成 10BaseT / 100Base T 以太网 PHY ,支持自动协商（全/半双工，10M/100M) ,不支持自动极性变换MDIX ### SPMOD_Ethernet 模块引脚定义： 引脚序号 引脚名称 类型 引脚说明 1 GND G 模块电源地 2 CS I SPI片选引脚 3 SO I/0 MISO数据引脚，主机输入从机输出 4 NC NC 悬空引脚，无功能 5 3V3 V 模块电源输入正 6 SCK I SPI串行时钟引脚 7 SI I/0 MOSI数据引脚，主机输出从机输入 8 NC NC 悬空引脚，无功能 <img src \"\" width \"300\" /> ## 使用例程 待更新 ## 参考设计 SPMOD_Ethernet 尺寸图： <img src \"../../assets/spmod/spmod_ethernet/sipeed_spmod_ethernet.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（六群） 636551897 "},"/hardware/zh/modules_spmod/spmod_extender.html":{"title":"SPMOD - Extender","content":"# SPMOD Extender ## 概述 ![](../../assets/spmod/spmod_extender/sp_extender.png) SPMOD_Extender(8PIN扩展模块) ## SPMOD Extender 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 利用SP Extender将SP MOD一分为四，包含三个相连的2线接口（连接至SP MOD的D0和D1）和一个单独的四线接口（连接至SP MOD的D2 D5） 模块尺寸：35.0\\*20.0\\*1.6mm ## 概括 功能特点： 参数 两线SP MOD接口*3 连接至SP MOD的D0和D1，可用作UART (最多连接一个设备)或I2C（最多连接三个设备）或者两个独立的GPIO 四线SP MOD接口 连接至SP MOD的D2 D5，通常用作SPI接口，也可用作四个杜立的GPIO接口 外部供电电压 视连接的模块而定 外部供电电流 视模块工作情况而定，通常小于1000mA 工作温度 40℃ ~ 85℃ ## 参考设计 SPMOD_Extender 尺寸图： <img src \"../../assets/spmod/spmod_extender/sipeed_spmod_extender.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（六群） 636551897 "},"/hardware/zh/modules_spmod/spmod_rfid.html":{"title":"SPMOD - RFID","content":"# SPMOD RFID ## 概述 <img src \"../../assets/spmod/spmod_rfid/sp_rfid.png\" style \"padding right:100px;\" width \"\" height \"300\" /> SPMOD_RFID (NFC 模块)采用复旦微电子 FM17510 高度集成的非接触式（13Mhz）的读写芯片。 ## SPMOD RFID 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 利用SP MOD SPI和RFID模块通讯 64Byte收发缓冲FIFO RIFC IC 为 FM17510。 模块尺寸：25.0\\*20.1\\*6.2mm ### FM17510 介绍 FM17510 是一款高度集成的工作在 13.56MHz 下的非接触读写器芯片，支持符合 ISO/IEC 14443 TypeA 协议的非接触读写器模式。 同时提供了低功耗的外部卡片侦测功能，方便电池供电、需要低功耗工作、并且需要实时处理任意 时刻会进入射频场的外部卡片的读写器设备。 FM17510 具有低电压、低功耗、 单端驱动等特点。适用于低功耗、低电压、低成本要求的非接触读。 FM1750XX 在软硬件层面上兼容 MFRC552，支持工作模式： FM17510 功能特点： 支持 ISO/IEC 14443 TypeA 读写器模式 读写器模式支持 M1 加密算法 ISO14443 TYPEA 支持通讯速率 106kbps， 212kbps， 424kbps 支持 SPI 串行接口，最高 10Mbps Host 接口独立电源供电，电压范围 2.2~3.6V 工作温度范围 40℃ ~ 85℃ 64Byte 收发缓冲 FIFO 中断输出模式灵活可配 多种低功耗模式 : Soft powerdown模式 , Hard powerdown 模式, Deep powerdown 模式（典型值 1uA） 支持低功耗外部卡片侦测功能 可编程定时器 内置振荡电路外接 27.12MHz 晶振 宽电压工作范围 2.2V~3.6V 内置 CRC 协处理器 可编程 I/O 引脚 ### SPMOD_RFID 模块引脚定义： 引脚序号 引脚名称 类型 引脚说明 Note 1 GND G 模块电源地 2 CS I SPI片选引脚 3 SO I/O MISO数据引脚，主机输入从机输出 4 NPD I 复位/休眠控制引脚 5 3V3 V 模块电源输入正 6 SCK I SPI串行时钟引脚 7 SI I/O MOSI数据引脚，主机输出从机输入 8 IRQ O 模块中断输出引脚 > 当 NPD 引脚为低电平时，模块进入休眠状态；当 NPD 引脚输入一个上升沿时，模块复位。 <img src \"../../assets/spmod/spmod_rfid/back.png\" height \"300\" /> 接线方式: MCU:FUN(IO) SP_RFID : : : : NC(IO_7) NPD SPI:MISO(IO_15) SO SPI:SS0(IO_20) CS SPI:SCK(IO_21) SCK SPI:MOSI(IO_8) SI NC(IO_6) IRQ 2.2~3.6V 3.3V GND GND <img src \"../../assets/spmod/spmod_rfid/connection.png\" height \"250\"> ## 使用例程 * 流程 1. 初始化 2. 扫描并绑定卡片 3. 读写数据 ### C 示例： ```c fpioa_set_function(RFID_CS_PIN, FUNC_GPIOHS0 + RFID_CS_HSNUM); // RFID_CS_PIN: 20; fpioa_set_function(RFID_CK_PIN, FUNC_GPIOHS0 + RFID_CK_HSNUM); // RFID_CK_PIN: 21; fpioa_set_function(RFID_MO_PIN, FUNC_GPIOHS0 + RFID_MO_HSNUM); // RFID_MO_PIN: 8; fpioa_set_function(RFID_MI_PIN, FUNC_GPIOHS0 + RFID_MI_HSNUM); // RFID_MI_PIN: 15; gpiohs_set_drive_mode(spi_io_cfg.hs_cs, GPIO_DM_OUTPUT); gpiohs_set_drive_mode(spi_io_cfg.hs_clk, GPIO_DM_OUTPUT); gpiohs_set_drive_mode(spi_io_cfg.hs_mosi, GPIO_DM_OUTPUT); gpiohs_set_drive_mode(spi_io_cfg.hs_miso, GPIO_DM_INPUT); // detected card PcdRequest(0x52, type) // auth and bind... // read or write 16 bytes data from sector 0x11 PcdWrite(0x11, w_buf) PcdRead(0x11, &r_buf) ``` ### MaixPy 例程： ```python # 20: CS_NUM; fm.register(20, fm.fpioa.GPIOHS20, force True) # set gpiohs work mode to output mode cs GPIO(GPIO.GPIOHS20, GPIO.OUT) # RFID_SCK: 21; RFID_SI:8; RFID_SO: 15; spi1 SPI(SPI.SPI1, mode SPI.MODE_MASTER, baudrate 600 * 1000, polarity 0, phase 0, bits 8, firstbit SPI.MSB, sck 21, mosi 8, miso 15) # Create an object of the class MFRC522 MIFAREReader MFRC522(spi1, cs) # detected and auth, bind... # read or write 16 bytes data from sector 0x11 MIFAREReader.MFRC522_Write(0x11, data) MIFAREReader.MFRC522_Read(0x11) ``` ### 运行环境 语言 开发板 SDK/固件版本 : : : : C MaixCube kendryte standalone sdk v0.5.6 MaixPy MaixCube maixpy v0.5.1 ### 运行结果 * C <img src \"../../assets/spmod/spmod_rfid/c_log.png\" height \"200\" /> * MaixPy <img src \"../../assets/spmod/spmod_rfid/maixpy_log.png\" height \"200\" /> ### 移植 修改以下参数即可适配其他 K210 开发板. * C ```c // board_config.h #define RFID_CS_PIN (20) #define RFID_CK_PIN (21) #define RFID_MO_PIN (8) #define RFID_MI_PIN (15) #define RFID_CS_HSNUM (20) #define RFID_CK_HSNUM (21) #define RFID_MO_HSNUM (8) #define RFID_MI_HSNUM (15) ``` * MaixPy ```python ################### config ################### CS_NUM const(20) SPI_FREQ_KHZ const(600) SPI_SCK const(21) SPI_MOSI const(8) SPI_MISO const(15) ############################################# ``` ## 参考设计 SPMOD_RFID 尺寸图： <img src \"../../assets/spmod/spmod_rfid/sipeed_spmod_rfid.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（六群） 636551897 "},"/hardware/zh/lichee/index.html":{"title":"Lichee Pi","content":" title: Lichee Pi > 编辑与2022年3月11日 Lichee 是 [Sipeed](https://www.sipeed.com/) 推出的开源产品，是为了能让用户获得优廉的linux设备，实战linux底层相关的内容的产品。 目前LicheePi相关核心板部分参数对比表格如下： 类别 Lichee RV Lichee Zero PlusLichee ZeroLichee nano : : : : : SOC Allwinner D1 Allwinner S3 Allwinner V3s Allwinner F1c100s CPU架构 玄铁 C906 Cortex™ A7 Cortex™ A7 ARM 926EJS 运行频率1GHz1.2GHz1.2GHz(max)600MHz(max) RAM 512MB DDR3 128Mbyte DDR3 64MB DRAM 32MB DDR FLASH可选SD nand可选SD Nand、<br>SPI Nor Flash<br>或者eMMC 预留<br>SOP8 SPI Flash<br>焊盘板载 16MB NOR FLASH TF连接器 有有有有 上述的款型都可以通过sd卡启动系统 其他参数过多，版面放不下，需要的话麻烦自行对比一下。 ## Lichee 核心版照片(Linux) ### Lichee Zero <div align \"center\"> <a href \"./Zero/Zero.html\" ><img src \"./assets/Zero/Zero_1.png\" width 400></a> </div> ### Lichee Nano <div align \"center\"> <a href \"./Nano/Nano.html\" ><img src \"./assets/Nano/Nano_2.png\" width 400></a> </div> ### Lichee Zero Plus <div align \"center\"> <a href \"./ZeroPlus/ZeroPlus.html\"><img src \"./assets/Zero Plus/Plus_1.jpg\" width 400></a> </div> ### Lichee RV <div align \"center\"> <a href \"./RV/RV.html\"><img src \"./assets/RV/D1 4.png\" width 400></a> </div>"},"/hardware/zh/lichee/RV/86_panel.html":{"title":"Lichee 86 Panel","content":"# Lichee 86 Panel ## 概述 Lichee RV 86 Panel是为智能家居中控应用场景而设计的开发套件。在硬件上，套件包含了LicheeRV 核心板（全志D1+512MB DDR3)、4英寸 IPS 显示屏+电容触摸屏、WIFI + BT、以太网、双数字硅麦和 GPIO 拓展接口等。 在软件上，我们提供了 Linux 系统（OpenWRT 及 Debian )和阿里 WAFT 开发环境( WAFT 是阿里基于 WebAssembly 和自研的渲染引擎打造的一款面向 AIOT 的高性能应用框架)。 ![裸板视图](./../assets/RV/86_2.png) ## 参数 项目 参数 核心模块 Sipeed LicheeRV 哪吒计算条 显示 默认搭配为4英寸480\\*480 IPS标清电容触摸屏<br>可选升级为4英寸720\\*720 IPS高清电容触摸屏<br>预留8英寸1280\\*800 IPS电容触摸屏接口 音频 板载1W小扬声器，双路数字硅麦 网络 XR829 WIFI+BT无线模块<br>RTL8201F百兆以太网<br>预留板载RJ45以太网接口 USB 核心板带有USB C OTG接口 <br>底板预留USB C HOST 与USB转串口电路 电源 支持5V,12V供电(板载DC DC ) 扩展引脚 双2x8Pin 2.54mm 排针，预留FPCIO引出 外壳 选配86盒3D打印外壳，图纸开源 尺寸 86x86mm 适用场景 智能家居中控，WAFT UI评估 开发框架 支持WAFT (WebAssembly Framework For Things）环境 系统支持 支持 OpenWRT及 Debian系统 开发资源 提供原厂SDK的 Docker开发镜像 ![板子功能](./../assets/RV/86_pin.png) ## 相关链接 [下载站](https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV_86_panel) [烧录系统](./flash.html) [相关使用](./user.html) ## 产品技术支持 Lichee RV 86 Panel 可以在多种场景实现客户不同方面的需要，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务 <support@sipeed.com>。"},"/hardware/zh/lichee/RV/RV.html":{"title":"Lichee RV - Nezha CM","content":"# Lichee RV Nezha CM ## 概述 Lichee RV Nezha CM是模块化设计的核心计算模组，搭载全志D1主控芯片(基于平头哥玄铁C906处理器），512MB DDR3内存，可选启动介质为TF卡或者SDNAND芯片，并使用两组M.2B KEY 67 Pin金手指引出所有l0，方便量产使用，也方便安装替换。 ![](./../assets/RV/D1 4.jpg) ![](./../assets/RV/D1 back.jpg) ## 参数 项目 参数 CPU 全志 D1 阿里平头哥 玄铁 C906 内核，主频 1GHz 内存 16bit 512MB DDR3，时钟频率 792MHz 存储 板载 TF 卡连接器，可插入 TF 卡作为存储，已测试能够识别1TB容量的卡； <br>预留 SD NAND 焊盘（与 8pin LCD 接口冲突，用于商业应用定制） 显示接口 MIPI：引出 4 lane MIPI DSI 至金手指 <br>RGB：引出 RGB888（部分与 DSI 复用） 至金手指 <br>MCU(I80)：引出 I80 接口至金手指 <br>SPI：板载 8pin SPI 液晶屏接口，可扩展 1.14 英寸液晶屏 音频接口 模拟音频耳机输出(HPOUT)： 引出至金手指 <br>模拟音频线路输入(LINEIN)： 引出至金手指 <br>数字音频 (I2S/SPDIF)： 引出至金手指 <br>模拟麦克风接口(MIC3)： 引出至金手指 <br>数字麦克风接口(DMIC)： 引出至金手指 以太网 引出 RMII/RGMII 接口至金手指（与部分 GPIO 复用） USB 板载 TYPE C USB OTG 接口(USB0) <br>USB HOST 引出至金手指(USB1) GPIO 剩余 GPIO 全部引出至金手指 按键 • FEL 按键（进入下载模式） 指示灯 • 一个电源指示灯 <br>• 一个用户指示灯（高电平有效） PCB 板层 4 层 固定方式 通过两组 M.2 B KEY 金手指连接器与底板连接，使用一颗 M2 螺丝紧固 支持开发语言 C/C++, Python, Golang, etc... 系统镜像 Tina Linux(基于OpenWRT 14.07)、 Debian、YoC (RTOS ) ![](./../assets/RV/D1 pin.png) ## 底板之间的对比 项目 Lichee RV Dock Lichee RV Panel : : SOC 全志D1（XuanTie C906 RISC V） 全志D1（XuanTie C906 RISC V） 内存 1GByte 1GByte 无线网络 可选择：<br> 2.4G WIFI+BT<br> 无（可以自行焊接其他型号的WIFI模块调试）\t 2.4G WIFI+BT 有线网络 无\t 支持100M以太网 影像输出 HDMI连接器 <br>SPI接口屏幕连接器 <br>连接屏幕转接板，可以实现：<br> 常用RGB接口屏幕连接器（含TP引脚）（支持我们店铺的4.3寸/5.0寸屏）<br> MIPI接口屏幕连接器（兼容Nezha开发板适配的8寸屏） sRGB接口屏幕连接器（含TP引脚）（支持标配的4寸IPS屏带TP） <br>MIPI接口屏幕连接器（兼容Nezha开发板适配的8寸屏） USB端口 \"1个USB OTG(核心板板载的USB C座子) <br> 1个USB Host(底板板载的USB A座子) 1个USB OTG(核心板板载的USB C座子) <br>1个USB Host(底板板载的USB C座子) 拓展接口 支持麦克风阵列板<br>大部分GPIO通过2x20P直插焊盘引出 小部分GPIO通过直插焊盘引出 音频 板载3W音频功放 <br>板载驻极体麦克风电路 板载3W音频功放 <br>板载2个MEMS数字麦克风 按键\t 1个FEL按键（进入下载模式）<br>1个RST按键（复位）<br>1个用户按键 1个FEL按键（进入下载模式） LED 1个电源指示灯<br>1个2812 RGB LED 1个电源指示灯 外壳 无 有3D打印外壳 尺寸 65.0mm x 40.0mm 86.0mm x 86.0mm ## 连接1.14寸屏幕 ![](./../assets/RV/D1 1.png)![](./../assets/RV/D1 2.png)![](./../assets/RV/D1 3.png) > 目前 1.14 显示屏是点不亮的，需要等待后续的更新; ## 系统烧录 [烧录教程](./flash.html) ## 注意事项 当前核心板的USB Type C连接器使用CC引脚作为自动OTG的识别引脚，但是与USB C to C 数据线的识别存在冲突，只能使用A to C数据线，可在硬件上改动器件进行切换，共有两种工作方式，具体特性对应如下： Type C工作模式 OTG（出厂默认产品） CC识别（需要改动硬件） : : : : 电阻R30与电阻R31 不贴 贴装5.1K 1% 0402电阻 二极管D3与D4 贴装4148二极管 不贴 是否兼容C to C数据线 否 是 是否兼容A to C 数据线 是 是 是否支持自动OTG切换 是 否 如需使用C to C数据线，则需要改动TypeC接口周围的器件对应CC识别模式，并在需要扩展外置USB设备时手动切换为HOST模式。核心板正面位号图如下，供参考： > ① 换上5.1K 1% 0402电阻，② 拆除二极管 ![](./../assets/RV/other.png) ![](./../assets/RV/D1Core2.png) ## 资料下载 [硬件资料下载](https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV/HDK) Debian 系统镜像请到 >[百度网盘](https://pan.baidu.com/s/1QJTaDw6kkTM4c_GAlmG0hg)(提取码：`wbef`) >[Mega netdisk](https://mega.nz/folder/lx4CyZBA#PiFhY7oSVQ3gp2ZZ_AnwYA) [源码获取](/hardware/zh/lichee/RV/user.html#BSP SDK 开发指南) ## 相关问题 [licheeRV debian镜像相关问题](https://wiki.sipeed.com/hardware/zh/lichee/RV/problems.html#apt %E7%9B%B8%E5%85%B3)"},"/hardware/zh/lichee/RV/Dock.html":{"title":"Lichee Dock","content":"# Lichee Dock ## 概述 Lichee RV Dock 是为开源开发者而设计的一款功能**集成度高**、**体积小**且价格亲民的RISC V Linux开发板套件。它不仅支持 **HDMI 输出**，搭配屏幕转接板更可以支持多种的屏幕显示（**MIPI、RGB和MCU接口**）。它同时具备丰富的外设，包括一个主机 **USB A** 接口，**2.4G Wi Fi+BT** 模块，一个模拟麦克风和扬声器插口等。使用者拿到套件之后，无需等待和焊接，即可用套件连接显示器和 USB 设备快速上手开发各种有趣且实用的 Linux 应用，较大地**加速了**开发者的试研和开发工作。除此之外，用户还可以利用开发板的多种显示接口，无线功能和 GPIO ，搭配板载麦克风和扬声器，快速实现各种创意。 ![外观图](./../assets/RV/RV Dock.jpg) ## 参数 项目 参数 支持的核心板 Lichee RV 核心板 显示输出接口 板载一个显示输出连接器；<br>RGB屏幕信号和MIPI屏幕信号连接到2x20P排针焊盘 <br>（可以使用我们的屏幕转接板驱动RGB接口或者MIPI接口的屏幕） 网络连接 板载2.4G WIFI+BT模组、2.4G 贴片天线、IPEX连接器 USB 板载一个USB type A母座 音频 板载扬声器驱动电路（最高支持4Ω3W扬声器）和扬声器连接器<br>板载驻极体麦克风电路 存储 预留了一个SOP8焊盘，SPI协议，默认不焊接元件 拓展连接器 板载30P FPC连接器，可以直接连接到我们的Mic Array R6 麦克风阵列板 GPIO拓展 通过2x20P 2.54mm 焊盘引出GPIO供用户使用 LED 板载一个WS2812 RGB LED<br>板载一个电源指示灯 按键 板载一个复位RST按键<br>板载一个用户按键 ## 相关链接 [规格书](https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV Dock/1_Datasheet) [原理图](https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV Dock/2_Schematic) [点位图](https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV Dock/3_Bitmap) [尺寸图](https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV Dock/4_Dimensions) [3D 模型文件](https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV Dock/5_3D) [使用教程](./flash.html) ## 产品技术支持 Lichee RV Dock 可以在多种场景实现客户不同方面的需要，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务 support@sipeed.com。"},"/hardware/zh/lichee/RV/problems.html":{"title":"相关问题","content":" title: 相关问题 keywords: debian, Rv, Problam, apt, img, sipeed ## apt 相关 在使用默认debian镜像时，如果进行apt操作，发现以下报错： > GPG error: http://ftp.ports.debian.org/debian ports sid InRelease: The following signatures couldn't be verified because the public key is not available: NO_PUBKEY E852514F5DF312F6 说明内置的密钥到期了，需要手工更新下密钥；下面是两种下载密钥的方式： 网页下载：https://packages.debian.org/sid/all/debian ports archive keyring/download wget方式 `wget http://ftp.cn.debian.org/debian/pool/main/d/debian ports archive keyring/debian ports archive keyring_2022.02.15_all.deb` 将密钥拷贝（使用scp或者lrzsz工具）到LicheeRV板上，执行： > sudo dpkg i debian ports archive keyring_2022.02.15_all.deb 即可更新密钥，然后可以正常进行apt更新：`sudo apt get update` ## 启动无反应 确认自己在使用 PhoenixCard 的时候选择的是 `启动卡` ![](./../assets/RV/flash.png) 对于使用Tina系统的是可以用adb终端来连接进行通信 直接将电脑与核心板相连即可 ![](./../assets/RV/adb shell.png) 对于debian系统只能使用串口来通信 ## 86 panel 烧录后屏幕无反应/显示不对 需要在linux系统中使用下面命令来和对应的fex文件来覆盖板级配置 fex下载地址 https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV/SDK/board 覆盖指令为 ```bash sudo dd if boot_package_XXX.fex of /dev/sdX bs 1K seek 16400 ``` 上面命令中的 sdX 为 TF 卡在 linux 系统中的命名。 有问题的话可以去[论坛](https://bbs.sipeed.com/)发帖"},"/hardware/zh/lichee/RV/user.html":{"title":"基础上手","content":"# 基础上手 ## Dock 相关使用 ### 连接板子 我们可以很容易看到底板背部上有串口的 TX 和 RX 引脚标识。因此可以使用 ttl 电平的串口来使板子与电脑进行通信（Tina和Debian均适用）。 对于 Tina 系统可以使用核心板上的 typec 接口和电脑上的 adb 终端来进行连接 对于 Debian 系统可以外接键盘和鼠标来直接操作 #### Debian 相关事项 启动会比较慢，取决于TF卡的速度。 用户名为 `root` 密码是 `licheepi` **使用串口与 debian 系统连接的话会一直打印内核信息。解决方法是：** 使用root权限编辑 `/etc/rsyslog.conf` 并且把文件最后一行中的 `*.emerg` 改成 `#*.emerg` 重启 rsyslog 服务，直接执行 `/etc/init.d/rsyslog restart` 即可 **想要在图形化界面中调出命令行的方法：** 键盘执行 `Alt+F2` 打开运行，接着在里面输入 `termit` 即可打开命令行终端。 ### 点灯示例 当我们成功进入系统(Tina和debian均可)后，就可以进行基础的点灯操作啦！ 核心板的螺丝固定焊盘旁有一颗 LED ，查看尺寸图很容易看到： <details> <summary><font color \"#4F84FF\">点开查看尺寸图</font></summary> <img src \"./../assets/RV/rv_coreboard_dimension.png\"> </details> 从[原理图](https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV/HDK/2_Schematic)可以查到 LED 连接的是 PC0 引脚，根据简单的公式 ('C' 'A')x32 + 0 2x32+0 64 当然我们也可以查看 pinmux pins 文件中的内容来知道 IO 复用情况表： ```bash cat /sys/kernel/debug/pinctrl/2000000.pinctrl/pinmux pins ... pin 64 (PC0): device 2008000.ledc function ledc group PC0 #这里可以看到是LED引脚 pin 65 (PC1): UNCLAIMED pin 66 (PC2): UNCLAIMED pin 67 (PC3): UNCLAIMED pin 68 (PC4): UNCLAIMED pin 69 (PC5): UNCLAIMED pin 70 (PC6): UNCLAIMED pin 71 (PC7): UNCLAIMED ... ``` 我们先导出该 GPIO： ```bash echo 64 > /sys/class/gpio/export #导出GPIO64 ``` 然后再将该 IO 置为输出状态，即可操作其电平： ```bash echo out>/sys/class/gpio/gpio64/direction #设置IO为输出 echo 1 > /sys/class/gpio/gpio64/value #输出高电平 echo 0 > /sys/class/gpio/gpio64/value #输出低电平 ``` 上面的是最简单的使用 IO 的操作了，就不细说了吧。 不使用IO的话就取消导出 ```bash echo 64 > /sys/class/gpio/unexport #取消导出GPIO64 ``` 至此我们就成功在 RISC V 64 D1上点灯啦~ 你也可以对 串行RGB LED WS2812 进行花式点灯： ```bash echo 255 > /sys/class/leds/sunxi_led0r/brightness #红灯亮 echo 0 > /sys/class/leds/sunxi_led0r/brightness #红灯灭 echo 255 > /sys/class/leds/sunxi_led0g/brightness #绿灯亮 echo 0 > /sys/class/leds/sunxi_led0g/brightness #绿灯灭 echo 255 > /sys/class/leds/sunxi_led0b/brightness #蓝灯亮 echo 0 > /sys/class/leds/sunxi_led0b/brightness #蓝灯灭 ``` ### 外设功能验证 #### 音频功能 录音设备查看 使用 `arecord l` 命令 ```bash root@MaixLinux:~# arecord l **** List of CAPTURE Hardware Devices **** card 0: audiocodec [audiocodec], device 0: SUNXI CODEC 2030000.codec 0 [] Subdevices: 1/1 Subdevice 0: subdevice 0 card 1: snddmic [snddmic], device 0: 2031000.dmic dmic hifi dmic hifi 0 [] Subdevices: 1/1 Subdevice 0: subdevice 0 card 2: sndhdmi [sndhdmi], device 0: 2034000.daudio audiohdmi dai 20340a4.hdmiaudio 0 [] Subdevices: 1/1 Subdevice 0: subdevice 0 ``` 播放设备查看 使用 `aplay l` 命令 ```bash root@MaixLinux:~# aplay l **** List of PLAYBACK Hardware Devices **** card 0: audiocodec [audiocodec], device 0: SUNXI CODEC 2030000.codec 0 [] Subdevices: 1/1 Subdevice 0: subdevice 0 card 2: sndhdmi [sndhdmi], device 0: 2034000.daudio audiohdmi dai 20340a4.hdmiaudio 0 [] Subdevices: 1/1 Subdevice 0: subdevice 0 ``` 录音播放测试： ```bash arecord D hw:1,0 f S16_LE t wav d 3 t.wav #录音 ``` ```bash aplay D hw:0,0 t.wav #播放录音 ``` 另外可以使用 alsamixer 进行音量调整 <details> <summary><font color \"#4F84FF\">点开查看运行alsamixer</font></summary> <pre><code class \"language shell\">┌────────────────────────────── AlsaMixer v1.2.4 ──────────────────────────────┐ │ Card: audiocodec F1: Help │ │ Chip: F2: System information │ │ View: F3:[Playback] F4: Capture F5: All F6: Select sound card │ │ Item: Headphone [dB gain: 24.00] Esc: Exit │ │ │ │ ┌──┐ ┌──┐ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ → │ │ │ │ │ → │ │ │ │▒▒│ → │ │ │ │▒▒│ → │ │ │ │▒▒│ → │ │ │ │▒▒│ → │ │▒▒│ │▒▒│ → │ │▒▒│ │▒▒│ │ │ │▒▒│ │▒▒│ │ │ ├──┤ ┌──┐ ┌──┐ Off ┌──┐ ┌──┐ ┌──┐ └──┘ │ │ │MM│ │MM│ │MM│ │MM│ │MM│ │MM│ │ │ └──┘ └──┘ └──┘ └──┘ └──┘ └──┘ │ │ 25 63 │ │ &lt;Headphon>FMINL ga FMINR ga ADC1 ADC ADC1 Inp ADC1 Inp ADC1 Inp ADC1 vol │ └──────────────────────────────────────────────────────────────────────────────┘</code></pre> </details> #### USB功能 默认内核支持外挂U盘的驱动，插上U盘后可以使用 `fdisk l` 指令查看到新增的 /dev/sda 设备 <br> 如果U盘没有被格式化，应该使用mkfs.vfat指令来格式化U盘，再使用mount指令挂载U盘。 #### 无线网络 ##### **使用 Tina 系统** LicheeRV 底板默认使用 XR829 或者 RTL8723BS wifi 模块，可以使用以下指令进行联网操作 先配置热点信息：需要手动在 /etc/wifi 目录下的 wpa_supplicant.conf 文件里添加下面内容 ```bash network { ssid \"WiFi_name\" psk \"WiFi_password\" } ``` 配置完成后重启一下(执行 `reboot` 命令即可)，重启完成后执行 `ifconfig wlan0 up; udhcpc iwlan0 &` 后即可连上对应的wifi。 连上网络后，就可以使用 ssh (自己记得设置一下密码)来远程登录板卡，或者使用 scp 来进行文件传输。 ##### **使用 debian 系统** > Debian 不支持命令行联网 点击系统菜单 Preferenes Connman Settings，打开 Network Settings ，查看网络属性中的 Interface 是否为 wlan0。双击网络名称，并输入 WiFi 密码进行连接 ![](./../assets/RV/wifi 1.jpg) 成功连接网络之后，通过系统系统菜单 Preferenes Connman Settings，查看网络属性查看网络的 IP 地址 ![](./../assets/RV/wifi 2.jpg) #### 屏显触摸 LicheeRV系列可以使用以下显示屏： SPI屏\t\t1.14寸屏(TODO) RGB屏\t\t4.3寸 480x272；5.0寸 800x480； RGB+SPI屏\t4.0寸 480x480(st7701s); 4.0寸 720x720(nv3052c) MIPI屏\t\t8.0寸 1280x720(ILI9881C) 如果需要调试屏幕驱动，可以使用以下指令查看屏幕驱动信息： 以下信息根据烧录镜像的不同而打印的不一样。 ```bash cat /sys/class/disp/disp/attr/sys screen 0: de_rate 300000000 hz, ref_fps:60 mgr0: 480x480 fmt[rgb] cs[0x204] range[full] eotf[0x4] bits[8bits] err[0] force_sync[0] unblank direct_show[false] iommu[1] dmabuf: cache[0] cache max[0] umap skip[0] overflow[0] \tlcd output\tbacklight( 50)\tfps:59.5\tesd level(0)\tfreq(60)\tpos(0)\treset(0)\t 480x 480 \terr:0\tskip:184\tirq:230715\tvsync:0\tvsync_skip:0 BUF enable ch[1] lyr[0] z[16] prem[N] a[globl 255] fmt[ 0] fb[ 480, 480; 480, 480; 480, 480] crop[ 0, 0, 480, 480] frame[ 0, 0, 480, 480] addr[ffe00000, 0, 0] flags[0x 0] trd[0,0] ``` 屏幕彩条测试：`echo 1 > /sys/class/disp/disp/attr/colorbar` #### 视频播放 我们可以尝试在LicheeRV上播放BadApple啦~ [视频文件下载](https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV/MP4) Tina镜像中内置了ffmpeg软件包；ffmpeg是强大的多媒体库，可以用于录屏或者播放 录屏指令： ```bash ffmpeg f fbdev framerate 10 i /dev/fb0 record.avi ``` 播放指令（分别是扬声器播放音频和hdmi播放音频）： ```bash ffmpeg i /mnt/UDISK/badapple_640480_xvid.mp4 pix_fmt bgra f fbdev /dev/fb0 f alsa hw:0,0 ffmpeg i /mnt/UDISK/badapple_640480_xvid.mp4 pix_fmt bgra f fbdev /dev/fb0 f alsa hw:2,0 ``` 这里由于是CPU软解，所以测试最高分辨率约为720x540， 再高会变卡 <iframe src \"https://player.bilibili.com/player.html?aid 209723771&bvid BV1xa411r7PP&cid 457742249&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> #### 麦克风阵列(仅debian系统) 将板子与麦克风阵列连接好后（需要注意不要将排线接反和不要把引脚接反。），直接执行内置的 `micarr_0609` 指令即可即 ```bash sudo ./micarr_0609 ``` 有麦克风阵列相关的二次开发需求，可以联系 support@sipeed.com ![](./../assets/RV/mic_array_picture.jpg) <iframe src \"https://player.bilibili.com/player.html?aid 849734125&bvid BV1HL4y1H7nv&cid 457750392&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> ## 86Panel 如果烧录后显示不正确或者不对劲的话，前往[相关问题](./problems.html)纠错一下 下面仅进行简单的操作。另外上面 dock 板子的操作同样适用于 86Panel。 对于使用 tina 系统的是没有 GUI 界面的。因此下面使用 debian 简单展示一下屏幕 烧录 debian 系统后，插卡启动，等待2分钟左右，屏幕上就会显示登录界面 ![登录界面](./../assets/RV/LicheeRV_login_picture.png \"登录界面\") 输入用户名 sipeed，密码 licheepi，即可进入桌面 （使用USB HOST口外接键盘鼠标进行输入） ![桌面样式](./../assets/RV/desktop_appearance.png \"桌面样式\") 进入桌面后可以进行一些基础操作 Alt+F2 可以打开 运行 ，接着输入 termit 即可打开命令行终端 ![基础操作](./../assets/RV/Basic_operation.png \"基础操作\") 接下来让我们尝试在Debian下跑一下Hello World: ![运行自制程序](./../assets/RV/Run_HelloWorld.png \"运行自制程序\") 另有720P高清屏的效果对比，有米的朋友可以考虑入手。 注意使用的时候应当烧录一下板级配置文件来成功显示，具体请看[86panel显示异常](problems.html#86 panel 烧录后屏幕无反应显示不对) 实际显示效果如下： ![高清显示_1](./../assets/RV/display_1.png) ![高清显示_2](./../assets/RV/display_2.png) ### 点灯操作 由于 86Panel 的核心板的 LED 与底板外设复用了，因此不能直接使用核心板的灯了。 将直插型 LED 正确地与预留的 IO 焊盘连接好后可以参考 dock 底板点灯的方式来点灯。 ### 连接网络 #### 有线网络 86 Panel 支持百兆网络，使用套餐附送的网线接上板子网口后，执行以下指令来连接有线网络 ```bash ifconfig eth0 up udhcpc ieth0 ``` #### 无线网络 可以参考 Dock 底板连接[网络的方法](#无线网络) ### 其他 与 dock 底板相关操作一致 ### 触摸屏测试 <font color #16B2C>仅 tina 系统内置 触摸demo</font> 如果你购买的是86面板套餐，可以使用 ts_test 进行触摸测试。 > 注意触摸驱动有瑕疵，ts_test测试时松开后，光标会不动，但是终端仍会正常打印信息 ```bash root@MaixLinux:/# ts ts_calibrate ts_harvest ts_print_mt ts_test ts_verify ts_finddev ts_print ts_print_raw ts_test_mt tshowimg ``` ## BSP SDK 开发指南 为了方便用户自行开发，矽速整理发布了 LicheeRV 的bsp开发docker镜像，大家使用该镜像可以快速开始D1的系统级开发。 国内用户：[百度网盘](https://pan.baidu.com/s/1QJTaDw6kkTM4c_GAlmG0hg) 提取码：wbef 国外用户：[Mega](https://mega.nz/folder/lx4CyZBA#PiFhY7oSVQ3gp2ZZ_AnwYA) 在网盘中下载对应的docker文件后，解压到tar文件后导入到docker ```bash gzip d licheerv_d1_compile.tar.gz #解压成tar文件 docker import licheerv_d1_compile.tar licheerv_d1_compile:latest #docker导入镜像 ``` 成功运行后应当重新登陆一次；用户名为 `nihao`，密码为 `sipeed123` ```bash sudo docker run it licheerv_d1_compile:latest /bin/bash # 交互模式启动D1镜像编译环境 login #切换用户 ``` 进入容器后的基础编译操作为： ```bash cd ~/sdk/tina d1 open_new/ source build/envsetup.sh lunch #选1 make menuconfig #去掉里面的 alsa plugin 选项，否则编译不过 # alsa plugins 在 menuconfig 中的位置如下 #. #└── Libraries # └── alsa plugins make j8 #按实际CPU性能编译 pack #打包 ``` SDK内置了一些版型的dts，你可以自行选择编辑： device/config/chips/d1/configs/nezha/board_xxx.dts 其他SDK的开发说明，可以参见全志开发平台上下载的相关文档 https://open.allwinnertech.com/ 也可以加全志交流QQ群：`498263967` 如果需要自己下载SDK开发，参考全志在线相关网页：https://d1.docs.aw ol.com/ ## WAFT 开发指南 TODO"},"/hardware/zh/lichee/RV/flash.html":{"title":"Lichee RV 烧录系统","content":"# Lichee RV 烧录系统 系统镜像分为 Tina与Debian两种，Tina为专用小linux镜像，Debian为桌面级镜像 ## 准备 1. Lichee RV 核心板 2. TF 内存卡（建议使用[官方店](https://shop365481095.taobao.com/)的的内存卡，其他的卡可能会有各种奇怪的问题） 3. 烧录工具 [PhoenixCard](https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV/tool) 4. 系统镜像下载 国内用户：[百度网盘](https://pan.baidu.com/s/1QJTaDw6kkTM4c_GAlmG0hg) 提取码：wbef 国外用户：[Mega](https://mega.nz/folder/lx4CyZBA#PiFhY7oSVQ3gp2ZZ_AnwYA) 镜像词缀说明 含义 备注 LicheeRV Sipeed 专用的 RISCV D1 Linux 系列系统。 Tina 标记为 tina openwrt 系统。 debian 标记为 riscv debian 系统。 86panel [taobao 86panel](https://item.taobao.com/item.htm?spm a230r.1.14.18.30b534187YMsRx&id 663345415205&ns 1&abbucket 7#detail) dock [taobao dock](https://item.taobao.com/item.htm?spm a1z10.3 c s.w4002 21410578028.20.35765d54K9XCOt&id 666274331852) hdmi 表示屏幕默认输出到 HDMI 屏幕上。 800480 / 480P 表示屏幕默认输出到 LCD 屏幕上，分辨率可以是 800*480 或 480P (640X480)。 8723ds 表示该镜像支持 8723ds WIFI / BLE 驱动。 xr829 表示该镜像支持 xr829 WIFI / BLE 驱动。 waft 是否内置 waft 软件。 ## 烧录镜像 ### 烧录步骤 烧录前最好使用[SD card Formatter](https://www.sdcard.org/downloads/formatter/eula_windows/SDCardFormatterv5_WinEN.zip)先把内存卡格式化一次，格式化的时候注意不要选择错了镜像。 打开烧录软件 [PhoenixCard](https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV/tool)，选择烧录的固件，将内存卡通过读卡器插入电脑中 选择 `启动卡` 选项 选择正确的盘符 点击 `烧卡` 根据状态栏的颜色可以判断烧录结果：红色的话说明烧录失败了，建议使用[SD card Formatter](https://www.sdcard.org/downloads/formatter/eula_windows/SDCardFormatterv5_WinEN.zip)格式化后再重新烧录一次；绿色则表示一切正常。 ![](./../assets/RV/flash.png) 要注意 Windows 默认打不开 linux 的文件系统，所以对于烧录过 linux 镜像的 sd 卡在 Windows 上会不能直接被打开，且被提示需要格式化之类的。 这时可以使用[SD card Formatter](https://www.sdcard.org/downloads/formatter/eula_windows/SDCardFormatterv5_WinEN.zip)来格式化 sd 卡来恢复到 Windows 系统可用的状态。 对于嵌入式 linux，建议持有两张以上的 sd 卡。 > 并不能保证每台电脑和每个人的内存卡都是可以烧录的，烧录失败的话建议购买官方的镜像卡。 等待烧录结束；烧录 Tina 系统镜像会比较快，烧录 Debian 系统镜像将会久一点，可能多用10分钟。 ### 烧录失败相关 如果在烧录时提示格式化失败，或者使用烧录过的卡但是电脑上没有显示盘符，可以按以下操作来解决： 1. 在此下载磁盘处理软件： https://www.diskgenius.cn/ 2. 电脑上显示不出的盘符，会在该软件里显示出来，使用该软件进行快速分区： ![attachmentId 2788](./../assets/RV/Diskgenius.png) 3. 分区完成后，电脑上就能够看到盘符，PhoenixCard 里也能看到，在 PhoenixCard 里点击恢复卡即可恢复卡到正常状态 4. 按之前步骤继续烧录即可 ## 启动 启动后若提示需要用户名和密码的话的分别如下： Tina 系统登录用户名：`root` 密码：`tina` Debian 系统登录用户名：`root` 密码：`licheepi` 插卡启动，可以在串口工具中查看到启动信息: debian 启动的打印信息 <details> <summary><font color \"#4F84FF\">点开查看部分debian启动日志</font></summary> <pre><code class \"language shell\"> [270]HELLO! BOOT0 is starting! [273]BOOT0 commit : 27369ab OpenSBI v0.6 ____ _____ ____ _____ / __ \\ / ____ _ \\_ _ _ __ ___ _ __ (___ _) '_ \\ / _ \\ '_ \\ \\___ \\ _ < __ _) __/ ____) _) _ \\____/ .__/ \\____ ______/____/_____ _ </code></pre> </details> Tina 启动的打印信息 <details> <summary><font color \"#4F84FF\">点开查看Tina启动日志</font></summary> <pre><code class \"language shell\"> BusyBox v1.27.2 () built in shell (ash) __ ___ _ __ _ / / /__ _(_)_ __ / / (_)__ __ ____ __ / /_/ / _ `/ /\\ \\ / / /__/ / _ \\/ // /\\ \\ / /_/ /_/\\_,_/_//_\\_\\ /____/_/_//_/\\_,_//_\\_\\ Maix Linux (Neptune, 5C1C9C53) root@MaixLinux:/# </code></pre> </details> ## 相关问题 [点我跳转](./problems.html)"},"/hardware/zh/lichee/RV/ubuntu.html":{"title":"LicheeRV ubuntu","content":" title: LicheeRV ubuntu keywords: ubuntu, riscv, lichee update: date: 2022 12 01 version: v0.1 author: wonder content: 初次编辑 Ubuntu 提供了可以在 LicheeRV 上面运行的镜像，它的烧录方法与并不是使用 PhoenixCard，因此这边专门说明一下使用方法。 有显示器的话可以接键盘来使用命令行操作该系统，没有的话只能通过串口来操作板子。 ## Ubuntu 介绍 Ubuntu 是基于另一个 Linux 发行版 Debian 发展而来，网上大多数 linux 相关的教程也是基于 ubuntu 的，这点对于新手很友好，遇到问题的时候可以比较快地找到解决办法。 因为 D1 的性能有限，所以只提供命名行版本，需要的话自行安装、适配桌面也是能有 GUI 的。 <img src \"./../assets/RV/ubuntu/d1_ubuntu_desktop.jpg\" alt \"d1_ubuntu_desktop\" width \"45%\"> <img src \"./../assets/RV/ubuntu/d1_ubuntu_desktop_picture.jpg\" alt \"d1_ubuntu_desktop_picture\" width \"45%\"> 上图为 D1 Dock Pro 板卡，与普通的 Dock 底板是不同的，底板上自带了串口，可以仅使用一根数据线来进行板卡与电脑的串口通信。相关外设可以看下图的标注。 <img src \"./../assets/RV/ubuntu/dock_pro_top_block.jpg\" alt \"dock_pro_top_block\" width \"45%\"> <img src \"./../assets/RV/ubuntu/dock_pro_bottom_block.jpg\" alt \"dock_pro_bottom_block\" width \"45%\"> 可以在官方淘宝店咨询卖家购得该板卡。 ## 操作步骤 ### 获取镜像 提供了百度网盘下载方式。 百度网盘: https://pan.baidu.com/s/1OrePh_HamqAuLi5T_66ScA 提取码: dock ### 软件获取 可以前往 [balenaEtcher](https://www.balena.io/etcher/) 官网下载软件或者[下载站](https://dl.sipeed.com/shareURL/others/balenaEtcher)下载，其中下载站仅提供 Windows 版本软件，其他系统想用这个软件自行前往 [balenaEtcher](https://www.balena.io/etcher/) 官网下载。 ### 烧录系统 准备一张容量 8G 以上的内存卡，读写速度快一些的卡能带来更好的体验。 将 TF 卡与电脑连接起来，使用读卡器或者其他方式都可以。下图的电脑上的 TF 卡槽仅做示例，电脑上没有 TF 卡读取插槽的话依然是需要准备读卡器的。 <table> <tr> <th colspan \"2\"> 将 TF 卡与电脑连接 </th> </th> </tr> <tr> <td>使用读卡器来连接 TF 卡和电脑</td> <td>直接使用电脑上的 TF 卡插槽来连接</td> </tr> <tr> <td><img src \"./../assets/RV/ubuntu/d1_ubuntu_sdcard_reader.jpg\" alt \"d1_ubuntu_sdcard_reader\" ></td> <td><img src \"./../assets/RV/ubuntu/d1_ubuntu_sdcard_computer_reader.jpg\" alt \"d1_ubuntu_sdcard_computer_reader\" ></td> </tr> </table> 打开 balenaEtcher，选择所下载的镜像文件，选择 TF 卡，点击烧录： ![d1_ubuntu_burn_image](./../assets/RV/ubuntu/d1_ubuntu_burn_image.gif) 要注意的是烧录的时候别选错了 TF 卡。 ![d1_ubuntu_burn_image_sdcard_choose](./../assets/RV/ubuntu/d1_ubuntu_burn_image_sdcard_choose.png) 烧录时间有点久，烧录结束后会出现下图的提示。如果不是 Successful 的话就需要重新烧录。 ![d1_ubuntu_finish_burn_image](./../assets/RV/ubuntu/d1_ubuntu_finish_burn_image.png) ## 启动系统 烧录完系统且看到 Successful 字样后，可以将 TF 卡插到板子上启动了。 ![dock_pro_ubuntu](./../assets/RV/ubuntu/dock_pro_ubuntu.jpg) 使用串口可以查看启动信息，并且操作板卡。 <img src \"./../assets/RV/ubuntu/d1_ubuntu_boot_opensbi.jpg\" alt \"d1_ubuntu_boot_opensbi\" width \"45%\"> <img src \"./../assets/RV/ubuntu/ubuntu_boot.jpg\" alt \"ubuntu_boot\" width \"45%\"> 等待启动一段时间后，使用 `root` 作为用户名和密码就可以登录进板卡了， ![d1_ubuntu_login](./../assets/RV/ubuntu/d1_ubuntu_login.jpg) ## 连接 wifi 然后使用 `nmcli` 命令来连接 2.4G 无线网络。 查看周围的 wifi ```bash nmcli dev wifi ``` ![d1_ubuntu_wifi_scan](./../assets/RV/ubuntu/d1_ubuntu_wifi_scan.jpg) 使用命令行来连接 wifi，语法为 `nmcli dev wifi connect (网络名称） password (密码）` ```bash nmcli dev wifi connect Sipeed_Guest password 12345678 ``` ![d1_ubuntu_wifi_connect](./../assets/RV/ubuntu/d1_ubuntu_wifi_connect.jpg) 出现 successfully 就表示连接上了，后面可以正常使用 `apt` 等软件了 ![d1_ubuntu_install_tree](./../assets/RV/ubuntu/d1_ubuntu_install_tree.jpg) ## 点灯 在这个 ubuntu 系统上，我们可以向之前使用 tina 系统时一样，控制核心板上的 led 灯。相关代码和结果如下所示： 点亮板卡上的 LED : ```bash echo 1 > /sys/class/leds/\\:status/brightness ``` 上面的命令中的 `:` 使用了 \"\\\" 进行转义，不然会报错。 ![d1_ubuntu_led_on](./../assets/RV/ubuntu/d1_ubuntu_led_on.jpg) 熄灭板卡上的 LED : ```bash echo 0 > /sys/class/leds/\\:status/brightness ``` ![d1_ubuntu_led_off](./../assets/RV/ubuntu/d1_ubuntu_led_off.jpg) ## 结语 在 Ubuntu 官方所提供的镜像上[点我跳转](https://wiki.ubuntu.com/RISC V/LicheeRV)，我们这边补上了 wifi 驱动免去了自行编译的麻烦。 ## 常见问题 ### 没有 HDMI 输出 板卡使用 ubuntu 镜像在启动时不会直接输出 HDMI， 而是会在相关的服务启动后 HDMI 屏幕在会有输出，另外部分 HDMI 屏幕不会兼容并显示出 LicheeRV HDMI 命令行。 下图是分别用串口 (ttyS0) 和 HDMI 显示器终端 (tty1) 登录 LicheeRV ubuntu 的拍照截图 ![d1_ubuntu_console_hdmi](./../assets/RV/ubuntu/d1_ubuntu_console_hdmi.jpg)"},"/hardware/zh/lichee/Zero/Zero.html":{"title":"Lichee Zero","content":"# Lichee Zero ## Lichee Zero 概述 Lichee Zero是基于全志科技的V3s(ARM Cortex A7内核)高性能CPL芯片设计的迷你开发板。开发板设计小巧精致，将芯片的所有资源都引出,板载USB、Flash、TF卡、4OP LCD接口等，并把所有IO资源引出，方便开发者拓展使用，适合初学者学习linux或者商用于产品开发。 核心板： <html> <div class \"imbox\"> <img src \"./../assets/Zero/Zero_1.png\" width 240> <img src \"./../assets/Zero/Zero_6.png\" width 240> <style> .imbox{ display:flex; flex direction: row; } </style> </div> </html> 核心板+扩展板： <html> <div class \"imbox\"> <img src \"./../assets/Zero/Zero_3.png\" width 240> <img src \"./../assets/Zero/Zero_4.png\" width 240> <style> .imbox{ display:flex; flex direction: row; } </style> </div> </html> ## 参数 ### V3s参数 V3s框架 ![](./../assets/Zero/V3s.png) 项目 参数 CPU ARM Cortex™ A7 最高1.2GHz Memory Integrated 64MB DRAM Audio Codec • Integrated 92dB audio codec<br>• Supports two ADC channels and two DAC channels<br>• Supports one low noise analog microphone bias outputs<br>• Supports one microphone input and one stereo microphone outpu Video • Supports 1080p@40fps or 1080p@30fps+VGA@30fps H.264 video encoding,<br>• Supports H.264 1080p@30fps decoding, MJPEG 1080@30fps decoding Video Input/Output • Supports 8/10/12 bit parallel CSI and 4 lane MIPI CSI2<br>• Supports up to 5M CMOS sensor<br>• Supports RGB/i80/LVDS LCD up to 1024x768 resolution Connectivity • 3 x SD card controllers<br>• LRADC/SPI/TWI/UART/PWM<br>• USB, EMAC+PHY ISP • Integrated ISP up to 5M pixels<br>• Supports two channel outputs for display and encoding respectively<br>• Supports various input and output formats<br>• Supports AE/AF/AWB<br>• Supports saturation adjustment/ noise reduction/ defect pixel correction/distortion correction ### Lichee Zero核心板参数 项目 参数 CPU V3s 内存 64MB DDR2 存储 预留 SOP8 SPI Flash焊盘 <br>板载TF卡座 显示 通用40P RGB LCD FPC座<br>可直插常见的40P 4.3/5/7寸屏幕（板载背光驱动)，通过转接板可插50P 7/9寸屏<br>支持常见的272x480,480x800,1024x600等分辨率板载电阻式触摸屏芯片，支持电阻屏<br>板载RGB LED 通讯接口 SDIO x2，可搭配配套SDIO WiFi+BT模块<br>SPl x1<br>12C x2<br>UART x3<br>100M Ether x1(含EPHY)<br>OTG USB x1<br>MIPI CSI x1 其他接口 <br>PWM x2<br>LRADC x1<br>Speakerx2+ Mic x1 电气特性 Micro USB 5V供电<br>2.54mm插针3.3V~5V供电<br>1.27mm邮票孔供电 ![](./../assets/Zero/Zero_8.png) ![](./../assets/Zero/Zero_10.png) ### Lichee Zero 拓展板 项目 参数 CPU V3s 内存 64MB DDR2 存储 预留 SOP8 SPI Flash焊盘 <br>板载TF卡座 显示 通用40P RGB LCD FPC座<br>可直插常见的40P 4.3/5/7寸屏幕（板载背光驱动)，通过转接板可插50P 7/9寸屏<br>支持常见的272x480,480x800,1024x600等分辨率板载电阻式触摸屏芯片，支持电阻屏<br>板载RGB LED 通讯接口 SDIO x2，可搭配配套SDIO WiFi+BT模块<br>SPI x1<br>I2C x2<br>UART x3<br>100M Ether x1(含EPHY)<br>OTG USB x1<br>MIPI CSI x1 其他接口 <br>PWM x2<br>LRADC x1<br>Speakerx2+ Mic x1 板载外设 以太网接口<br>3.5mm耳机接口<br>驻极体麦克风<br>额外TF卡卡槽<br>4个按键<br>MIPI接口 电气特性 Micro USB 5V供电<br>2.54mm插针3.3V~5V供电<br>1.27mm邮票孔供电 ![](./../assets/Zero/Zero_9.png) ## 使用教程 [Lichee Zero](./../../../../soft/Lichee/zh/Zero Doc/Start/board_intro.html) ## 产品技术支持 Lichee Zero 开发板可以在多种场景实现客户不同方面的需要，在 AIoT 上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务 <support@sipeed.com>。"},"/hardware/zh/lichee/One/index.html":{"title":"","content":"敬请期待"},"/hardware/zh/lichee/th1520/lp4a.html":{"title":"Lichee Pi 4A","content":" title: Lichee Pi 4A keywords: Linux, Lichee, TH1520, SBC, update: date: 2023 03 31 version: v0.1 author: wonder content: 新建文档 ## 简介 Lichee Pi 4A 是使用了 [Lichee Module 4A](http://wiki.sipeed.com/hardware/zh/lichee/th1520/lm4a.html) 核心板组合出来的 Linux 开发板，以 [TH1520](https://www.t head.cn/product/yeying) 为主控核心，搭载 4TOPS@int8 AI 算力的 NPU，支持双屏 4K 显示输出，支持 4K 摄像头接入，双千兆 POE 网口和多个 USB 接口，音频由 C906 核心处理。 购买链接：[淘宝](https://item.taobao.com/item.htm?id 715508771884) ## 基本参数 <table> <thead> <tr> <th colspan 2>主控参数</th> </tr> </thead> <tbody> <tr> <td>主控芯片</td> <td>曳影 1520</td> </tr> <tr> <td>CPU处理器</td> <td>RISC V 64GCV C910*4@2GHz <br>· 每核支持 64KB I cache 和 64KB D Cache <br>· 四核共享 1MB L2 Cache <br>· 支持 TEE 和 REE，TEE/REE 支持核数启动时可配置<br>· 支持自定义且接口兼容 RISC V 的多核调试框架<br>· 独立电源域，支持 DVFS</td> </tr> <tr> <td>图形处理器</td> <td>· OpenCL 1.1/1.2/2.0<br>· OpenGL ES 3.0/3.1/3.2<br>· Vulkan 1.1/1.2<br>· Android NN HAL</td> </tr> <tr> <td>NPU处理器</td> <td>支持 4TOPS@INT8 通用 NNA 算力，主频 1GHz <br>· 支持 TensorFlow、ONNX、Caffe <br>· 支持 CNN、RNN、DNN 等</td> </tr> <tr> <td>视频解码器</td> <td>实时解码器，支持 H.265/H.264/VP9/8/7/6/AVS/AVS+/AVS2.0/VC1/MPEG4 <br>· 支持 H.264 BP/MP/HP@level 5.1 解码，最大 4K 分辨率<br>· 支持 H.265/HEVC Main Profile@level 5.1 解码，最大 4K 分辨率<br>· 支持 VP9 Profile 2 解码，最大 4K 分辨率<br>· 支持 AVS2.0 解码，最大 4K 分辨率<br>· 支持 VP6/7/8/AVS/AVS+/VC1/MPEG4 解码，最大 1920x1080 分辨率<br>· 解码性能最大 4K@75fps</td> </tr> <tr> <td>视频编码器</td> <td>· 支持 H.264 BP/MP/HP@level4.2 编码，最大 4K 分辨率<br>· 支持 H.265/HEVC Main Profile 编码，最大 4K 分辨率<br>· 仅支持 I 帧和 P 帧<br>· 编码性能最大 4K@40fps</td> </tr> <tr> <th colspan 2>硬件特性</th> </tr> <tr> <td>RAM</td> <td>· 8GB 64bits LPDDR4<br>· 16GB 64bits LPDDR4<br></td> </tr> <tr> <td>存储</td> <td>· eMMC: 可选 空贴、 8G、 32G、 128G<br>· 支持 TF 卡</td> </tr> <tr> <td>以太网</td> <td>· 2 x 千兆以太网接口，可选 POE</td> </tr> <tr> <td>USB</td> <td>· USB3.0 x 4<br>· USB2.0 x 1（仅用于烧录）</td> </tr> <tr> <td>音频接口</td> <td>· 1 x 3.5mm 耳机接口<br>· 一个扬声器接口<br>· 两个板载麦克风<br></td> </tr> <tr> <td>显示接口</td> <td>· 1 x HDMI2.0<br>· 1 x 4 lane MIPI DSI</td> </tr> <tr> <td>摄像头接口</td> <td>· 2 x 2 lane MIPI CSI<br>· 1 x 4 lane MIPI CSI</td> </tr> <tr> <td>GPIO</td> <td>· UART<br>· IIC<br>· SPI</td> </tr> </tbody> </table> ## 相关链接 [板卡规格书](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/01_Specification) [底板原理图](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/02_Schematic) [底板点位图](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/03_Bit_number_map) [底板尺寸图](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/04_Dimensional_drawing) [模型文件](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/05_3D_model) [Github](https://github.com/sipeed/LicheePi4A)"},"/hardware/zh/lichee/th1520/index.html":{"title":"","content":""},"/hardware/zh/lichee/th1520/lc4a.html":{"title":"","content":""},"/hardware/zh/lichee/th1520/lpi4a/2_unbox.html":{"title":"开箱体验","content":" title: 开箱体验 keywords: Linux, Lichee, TH1520, SBC, RISCV, unbox update: date: 2023 05 08 version: v1.0 author: wonder content: Release docs ## 开箱内容 LicheePi 4A 分为两个版本，内测版与正式版。 内测版于 2023 年 5 月发售，仅有 8+8（DDR+eMMC）版本，各部分功能基本正常。 正式版预计于 2023 年 6 月发售，将有 8+32,16+128 版本，也会针对内测版用户提出的相关建议进行局部微调优化，功能/镜像与内测版会保持一致。 ### 内测版 如果你是第一批内测版 LicheePi 4A 用户，你收到的包裹内将是如下包装： ![package_alpha](./assets/unbox/package_alpha.png) 打开塑料盒包装，你将看到如下的内容： ![unbox_alpha](./assets/unbox/unbox_alpha.png) 包裹在黑色泡棉内的就是 LicheePi 4A 主体，其余标号部件为： 1. 30x30mm 散热硅脂 2. 30mm 5V 散热风扇，右边已连接至风扇插针。如果松动脱出，请自行安装回去，注意红线为正极，装反后风扇不会转动。 3. 2.4G WiFi 天线，已安装至 IPEX 座子。如果松动脱出，请自行安装回去。 4. USB C 线缆，作为供电和下载镜像使用。 如果开箱后发现缺少相关部件，请联系客服咨询。 ### 正式版 （预计2023年6月发售） ### 选配件 如果你购买了选配件的话，包裹里还可能有： ![option_alpha](./assets/unbox/option_alpha.png) 图中上半部分是选配的 RVDebugger Plus，具有 JTAG+UART 功能，如果你需要进行底层调试，可选购买。 图中下半部分是选配的 12V2A 电源适配器，如果你需要在板子上外接大量耗电外设（如 USB，MIPI 屏），可选购买。 5V2A USB 供电可满足板卡在 1.85GHz 下的满载烤机运行 以及未来还会有POE供电模块（TODO） ## 组装板卡 ### SOM安装 默认情况下 LM4A SOM 已经安装至主板上，如果你需要升级/替换 SOM，可按如下说明进行 SOM 的取出和安装 1. 取出 SOM: <table> <tr> <td colspan 2>先用手指往外拨动弹片解锁 SOM, 然后将 SOM 取出</td> </tr> <tr> <td><img src \"./assets/unbox/unlock_som.png\" alt \"unlock_som\"></td> <td><img src \"./assets/unbox/remove_som.png\" alt \"remove_som\"></td> </tr> </table> 2. 安装 SOM: <table> <tr> <td colspan 2>先把 SOM 斜着插入连接器插槽, 然后按压SOM，两边弹片会自动锁住SOM</td> </tr> <tr> <td><img src \"./assets/unbox/insert_som.png\" alt \"insert_som\"></td> <td><img src \"./assets/unbox/lock_som.png\" alt \"lock_som\"></td> </tr> </table> ### 散热器安装 LicheePi 4A 是高性能 SBC，需要安装主动散热器对 SOM 进行散热，否则在满载时可能由于核心过热而自动降频，无法达到最优性能。 1. 安装导热硅脂片 取出导热硅脂片，撕开两面薄膜，将硅脂片放置在下图位置并轻轻按压固定（硅脂片自己具备一定粘性可以固定住），注意完整覆盖住主芯片与两颗内存芯片 ![silicone_pad](./assets/unbox/silicone_pad.png) 2. 安装散热风扇 在硅脂片上对齐安装30mm的散热风扇，并轻轻按压固定住。 ![insert_fan](./assets/unbox/insert_fan.png) 3. 安装散热风扇电源 默认收到时应该已经插入好了风扇电源，如果风扇电源线脱出，请按下图所示插入，注意电源线顺序，装反风扇不会旋转。 注意，该位置上的插针电源受 linux 内核控制，需正确配置内核才会旋转，如果风扇不转，也可插到板卡下方的 20pin 插针的 5V + GND 处测试风扇好坏。 ![insert_fan_cable](./assets/unbox/insert_fan_cable.png) ### WIFI天线安装 默认情况下WIFI天线已经安装在主板上，如果脱出，请按照下图安装回去： ![insert_ant](./assets/unbox/insert_ant.png) ### POE模块安装 选配，TODO。 ### 组装完成 组装完成后的状态如下所示： ![assemble_ok](./assets/unbox/assemble_ok.png) ## 启动板卡 LicheePi 4A出库已预烧录了基础系统镜像，至此你已可以快速进行开机体验！ 注意：预烧录的系统镜像版本可能比较旧，体验不佳，完成上电体验后，可以根据下章教程进行镜像更新。 使用 HDMI 线缆(自备)连接显示器(自备)与 LicheePi 4A 的 HDMI 口，使用配套的 USB C 线缆连接到至少 5V2A 输出的 USB 电源(自备)上，LicheePi 4A 即会开机启动，默认镜像会在 30s 内启动到桌面系统的登录界面。 ![boot_login](./assets/unbox/boot_login.png) 默认镜像有两类帐号密码配置，可以都尝试下： 1. 帐号：`root`，`debian`，`sipeed`；密码均为 `licheepi` 2. 帐号`debian`，密码`debian`；帐号`sipeed`，密码`licheepi` 插入键鼠，输入用户名密码后即可登录体验，具体操作请查看后续章节。 如果按照上述操作，没能点亮显示器，进入系统，有以下可能请自查： 1. 检查电源电压是否正常，USB C 口连接是否正常，电源指示灯是否点亮 2. 检查散热器是否正常安装，风扇是否旋转 3. 检查 HDMI 是否稳固连接，显示器是否开机，以及可以尝试更换显示器测试 4. 也可能是出厂遗漏固件烧录，请按下章方法进行镜像烧录后再试 5. 如果以上均不奏效，请联系客服售后 ## 板卡硬件说明 完成初次点亮板卡后，可以静下心来认识下 LicheePi 4A 的硬件，方便后期可能的维护工作。 ![pi_view](./assets/unbox/pi_view.png) ### 超频说明 TH1520 标称频率为 1.85GHz，我们仅保证你收到的板卡可以稳定工作在 1.85GHz。 如果你是发烧玩家，想进行超频操作，那么你有一定概率可以超频到 2GHz，但我们不保证在该频率下的稳定性。 经不完全测试，约有 80% 的 SOM 可以超频至 2GHz 启动系统，约有 50% 的 SOM 可以在 2GHz 下跑通压力测试。 ### USB 限流说明 由于系统最大电源输入能力为 12V2A，即约 24W，转换为 5V 后，大约有 20W 左右有效功率。 为了更好地为 SOM 供电（SOM 在超频满载情况下可达 12W 功率），所以 USB HUB 处进行了电流限制，限制了 1.5A 的电流（内测版硬件。正式版硬件会根据反馈调整此处电流限制），即 7.5W 功率。 再接入大量 USB 设备时可能会超出该电流限制，此时建议对 USB 设备进行外部辅助供电。 如果需要解除此处电流限制，请进行如下操作：TODO。 ### 内测版已知问题 1. 仅支持原生eMMC启动，不支持 SD / SPI Flash 启动。正式版会增加拨码开关选择。 2. HDMI电平转换可能在个别显示器上存在兼容性问题，导致无法设置分辨率。可以尝试更换显示器。 3. 板载音频输出电路的高通滤波电路的截止频率过高（500Hz），导致低音丢失。正式版中会修正RC参数 ### 硬件资料下载 [板卡规格书](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/01_Specification) [底板原理图](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/02_Schematic) [底板点位图](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/03_Bit_number_map) [底板尺寸图](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/04_Dimensional_drawing) [模型文件](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/05_3D_model) ## 其他链接 [Github](https://github.com/sipeed/LicheePi4A) [淘宝](https://item.taobao.com/item.htm?id 715508771884) [Sipeed 下载站](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a) QQ群: 559614960 [点我自动加群](http://qm.qq.com/cgi bin/qm/qr?k 5YkapIhdtWHp8AEfM5_bFFYQIX3CUQN6) Telegram: https://t.me/linux4rv 论坛：bbs.sipeed.com 联系邮箱：support@sipeed.com"},"/hardware/zh/lichee/th1520/lpi4a/9_benchmark.html":{"title":"CPU 跑分测试","content":" title: CPU 跑分测试 keywords: Linux, Lichee, TH1520, SBC, RISCV, benchmark update: date: 2023 05 08 version: v1.0 author: wonder content: Release docs ## Dhrystone 平头哥官方数据，C910 为 5.6 分左右。 ![dmips](./assets/benchmark/dmips.png) ## CoreMarks 测试参数配置： ` funroll all loops finline limit 500 fgcse sm fno schedule insns msignedness cmpiv fno code hoisting mno thread jumps1 mno iv adjust addr cost mno expand split imm` 测试结果（1.85GHz）： ```txt 2K performance run parameters for coremark. CoreMark Size : 666 Total ticks : 15129 Total time (secs): 15.129000 Iterations/Sec : 13219.644392 Iterations : 200000 Compiler version : GCC10.4.0 Compiler flags : O2 march rv64gv0p7_zfh_xtheadc O3 funroll all loops finline limit 500 fgcse sm fno schedule insns msignedness cmpiv fno code hoisting mno thread jumps1 mno iv adjust addr cost mno expand split imm DPERFORMANCE_RUN 1 lrt Memory location : Please put data memory location here (e.g. code in flash, data on heap etc) seedcrc : 0xe9f5 [0]crclist : 0xe714 [0]crcmatrix : 0x1fd7 [0]crcstate : 0x8e3a [0]crcfinal : 0x4983 Correct operation validated. See README.md for run and reporting rules. CoreMark 1.0 : 13219.644392 / GCC10.4.0 O2 march rv64gv0p7_zfh_xtheadc O3 funroll all loops finline limit 500 fgcse sm fno schedule insns msignedness cmpiv fno code hoisting mno thread jumps1 mno iv adjust addr cost mno expand split imm DPERFORMANCE_RUN 1 lrt / Heap lrt / Heap ``` ![coremarks](./assets/benchmark/coremarks.png) ## Geekbench5 > 注：这里的测试使用公版工具链，若使用thead专用工具链，性能预计可提升50%以上 ![geekbench5](./assets/benchmark/geekbench5.png) https://browser.geekbench.com/v5/cpu/compare/21100603?baseline 21092115 ## 7 Zip LZMA [7 Zip LZMA Benchmark](https://7 cpu.com/) ![7z](./assets/benchmark/7z.png) ## OpenSSL ```bash openssl speed evp aes 256 cbc openssl speed evp aes 256 gcm openssl speed evp sha1 openssl speed evp sha256 ``` type 16bytes 64bytes 256bytes 1024bytes 8192bytes 16384bytes <p style \"white space:nowrap\">AES 256 CBC</p> 29206.05k 36957.73k 39648.85k 40407.72k 40624.13k 40768.21k <p style \"white space:nowrap\">AES 256 GCM</p> 24610.57k 28191.29k 29459.29k 29727.06k 29911.72k 29949.95k <p style \"white space:nowrap\">sha1</p> 9428.03k 30591.02k 72920.06k 113164.63k 135271.77k 137052.16k <p style \"white space:nowrap\">sha256</p> 6206.94k 17151.38k 34806.19k 47151.10k 52559.87k 53163.07k ## LLVM TODO ## 其它 欢迎投稿～ 投稿接受后可得￥5～150（$1~20）优惠券！"},"/hardware/zh/lichee/th1520/lpi4a/3_images.html":{"title":"镜像集合","content":" title: 镜像集合 keywords: Linux, Lichee, TH1520, SBC, RISCV, image update: date: 2023 05 08 version: v1.0 author: wonder content: Release docs ## 内核支持 目前平头哥官方 SDK 使用 Linux5.10 内核： https://gitee.com/thead yocto 主线 linux6.x 内核正在移植中，主要社区贡献者：`Jisheng Zhang ` ## Sipeed官方镜像 LicheePi 4A 的镜像不定期更新中，初期的镜像可能不太稳定，或者无法发挥 TH1520 的完全性能，请关注本页面，获取最新镜像。 Sipeed 官方镜像基于 Debian 系统修改适配。 默认镜像有两类帐号密码配置，可以都尝试下： 1. 帐号：`root`，`debian`，`sipeed`；密码均为 `licheepi` 2. 帐号`debian`，密码`debian`；帐号`sipeed`，密码`licheepi` 下载地址： 百度网盘：[点我](https://pan.baidu.com/e/1jnjz0KO_xnO5R8tWlXtx0A) Mega 云盘：[点我](https://mega.nz/folder/phoQlBTZ#cZeQ3qZ__pDvP94PT3_bGA) ISCAS 镜像站：[点我](https://mirror.iscas.ac.cn/revyos/extra/images/lpi4a/) ### Debian ![debian](./assets/images/debian.png) 1. LPi4A_Test_0425 1. 发布日期：2023年4月25日 2. 内核：5.10 3. 根文件系统：ext4, 4.3GB 4. 主要预装软件包： 1. 开发类 2. 办公类 5. 修复问题： 6. 已知问题： 1. 关闭GPU 2. 安装ibus输入法后会导致GPU开启，复现GPU双缓冲卡顿（终端+图形界面）问题 2. LPI4A tempfix0428 1. 发布日期：2023年4月28日 2. 内核：5.10 3. 根文件系统：ext4, 4.3GB 4. 主要预装软件包：TODO 5. 修复问题： 1. 临时修复0425版本中终端显示滞后的问题，但是会导致CPU占用率提升，GPU效率减半 6. 已知问题： 1. 安装ibus输入法后会导致GPU开启，复现GPU双缓冲卡顿（图形界面）问题 ### OpenWRT ![openwrt](./assets/images/openwrt.png) TODO ### Andriod ![android](./assets/images/android.png) TODO 系统安装：提示默认已安装到 eMMC。升级系统的方式（镜像下载，烧录工具，步骤） ## 第三方镜像 这里整理了第三方提供的镜像，仅供用户体验，sipeed 不保证此类镜像的可用性，稳定性。 ### openEuler ![openEuler](./assets/images/openEuler.png) Download: [Click me](https://mirror.iscas.ac.cn/openeuler sig riscv/openEuler RISC V/preview/openEuler 23.03 V1 riscv64/lpi4a/) Twitter: https://twitter.com/openEuler ### DeepinOS 深度 ![deepin](./assets/images/deepin.jpg) Readme and image download link: [Click me](https://github.com/aiminickwong/licheepi4a images) ### openKylin ![openKylin](./assets/images/openkylin.png) Readme and image download link: [Click me](https://github.com/aiminickwong/licheepi4a images) ### armbian ![armbian](https://cdn.armbian.com/wp content/uploads/2018/03/logo2.png) Project address: [Click me](https://github.com/chainsx/armbian riscv build) ### Fedora ![fedora](./assets/images/fedora.png) Project address: [Click me](https://github.com/chainsx/fedora riscv builder) ### Ubuntu ![ubuntu](./assets/images/ubuntu.png) ### NixOS ![nixos](./assets/images/nixos.png) ### Gentoo Project address: [Click me](https://wiki.gentoo.org/wiki/Project:RISC V) 下面链接说明如何从stage3制作一个Gentoo Linux系统 Deplay Gentoo Linux [Click me](https://wiki.gentoo.org/wiki/User:Dlan/RISC V/TH1520) ![gentoo](./assets/images/gentoo.jpg)"},"/hardware/zh/lichee/th1520/lpi4a/7_develop_andriod.html":{"title":"系统开发","content":" title: 系统开发 keywords: Linux, Lichee, TH1520, SBC, RISCV, Kernel, SDK, Develop update: date: 2023 05 08 version: v1.0 author: wonder content: Release docs "},"/hardware/zh/lichee/th1520/lpi4a/7_develop_thead.html":{"title":"系统开发","content":" title: 系统开发 keywords: Linux, Lichee, TH1520, SBC, RISCV, Kernel, SDK, Develop update: date: 2023 05 12 version: v1.1 author: wonder content: Depart docs date: 2023 05 08 version: v1.0 author: wonder content: Release docs ## Yocto Linux TH1520 的官方开发环境是平头哥的基于 yocto 的开发环境，大家可以在这里获取开发环境： https://gitee.com/thead yocto/ 本节简单介绍如何搭建 Linux Yocto 环境并使用 Yocto 构建可在开发板上运行的完整镜像。 ### 搭建Yocto编译环境 Linux SDK 使用 Yocto 构建镜像。Yocto 编译环境使用 Ubuntu18.04，推荐在 Linux 上使用 Docker 部署,也可直接在 Ubuntu18.04 下搭建环境（见[T Head曳影1520Yocto用户指南.pdf](https://gitee.com/thead yocto/documents/blob/master/zh/user_guide/T Head%E6%9B%B3%E5%BD%B11520Yocto%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf)2.2）。 这里仅介绍 Linux 上使用 Docker 部署的方式。**建议编译机器预留200G磁盘空间，内存为4G以上，编译时间因网络情况差异很大，在使用代理的情况下编译典型linux系统配置（最小系统加上必要的相关基础组件）时间约为1.5h（CPU为i5 11400，时间供参考）**。 使用官方脚本安装 docker \t```bash \tcurl fsSL https://get.docker.com bash s docker mirror Aliyun \t``` 下载 dockerfile 并修改用户名和 ID \t点击下载 [linux dev master.7z](https://gitee.com/thead yocto/documents/blob/master/linux dev master.7z) 并解压后，进入到 `linux dev master` 目录，打开 `Dockerfile`，找到如下语句 \t```bash \tENV DOCKER_USER2 \"your the same user name asyour host\"` \tENV USER2_ID \"your user id\" \t``` \t将 \"your the same user name asyour host\" 改为用户 host os 的用户名，\"your user id\" 的值对应该用户的密码。 构建 docker 镜像环境 \t```bash \tdocker build t linux dev base:base . \t``` \t这里下载的软件包的时候可能会有些报错，可以在 Dockerfile 中进行相应的修改，等到创建好 docker 后登录到 docker 中再进行下载。这个 docker 镜像可以编译 thead 发布的 buildroot、yocto 等 Linux SDK。默认密码为 `123`。 启动 docker \t```bash \tdocker run u thead dt name linux dev {your_name} v {your_lock_home}:{your_home} linux dev base:base /bin/bash \t``` \t{your_name} 为容器名称，起名时不要重名。 \t通过 v 选项可以挂载宿主机的目录，起到类似共享文件的作用，{your_lock_home} 为宿主机的本地路径，{your_home} 为挂载在 docker 里的路径。 查看启动的 docker 容器 \t```bash \tdocker ps grep linux dev base \t``` 就能够看到刚刚启动的 docker 容器。 登录 docker \t```bash \tdocker exec it linux dev {your_name} /bin/bash \t``` 下载开源软件包（仅在第一次获取 SDK 时才需要下载） \t构建固件时会从网上下载开源软件包，若网络较差，下载时间会比较长。为了加速这一过程，可以先到 gitee 下载离线开源软件包（假设下载到用户目录） \t```bash \tcd ~ \tgit clone https://gitee.com/thead yocto/yocto downloads.git \t``` 下载 Yocto 构建包 \t```bash \tgit clone https://gitee.com/thead yocto/xuantie yocto.git b Linux_SDK_V1.1.2 \t``` 加载目标设备的配置文件和环境变量（编译前记得检查是否加载） \t```bash \tcd xuantie yocto \tsource openembedded core/oe init build env thead build/light fm \t``` 将前面下载的开源软件包通过共享 downloads 目录的方式软链接到 SDK 目录 \t```bash \tln s ~/yocto downloads ../downloads \t``` 至此，搭建环境已经完成。 ### Machine/Target支持列表 在上面的加载环境变量步骤中，设置完成后可看到以下信息 ```bash ### Shell environment set up for builds. ### You can now run 'bitbake <target>' Common targets are: thead image linux thead image multimedia thead image gui machines: light beagle light b product light a val light lpi4a ``` 相关说明如下 target（SDK 支持的镜像列表）： 命名描述 thead image linux典型linux系统配置，最小系统加上必要的相关基础组件 thead image multimedia典型linux系统+视频视觉配置，加上视频子系统的组件（Gstreamer等） thead image gui加上GUI相关组件的完整配置版本，包括Gnome桌面、weston、QT等应用组件等等 machines（SDK 支持的板级配置）： 命名描述 light a valTH1520 A EVB板 light b productTH1520 B EVB板 light beaglebeagleV Ahead开发板 light lpi4aLichee Pi 4A开发板 ### 构建镜像 构建命令格式如下： ```bash MACHINE {machine} bitbake {target} ``` 将其中的 {machine} 和 {target} 部分替换为上面两个表格中对应的命名即可。例如，编译一个在 LicheePi 4A 开发板上运行的典型 Linux 镜像的命令如下： ```bash MACHINE light lpi4a bitbake thead image linux ``` #### 构建镜像时可能会出现的问题 由于网络原因，这一步可能仍会出现下载失败或下载很慢的情况，有条件的话推荐使用代理。 报错信息 \t```bash \tPlease use a locale setting which supports utf 8. \tPython can't change the filesystem locale after loading so we need a utf 8 when python starts or things won't work. \t``` \t首先运行如下命令 \t```bash \tsudo apt get install locales \tsudo dpkg reconfigure locales \t``` \t然后在打印出来的列表中找到`en_US.UTF8`这一项（大概在第158项）,输入这一项对应的序号后回车，接下来也选择这一项后回车。 \t完成上述设置步骤后接着运行如下命令（也可考虑将下面的命令加入到docker的`.bashrc`中） \t```bash \tsudo locale gen en_US.UTF 8 \tsudo update locale LC_ALL en_US.UTF 8 LANG en_US.UTF 8 \texport LANG en_US.UTF 8 \t``` \t完成上述步骤后再编译就不会出现原来的报错。 报错信息 \t```bash \tplease install them in order to proceed: lz4c pzstd zstd \t``` \t安装对应的依赖即可 \t```bash \tsudo apt update && sudo apt install y zstd liblz4 tool \t``` ### 镜像打包 在 [light_deploy_images](https://gitee.com/thead yocto/light_deploy_images/tree/master/tarball) 仓库中，包含了一些预发布镜像。对于刚刚编译好的镜像，可以利用这个仓库中的 `sdk.sh` 脚本来进行打包。 首先切换到已经编译好的镜像中的 `light fm` 目录下，将该仓库中的 `sdk.sh` 移动到这里即可。直接运行该脚本 `./sdk.sh` 即可，打包后会生成相应的镜像，相应文件的位置以及镜像目录的结构参考 [light_deploy_images](https://gitee.com/thead yocto/light_deploy_images/tree/master/tarball) 仓库。 最后，可以将 docker 编译好的镜像及相关文件复制到先前通过 v 选项挂载的共享文件夹中，宿主机即可使用该文件进行烧录。 到这里，我们已经完成了编译和打包，得到了一个可以烧录到开发板中运行的镜像。 简单介绍yocto中的常用概念和一些实用技巧。 ### 基础概念 Yocto用来构建定制的Linux镜像，有广泛的硬件支持，它是一个集合了很多工具的开源项目。 先对Yocto在构建镜像时的大致工作流程简单介绍： Fetch >Extract >Patch >Configure >Build >Install >Package Fetch：在编译时获取需要的源码。 Extract：对获取到的源码进行解压。 Patch：应用补丁以修复bug和添加新功能。 Configure：配置开发环境。 Build：构建镜像，编译链接。 Install：拷贝文件到目标目录。 Package：镜像打包。 下图展示了流程中的一些具体步骤： ![](https://gitee.com/cindycyber/blog pic/raw/e87498543df4f56c423509546cbd378ab85baa34/img/Pasted%20image%2020230508114904.png) Yocto project的大概构成如下图，构建所用到的主要是OpenEmbedded构建系统（下文用OE简称），它的核心是任务执行器Bitbake。 ![](https://gitee.com/cindycyber/blog pic/raw/e87498543df4f56c423509546cbd378ab85baa34/img/Pasted%20image%2020230508081704.png) 常用到的一些概念如下： recipes：以`.bb`结尾的文件，里面会包含下载软件包时需要的相关信息，如下载固定源码的文件位置，需要应用到该软件包的patch信息,编译需要的信息等。例如`xuantie yocto`的中的`gnome shell`，它的recipes文件存储在`/home/thead/xuantie yocto/meta openembedded/meta gnome/recipes gnome/gnome shell`目录下。 build directory：该目录即为构建时的输出目录，同时也会存放一些环境配置文件，`source`命令指定编译环境时就会生成该目录，默认命名为`build`，也可在`source`时更改为其他名字，如`sourece oe init build env mybuild`。 configurations：以`.conf`结尾的文件，主要是配置文件。比如存储在`build directory`的`conf`目录中的`local.conf`，在编译时可能会在根据需要更改其中一些参数。 layers：通常会在这里存储所需要的各种metadata(如，`.bb`文件，`patches`和一些其他的附加文件)，主要是用于告诉OE构建系统如何构建目标文件。将metadata按层分类有助于项目维护。 bitbake：OE构建系统中用来执行各种任务的任务执行器。 ### 常用操作 ##### 常用task Yocto以package为单位管理开源软件组件，如需要编译某个package，方法如下： ```shell bitbake \"package name\" ``` 每个package都在recipes文件中定义支持的task，有些task如clean，是所有包通用的，可以用一下命令列出package支持的task： ```shell bitbake \"package name\" c listtasks ``` ##### 查找编译后package的位置 Yocto集成了大量开源的package，这些 package 编译的时候的工作目录通常在以下目录： tmp glibc/work/riscv64 oe linux tmp glibc/work/${MACHINE} 例如 ```shell thead@b9461db16a58:~/xuantie yocto/thead build/light fm/tmp glibc/work/light_lpi4a oe linux/u boot$ tree L 2 . └── 1_2020.10 r0 ├── 0001 no strip fw_printenv.patch ├── build ├── deploy debs ``` 可以通过`bitbake e linux thead grep ^S `命令查找package目录。例如，查看内核的编译目录 ```shell $ bitbake e linux thead grep ^S S \"/home/thead/xuantie yocto/thead build/light fm/tmp glibc/work/light_a_val oe linux/linux thead/5.10.y r0/linux 5.10.y\" ``` 编译完成后文件输出的位置，例如，镜像编译完成后相关的各类文件都位于`light fm/tmp/glibc/work/light_lpi4a oe linux`下，例如镜像就位于该目录的`linux thead`下，最后只需要打包即可。 ##### 编译时fetch包的速度过慢 在编译时，可能会遇到fetch包过慢问题，这是除了使用代理，也可以将包下载到本地，然后根据得到的包地址让fetch时直接使用本地的repo。例如： ```shell WARNING: bzip2 native 1.0.8 r0 do_fetch: Failed to fetch URL git://sourceware.org/git/bzip2 tests.git;name bzip2 tests;branch master, attempting MIRRORS if available ``` 那么可以使用如下命令找到包的下载地址 ```shell $ bitbake e bzip2 grep ^SRC_URI SRC_URI \"https://sourceware.org/pub/bzip2/bzip2 1.0.8.tar.gz git://sourceware.org/git/bzip2 tests.git;name bzip2 tests;branch master file://configure.ac;subdir bzip2 1.0.8 file://Makefile.am;subdir bzip2 1.0.8 file://run ptest \" ``` 得到地址后，手动将该仓库`clone`下来，然后找到它对应的`.bb`文件 ```shell $ find name bzip*.bb ./openembedded core/meta/recipes extended/bzip2/bzip2_1.0.8.bb ``` 在该文件中找到`SRC_URI`这一项 ```shell SRC_URI \"https://sourceware.org/pub/${BPN}/${BPN} ${PV}.tar.gz \\ git://sourceware.org/git/bzip2 tests.git;protocol file;name bzip2 tests;branch master \\ file://configure.ac;subdir ${BP} \\ file://Makefile.am;subdir ${BP} \\ file://run ptest \\ \" ``` 加上`protocol`指定为`file`，若需要切换分支，直接在`clone`下来的本地repo中`checkout`到对应的分支即可，修改好后，直接fetch这个包即可。 ```shell bitbake bzip2 c fetch ``` 若编译速度过慢，找到`build_directory`的`conf`目录下的`local.conf`文件，修改相应的参数即可，参考[此文档](https://docs.yoctoproject.org/dev manual/speeding up build.html?highlight bb_numbers)，例如，增加下载和编译时的速度，可以在文件中增加如下代码，将并行数量调大（注意根据CPU具体参数来） ``` BB_NUMBER_THREADS '16' PARALLEL_MAKE ' j 12' ``` yocto编译后对package有缓存机制，可以在后面编译时减少所花费的时间。 除此之外，也可在编译前提前下载好一些包，放入某个文件夹，然后在`build_directory`的`conf`文件夹的`local.conf`找到`DL_DIR`这一项，这就是共享文件夹，更改到指定目录或软链接共享即可。 ##### 单独构建u boot 在编译时将源码下载到`light fm/tmp glibc/work/light_lpi4a oe linux/u boot/1_2020.10 r0/git`路径下（倒数第二级目录名为版本号），修改源码后执行该命令即可： ```shell bitbake u boot C compile ``` ##### 单独构建opensbi 在编译时将源码下载到`light fm/tmp glibc/work/light_lpi4a oe linux/opensbi/0.9 r0/git`路径下，修改源码后执行该命令即可： ```shell bitbake opensbi C compile ``` 编译完成后，为了简化打包流程，在`light_deploy_images`提供了打包脚本`sdk.sh`。编译完成后，在`light fm`文件夹下创建一个`sdk`文件夹，将该镜像打包脚本下载到该文件夹下，运行即可。 打包后典型的目录结构应如下所示： ```shell . ├── deb │   ├── all │   ├── light_lpi4a │   └── riscv64 ├── images │   └── light lpi4a │   ├── boot.ext4 │   ├── light_fastboot_image_single_rank │   │   └── u boot with spl.bin │   ├── rootfs.thead image linux.ext4 │   └── vmlinux ├── sdk.sh └── tarball └── prebuild_light lpi4a.tar.gz ``` 烧录时主要是用`images`目录下的文件，如果少了哪个文件，也可以手动复制进去。`tarball`目录下为打包好的镜像文件的压缩包，`deb`目录下为软件包。 参考： [bitbake官方文档](https://docs.yoctoproject.org/bitbake.html?highlight bitbake) [yocto官方文档](https://docs.yoctoproject.org/overview manual/yp intro.html) [T Head 曳影 1520 Yocto 用户指南](https://gitee.com/thead yocto/documents/raw/master/zh/user_guide/T Head%E6%9B%B3%E5%BD%B11520Yocto%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) ### 设备树解析 TODO ### 其他参考资料 **light_deploy_images 仓库：** 包含已经构建好可烧录的 Linux Image，打包镜像脚本以及其他相关工具，详见仓库。 仓库地址：[https://gitee.com/thead yocto/light_deploy_images](https://gitee.com/thead yocto/light_deploy_images) **documents 仓库：** 包含所有发布的 SDK 相关文档 仓库地址：[https://gitee.com/thead yocto/documents](https://gitee.com/thead yocto/documents) <! ## Mainline Linux TODO ## OpenWRT TODO ## Andriod TODO ## OpenHarmony TODO { \"label\":\"THead Yocto\", \"file\":\"lichee/th1520/lpi4a/7_develop_thead.md\" }, { \"label\":\"Mainline Linux\", \"file\":\"lichee/th1520/lpi4a/7_develop_mainline.md\" }, { \"label\":\"Andriod\", \"file\":\"lichee/th1520/lpi4a/7_develop_andriod.md\" }, { \"label\":\"Other\", \"file\":\"lichee/th1520/lpi4a/7_develop_other.md\" } > ## Others 在本机配置编译环境使用`make`构建。该构建流程运行于ubuntu 22.04系统，请预留约20G空间。 首先安装所需的软件包并设置好环境变量就配置好了构建所需环境 ``` export xuetie_toolchain https://occ oss prod.oss cn hangzhou.aliyuncs.com/resource//1663142514282 export toolchain_file_name Xuantie 900 gcc linux 5.10.4 glibc x86_64 V2.6.1 20220906.tar.gz export toolchain_tripe riscv64 unknown linux gnu export ARCH riscv export nproc 12 #请根据自身CPU配置设置，该文档使用cpu为i5 11400 mkdir th1520_build && cd th1520_build export GITHUB_WORKSPACE \"~/th1520_build\" #本文假设均下载到用户目录下，可根据自身需要更改 sudo apt update && \\ sudo apt install y gdisk dosfstools g++ 12 riscv64 linux gnu build essential \\ libncurses dev gawk flex bison openssl libssl dev tree \\ dkms libelf dev libudev dev libpci dev libiberty dev autoconf device tree compiler sudo update alternatives install \\ /usr/bin/riscv64 linux gnu gcc riscv64 gcc /usr/bin/riscv64 linux gnu gcc 12 10 sudo update alternatives install \\ /usr/bin/riscv64 linux gnu g++ riscv64 g++ /usr/bin/riscv64 linux gnu g++ 12 10 ``` #### 构建kernel 首先请clone用到的repo，并建立好对应文件夹（下列路径均假设根目录为用户目录下） ```shell git clone https://github.com/revyos/thead kernel.git kernel git clone https://github.com/revyos/gpu_bxm_4_64 kernel.git img_module ``` 配置编译工具链 ```shell mkdir rootfs && mkdir rootfs/boot wget ${xuetie_toolchain}/${toolchain_file_name} tar xvf ${toolchain_file_name} C /opt export PATH \"/opt/Xuantie 900 gcc linux 5.10.4 glibc x86_64 V2.6.1/bin:$PATH\" ``` 编译内核 ```shell pushd kernel make CROSS_COMPILE ${toolchain_tripe} ARCH ${ARCH} light_defconfig make CROSS_COMPILE ${toolchain_tripe} ARCH ${ARCH} j$(nproc) make CROSS_COMPILE ${toolchain_tripe} ARCH ${ARCH} j$(nproc) dtbs if [ x\"$(cat .config grep CONFIG_MODULES y)\" x\"CONFIG_MODULES y\" ]; then sudo make CROSS_COMPILE ${toolchain_tripe} ARCH ${ARCH} INSTALL_MOD_PATH ${GITHUB_WORKSPACE}/rootfs/ modules_install j$(nproc) fi sudo make CROSS_COMPILE ${toolchain_tripe} ARCH ${ARCH} INSTALL_PATH ${GITHUB_WORKSPACE}/rootfs/boot zinstall j$(nproc) ``` 初步打包内核、设备树文件 ```shell sudo cp v arch/riscv/boot/Image ${GITHUB_WORKSPACE}/rootfs/boot/ sudo cp v arch/riscv/boot/Image.gz ${GITHUB_WORKSPACE}/rootfs/boot/ sudo cp v arch/riscv/boot/dts/thead/*.dtb ${GITHUB_WORKSPACE}/rootfs/boot/ popd ``` 编译模块 ```shell export PVR_BUILD_DIR thead_linux export PVR_ARCH rogue export RGX_BVNC 36.52.104.182 export RGX_BNC 36.52.104.182 export CROSS_COMPILE ${toolchain_tripe} pushd img_module/rogue_km export KERNELDIR ${GITHUB_WORKSPACE}/kernel/ make for kernel_version in $(ls ${GITHUB_WORKSPACE}/rootfs/lib/modules/); do \t sudo install D p m 644 binary_thead_linux_wayland_release/target_riscv64/kbuild/drm_nulldisp.ko \\ \"${GITHUB_WORKSPACE}/rootfs/lib/modules/${kernel_version}/extra/drm_nulldisp.ko\" \tsudo install D p m 644 binary_thead_linux_wayland_release/target_riscv64/kbuild/pvrsrvkm.ko \\ \"${GITHUB_WORKSPACE}/rootfs/lib/modules/${kernel_version}/extra/pvrsrvkm.ko\" \tsudo depmod a b \"${GITHUB_WORKSPACE}/rootfs\" \"${kernel_version}\" done popd ``` 查看编译生成的文件 ```shell tree ${GITHUB_WORKSPACE}/rootfs ``` ### 构建uboot 注意，此时仍在th1520_build目录下，且已经配置好环境变量和工具链，步骤参考构建kernel。 ```shell git clone https://github.com/revyos/thead u boot.git uboot ``` 然后开始执行编译命令 ```shell pushd uboot sed i \"s/YYLTYPE yylloc;/extern YYLTYPE yylloc;/\" scripts/dtc/dtc lexer.l make ARCH ${ARCH} CROSS_COMPILE ${toolchain_tripe} light_lpi4a_defconfig make ARCH ${ARCH} CROSS_COMPILE ${toolchain_tripe} j$(nproc) find . name \"u boot with spl.bin\" xargs I{} cp av {} ${GITHUB_WORKSPACE}/rootfs/boot/u boot with spl lpi4a.bin popd ``` 上述过程中，可能会遇到重复定义`YYLTYPE yylloc`问题，按照报错信息找到重复定义的那一行删掉多余的`extern`即可，典型文件位置如下`uboot/scripts/dtc/dtc lexer.lex.c`。 检查输出的文件 ```shell tree ${GITHUB_WORKSPACE}/rootfs ``` ### 构建opensbi 注意，此时仍在th1520_build目录下，且已经配置好环境变量和工具链，步骤参考构建kernel。 ```shell git clone https://github.com/revyos/thead opensbi.git opensbi ``` 然后开始执行编译命令 ```shell pushd opensbi make PLATFORM generic ARCH ${ARCH} CROSS_COMPILE ${toolchain_tripe} sudo install D p m 644 build/platform/generic/firmware/fw_payload.bin \\ \"${GITHUB_WORKSPACE}/rootfs/boot/\" popd ``` 检查输出的文件 ``` tree ${GITHUB_WORKSPACE}/rootfs ``` 将目前构建好的kernel, uboot, opensbi相关文件打包为压缩包 ```shell tar zcvf kernel.tar.gz rootfs ``` 完成上述步骤后仍可以继续使用yocto来进行开发，yocto使用技巧可参考thead yocto相关介绍。 欢迎投稿～ 投稿接受后可得￥5～150（$1~20）优惠券！"},"/hardware/zh/lichee/th1520/lpi4a/7_develop_mainline.html":{"title":"系统开发","content":" title: 系统开发 keywords: Linux, Lichee, TH1520, SBC, RISCV, Kernel, SDK, Develop update: date: 2023 05 08 version: v1.0 author: wonder content: Release docs "},"/hardware/zh/lichee/th1520/lpi4a/5_desktop.html":{"title":"桌面系统基础使用","content":" title: 桌面系统基础使用 keywords: Linux, Lichee, TH1520, SBC, RISCV, Debian, Desktop update: date: 2023 05 08 version: v1.0 author: wonder content: Release docs ## 登录系统 本篇文档以默认的 Debian 桌面系统为例，介绍基础系统使用操作。 将 LicheePi 4A 连接上显示器后，可以看到图形化交互界面了。 在登录界面，输入用户名 `sipeed`，密码 `licheepi` 就可以登录进系统了。 > 总共有三个用户，`root`，`debian`，`sipeed`，初始密码均为`licheepi` > 有些版本的`debian`用户的密码为`sipeed` ![usage_login_userpasserward](./assets/desktop/usage_login_userpasserward.png) ## 打开命令行 在 LicheePi 4A 的 Debian 图形化系统中，使用快捷键 `Ctrl` + `Alt` + `T` 三个组合键可以直接打开命令行终端，来快速方便地操作系统。 ![usage_debian_terminal_shell_hotkey](./assets/desktop/usage_debian_terminal_shell_hotkey.png) ## 连接网络 ### 连接有线网络 LicheePi 4A 由两个千兆网络接口；将已经接通网络的网线插入到 LicheePi 4A 的网络接口中节能实现连接有线网络了。 <table> <tr> <td>插上网线之前</td> <td>插上网线之后</td> </tr> <tr> <td><img src \"./assets/desktop/usage_debian_ethernet_port_disconnect_one.png\" alt \"usage_debian_ethernet_port_connect_one\"></td> <td><img src \"./assets/desktop/usage_debian_ethernet_port_connect_one.png\" alt \"usage_debian_ethernet_port_connect_one\"></td> </tr> <tr> <td colspan 2> 上面两张图对比可以看到：在接上网线前，系统中 <code>Ethernet Network</code> 下面显示着 <code>disconnected</code>, 接上网线后显示 <code>Wired connection </code></td> </tr> </table> ### 连接无线网络 LicheePi 4A 板载无线模组，支持蓝牙和 wifi 。 从状态栏中的 `Avaliable networks` 中查看自己想要连接到的无线网络，输入密码之后就自动连接上了。 <table> <tr> <td colspan 2><img src \"./assets/desktop/usage_debian_select_wireless_network.png\" alt \"usage_debian_select_wireless_network\"></td> </tr> <tr> <td><img src \"./assets/desktop/usage_debian_wireless_network_password.png\" alt \"usage_debian_wireless_network_password\"></td> <td><img src \"./assets/desktop/usage_debian_wireless_network_connected.png\" alt \"usage_debian_wireless_network_connected\"></td> </tr> </table> 在输入密码的弹出窗口中，`Wi Fi adapter` 中需要选择 `wlan0` 来连接网络。 <! ## TODO 连接蓝牙 > ## 软件安装 在完成网络连接后，即可进行软件包的更新，安装。 ### 软件源 在 Debian 系统中，可以使用 apt (Advanced Packaging Tool) 来进行软件的安装。 安装软件的时候，会从系统指定的软件网站中搜索并下载目标软件，当目标网站访问困难（比如服务器距离太远或者服务器网络不佳）时，可以手动设置编辑软件源网站，改成距离自己当前最近的源，来减少下载时间。 软件源默认使用 `/etc/apt/sources.list` 文件里面的内容，有额外需要的话可以自行更改。但是要注意需要使用支持 Risc V 架构的软件源。 ![usage_debian_apt_change_source](./assets/desktop/usage_debian_apt_change_source.png) ### 升级软件 使用 `sudo apt update` 可以更新软件列表，一般在更换软件源之后需要使用这个命令。 然后使用 `sudo apt upgrade package_name` 可以更新名称为 `package_name` 的软件。 比如下面是使用 `sudo apt upgrade vim` 来更新 `vim` 这个软件的示例 ![usage_debian_apt_upgrade_vim](./assets/desktop/usage_debian_apt_upgrade_vim.png) ### 安装程序 可以借助于 apt 命令来安装软件；比如使用 `sudo apt install package_name` 命令来安装 `package_name`，下面是使用 apt 来安装 `net tools` 的例子。 ![usage_debian_apt_install_nettools](./assets/desktop/usage_debian_apt_install_nettools.png) 安装 `net tools` 后，就可以使用 `ifconfig` 命令了。 ![usage_debian_ifconfig_result_list](./assets/desktop/usage_debian_ifconfig_result_list.png) 箭头指向的地方就是常说的 IP 地址了。 ## SSH 如果你的镜像里没有 ssh 或 sshd 指令，可以先通过以下指令安装： ```bash sudo apt install ssh openssh server ``` 安装之后即可使用 ssh 来远程登录到其它机器操作，或者在其它机器上使用 ssh 登录到 LicheePi 4A 还可以使用 scp 进行文件传输： ```bash scp demo.zip sipeed@192.168.1.9:~/ ``` ## 输入法 如果你需要进行非 ascii 的字符输入，就需要安装输入法，这里以中文输入法为例，其它语言请自行查找相关教程。 先安装 ibus libpinyin： ```bash sudo apt install y ibus libpinyin ``` > 注意这里会消耗约200MB磁盘空间 安装完后，重启板卡，即可在 Applications 下看到 `IBus Preference` 选项，点击进入设置。 ![pinyin_cfg0](./assets/desktop/pinyin_cfg0.png) 在出现的界面里点击 `Input Method`，点击 `Add`，选择 `Chinese`，选择 `Intelligent Pinyin`，点击 `Add`，即可添加中文拼音输入法。 ![pinyin_cfg1](./assets/desktop/pinyin_cfg1.png) 在右上角点击输入法图标，可见以下选项，选择 `Chinese Intelligent Pinyin` 即可。 ![pinyin_cfg2](./assets/desktop/pinyin_cfg2.png) 此时即可在系统中顺利输入中文： ![pinyin_cfg3](./assets/desktop/pinyin_cfg3.png) > 注：在 0425 版本镜像中，可能会由于 GPU 支持问题，导致安装了输入法后，出现图形界面卡顿滞后的问题。 ## 办公软件 部分镜像里内置了基础的 Office 办公软件（LibreOffice）： ![office0](./assets/desktop/office0.png) LibreOffice Calc 即 XLS 功能： ![office_calc](./assets/desktop/office_calc.png) LibreOffice Impress 即 PPT 功能： ![office_impress](./assets/desktop/office_impress.png) LibreOffice Writer 即 WORD 功能： ![office_writer](./assets/desktop/office_writer.png) ## 浏览器 系统内置了火狐浏览器（Firefox）： ![browser0](./assets/desktop/browser0.png) 使用搜索引擎： ![browser_bing](./assets/desktop/browser_bing.png) 观看在线视频： ![browser_bili](./assets/desktop/browser_bili.png) > 注：由于目前（0425）版本还未完全适配好 GPU，视频编解码使用 CPU 软解，所以浏览器下播放视频占用率较高。实际性能以未来的 GPU 适配完成的镜像为准。 ## 播放器 系统内置了一些开源播放器，我们建议使用 VLC Player 作为视频播放器 ![player](./assets/desktop/player.png) ## 编程开发 ### Python 系统已内置了 python3 环境，可以在终端直接运行： ![python](./assets/desktop/python.png) 如果需要安装Python包，则使用：`sudo apt install python3 XXX` 比如安装pyserial包：`sudo apt install python3 serial` 即可 ### C 需要安装 `build essential` 包，占用约800MB磁盘空间 ```bash sudo apt install build essential ``` 然后即可使用 gcc 进行相关编译操作： ![gcc](./assets/desktop/gcc.png) ## 扩展存储空间 内测版板载 eMMC 容量较小，留给用户的空间只有 2～3GB，如果需要进行大容量存储，则需要扩展存储空间，可选使用 USB 存储或者 TF 存储。 ### 挂载 U 盘 将一个 U 盘插入 LicheePi 4A 的 USB 口后，可以在命令终端窗口使用 `dmesg` 查看板卡硬件变动信息。 如下是连接 U 盘后，使用 `dmesg` 在命令行终端看到的最新信息（截取）。 ![usage_debian_udisk_dmesg](./assets/desktop/usage_debian_udisk_dmesg.png) 上面的信息显示出了板卡的外设更改信息；从中可以看到有一个大容量 USB 存储设备连接到了 LicheePi 4A。 使用命令 `cat /proc/partitions grep \"sd*\"` 命令可以查看到 U 内部的分区个数 ![usage_debian_udisk_partition_detail](./assets/desktop/usage_debian_udisk_partition_detail.png) 以上面的结果为例，其中 `sda` 指代的是整个 U 盘，`sda1` 和 `sda2` 表示的是 U 盘里面的两个分区。 先在桌面系统创建一个文件夹，然后使用 `mount` 命令将 U 盘的某一分区挂载到该文件夹下。 ```bash mkdir ~/Desktop/udisk # 在桌面创建一个名为 udisk 的文件夹 mount /dev/sda2 ~/Desktop/udisk # 挂载 U 盘的 sda2 分区到 udisk 文件夹 ``` <table> <tr> <td> 运行命令前 </td> <td> 运行命令后 </td> </tr> <tr> <td style \"white space:nowrap\"><img src \"./assets/desktop/usage_debian_udisk_before_mount.png\" alt \"usage_debian_udisk_before_mount\"></td> <td style \"white space:nowrap\"><img src \"./assets/desktop/usage_debian_udisk_after_mount.png\" alt \"usage_debian_udisk_after_mount\"></td> </tr> <tr> <td colspan 2> 运行命令后桌面新增了一个名为 udisk 的文件夹，使用鼠标双击打开 udisk 文件夹后可以看到文件夹里面的内容与 U 盘里面的实际内容一致 <img src \"./assets/desktop/usage_debian_udisk_open_folder.png\" alt \"usage_debian_udisk_open_folder\"></td> </tr> </table> ### 挂载 TF卡 将 TF 卡插入 LicheePi 4A 背面的 TF 卡槽中，即可在系统下看到 `/dev/mmcblk1` 设备 （/dev/mmcblk0 是 SOM 上的 eMMC） 如果 TF 卡尚未分区或者格式化，用户可以使用 `sudo fdisk /dev/mmcblk1` 指令进行分区， 然后使用 `sudo mkfs.ext4 /dev/mmcblk1p1` 或者 `sudo mkfs.vfat /dev/mmcblk1p1` 对新建的分区进行格式化操作。 如果想作为扩展分区使用，建议使用 ext4；如果想作为与 Windows 交换数据的 TF 卡，建议使用 vfat。 格式化好后，即可与上节内容一样进行挂载操作，确认是否挂载正常。 ### 设置开机挂载 验证手工挂载成功后，你可以进一步设置开机挂载。 只需要在 /etc/fstab 文件内加上需要开机自动挂载的设备信息即可，以下是在最后一行添加TF卡自动挂载的示例。 ```bash sipeed@lpi4a:~$ cat /etc/fstab # UNCONFIGURED FSTAB FOR BASE SYSTEM /dev/mmcblk0p3 / auto defaults 1 1 /dev/mmcblk0p2 /boot auto defaults 0 0 /dev/mmcblk1p1 /mnt auto defaults 0 2 ``` 第一个数字：0 表示开机不检查磁盘，1 表示开机检查磁盘； 第二个数字：0 表示交换分区，1 代表启动分区（Linux），2 表示普通分区 /dev/mmcblk1p1 也可使用磁盘 UUID，即写成 UUID xxxx xxx 的形式，UUID 可以使用`sudo blkid`查看： `/dev/mmcblk1p1: UUID \"033173ff b3ab 494c ab14 4dcd656a9214\" BLOCK_SIZE \"4096\" TYPE \"ext4\" PARTUUID \"8e4e28df 01\"` ## 更多 欢迎投稿～ 投稿接受后可得￥5～150（$1~20）优惠券！"},"/hardware/zh/lichee/th1520/lpi4a/11_credits.html":{"title":"致谢","content":" title: 致谢 keywords: Linux, Lichee, TH1520, SBC, RISCV, credits update: date: 2023 05 08 version: v1.0 author: wonder content: Release docs 本章节专门向 LicheePi 4A 作出贡献的个人和团体致谢！ 感谢你们的贡献让 RISC V 发展得更快更好！ （本文按个人意愿以真名或者网名进行致谢） ## 矽速 泽畔，阔爷，瀚宝，wonder，ztd，... ## 平头哥 春强，陈炜，穆呈，陆斌，... 特别感谢 陆斌 同学的全程沟通！ ## PLCT Wu Wei：感谢吴老板大力支持！老板大气！ [Icenowy Zheng](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/log/?qt author&q Icenowy+Zheng)：冰激凌，永远的神，手打 binary patch，真人快打！ 高涵：revyos之父！ Estela ad Astra：预订 OpenWRT！ ## 开源社区 [Jisheng Zhang](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/log/?qt author&q Jisheng+Zhang): TH1520 主线化支持 范文捷：Wine CE 作者，在 LPi4A 上进行相关移植测试。"},"/hardware/zh/lichee/th1520/lpi4a/usage.html":{"title":"LicheePi 4A 基础上手","content":"# LicheePi 4A 基础上手 ## 需要的配件 为了更容易地使用 LicheePi 4A，需要准备以下的配件: HDMI 显示器，或者与 LicheePi 4A 拍套售卖的显示屏；图形化操作系统很方便操作。 键盘和鼠标；用来操作图形化系统。 电源适配器；最好购买与 LicheePi 4A 配套的电源适配器；这会给 LicheePi 4A 提供足够的供电。 ## 烧录系统 ### 获取镜像 百度网盘：[点我](https://pan.baidu.com/s/1jnjz0KO_xnO5R8tWlXtx0A) ### 烧录系统 烧录镜像需要使用 参考：https://gitee.com/thead yocto/light_deploy_images ## 串口登录 20230423 记录: > 当前图形化系统显示驱动有一些问题，先使用串口登录到系统后，删除 `/lib/libGLESv1_CM_PVR_MESA.so` 和`/lib/libGLESv2_PVR_MESA.so` 两个文件后，可以流畅的使用图形化系统了 使用串口连接上底板上 GPIO 的 `U0 RX` 和 `U0 TX`，然后打开串口软件，`Windows` 上可以使用 `mobaxterm`，`Linux` 系统可以使用 `minicom`。 设置波特率 `115200` 后打开选择并打开连接在电脑上的串口端口，然后在打开串口后的终端里可以敲击几次 **回车键** 来看看终端有没有反应. ![usage_serial_login_test](./assets/usage/usage_serial_login_test.png) 如果没有反应： 1. 检查 Lichee Pi 4A 的供电情况；如果底板 TypeC 附近的 LED 亮起来，说明供电正常。 2. 检查串口引脚接线情况；可以更换 `TX` 和 `RX` 接线来尝试排除串口接线错误导致串口不能正常通信的情况 3. 检查系统烧录情况；在底板 TypeC 接口与天线接口之间有一个复位按键，尝试按下后可以从串口终端中开到启动信息日志；多次重启说明系统有缺失，需要重新烧录镜像。 输入用户名 `root`，密码 `sipeed` 就可以登录进系统了。 登录系统后，使用 `rm /lib/libGLESv1_CM_PVR_MESA.so` 和`rm /lib/libGLESv2_PVR_MESA.so` 命令来删除两处文件，暂时解决图形化系统卡顿的情况。 ![usage_login_remove_gpu_file](./assets/usage/usage_login_remove_gpu_file.png) ## 登录系统 将 Lichee Pi 4A 连接上显示器后，可以看到图形化交互界面了。 在登录界面，输入用户名 `root`，密码 `sipeed` 就可以登录进系统了。 > 2023 年 4 月 25 日更新镜像的登录密码为 `licheepi` ![usage_login_userpasserward](./assets/usage/usage_login_userpasserward.png) ## 打开命令行 在 Lichee Pi 4A 的 Debian 图形化系统中，使用快捷键 `Ctrl` + `Alt` + `T` 三个组合键可以直接打开命令行终端，来快速方便地操作系统。 ![usage_debian_terminal_shell_hotkey](./assets/usage/usage_debian_terminal_shell_hotkey.png) ## 控制风扇 在 Lichee Pi 4A 上，风扇是通过 PWM 来控制的，使用 ## 连接网络 ### 连接有线网络 Lichee Pi 4A 由两个千兆网络接口；将已经接通网络的网线插入到 Lichee Pi 4A 的网络接口中节能实现连接有线网络了。 <table> <tr> <td>插上网线之前</td> <td>插上网线之后</td> </tr> <tr> <td><img src \"./assets/usage/usage_debian_ethernet_port_disconnect_one.png\" alt \"usage_debian_ethernet_port_connect_one\"></td> <td><img src \"./assets/usage/usage_debian_ethernet_port_connect_one.png\" alt \"usage_debian_ethernet_port_connect_one\"></td> </tr> <tr> <td colspan 2> 上面两张图对比可以看到：在接上网线前，系统中 <code>Ethernet Network</code> 下面显示着 <code>disconnected</code>, 接上网线后显示 <code>Wired connection </code></td> </tr> </table> ### 连接无线网络 Lichee Pi 4A 板载无线模组，支持蓝牙和 wifi 。 从状态栏中的 `Avaliable networks` 中查看自己想要连接到的无线网络，输入密码之后就自动连接上了。 <table> <tr> <td colspan 2><img src \"./assets/usage/usage_debian_select_wireless_network.png\" alt \"usage_debian_select_wireless_network\"></td> </tr> <tr> <td><img src \"./assets/usage/usage_debian_wireless_network_password.png\" alt \"usage_debian_wireless_network_password\"></td> <td><img src \"./assets/usage/usage_debian_wireless_network_connected.png\" alt \"usage_debian_wireless_network_connected\"></td> </tr> </table> 在输入密码的弹出窗口中，`Wi Fi adapter` 中的两个选项都能用来链接无线网络，选择一个即可。 <! ## 连接蓝牙 > ## 测试 USB 接口 使用桌面系统时，键盘鼠标正常使用就说明 USB 是正常的。 当然，只有命令行终端时，使用 `lsusb` 命令可以查看当前板卡上所连接的 USB 设备。 如下图，箭头所指的是已经接上 Lichee Pi 4A 的键盘。 ![usage_debian_lsusb_list_device](./assets/usage/usage_debian_lsusb_list_device.png) ## 挂载 U 盘 除了上面使用 `lsusb` 来查看 USB 接口的连接情况外，也可以使用 `dmesg` 命令来查看内核信息，进一步查看详细信息。 将一个 U 盘插入 Lichee Pi 4A 的 USB 口后，可以在命令终端窗口使用 `dmesg` 查看板卡硬件变动信息。 如下是连接 U 盘后，使用 `dmesg` 在命令行终端看到的最新信息（截取）。 ![usage_debian_udisk_dmesg](./assets/usage/usage_debian_udisk_dmesg.png) 上面的信息显示出了板卡的外设更改信息；从中可以看到有一个大容量 USB 存储设备连接到了 Lichee Pi 4A。 使用命令 `cat /proc/partitions grep \"sd*\"` 命令可以查看到 U 内部的分区个数 ![usage_debian_udisk_partition_detail](./assets/usage/usage_debian_udisk_partition_detail.png) 以上面的结果为例，其中 `sda` 指代的是整个 U 盘，`sda1` 和 `sda2` 表示的是 U 盘里面的两个分区。 先在桌面系统创建一个文件夹，然后使用 `mount` 命令将 U 盘的某一分区挂载到该文件夹下。 ```bash mkdir ~/Desktop/udisk # 在桌面创建一个名为 udisk 的文件夹 mount /dev/sda2 ~/Desktop/udisk # 挂载 U 盘的 sda2 分区到 udisk 文件夹 ``` <table> <tr> <td> 运行命令前 </td> <td> 运行命令后 </td> </tr> <tr> <td style \"white space:nowrap\"><img src \"./assets/usage/usage_debian_udisk_before_mount.png\" alt \"usage_debian_udisk_before_mount\"></td> <td style \"white space:nowrap\"><img src \"./assets/usage/usage_debian_udisk_after_mount.png\" alt \"usage_debian_udisk_after_mount\"></td> </tr> <tr> <td colspan 2> 运行命令后桌面新增了一个名为 udisk 的文件夹，使用鼠标双击打开 udisk 文件夹后可以看到文件夹里面的内容与 U 盘里面的实际内容一致 <img src \"./assets/usage/usage_debian_udisk_open_folder.png\" alt \"usage_debian_udisk_open_folder\"></td> </tr> </table> ## 挂载 TF 卡 将 tf 卡插入到 Lichee Pi 4A 底板，使用 ## 音频测试 ### 测试音频播放 Lichee Pi 4A 底板上有扬声器接口和 3.5mm 音频接口两处可以播放音频的地方。 要注意的是 3.5mm 音频接口和扬声器接口是互斥的：接上 3.5mm 音频设备后，板载的扬声器接口是被禁用的；断开 3.5mm 音频设备才能使用板载的扬声器。 系统内置了一些 wav 音频文件用来测试，直接使用 `aplay` 命令来播放音频文件就可以。 ![usage_debian_list_audio_file](./assets/usage/usage_debian_list_audio_file.png) 运行下面的命令后，可以从耳机孔音频设备中听到 `Rear` `Left` 两个单词的声音。 ```bash aplay /usr/share/sounds/alsa/Rear_Left.wav ``` ## 设置中文显示 ## 安装中文输入法 ## 更换软件源 在 Debian 系统中，可以使用 apt (Advanced Packaging Tool) 来进行软件的安装。 安装软件的时候，会从系统指定的软件网站中搜索并下载目标软件，当目标网站访问困难（比如服务器距离太远或者服务器网络不佳）时，可以手动设置编辑软件源网站，改成距离自己当前最近的源，来减少下载时间。 软件源默认使用 `/etc/apt/sources.list` 文件里面的内容，有额外需要的话可以自行更改。但是要注意需要使用支持 Risc V 架构的软件源。 ![usage_debian_apt_change_source](./assets/usage/usage_debian_apt_change_source.png) ## 升级软件 使用 `sudo apt update` 可以更新软件列表，一般在更换软件源之后需要使用这个命令。 然后使用 `sudo apt upgrade package_name` 可以更新名称为 `package_name` 的软件。 比如下面是使用 `sudo apt upgrade vim` 来更新 `vim` 这个软件的示例 ![usage_debian_apt_upgrade_vim](./assets/usage/usage_debian_apt_upgrade_vim.png) ## 安装程序 可以借助于 apt 命令来安装软件；比如使用 `sudo apt install package_name` 命令来安装 `package_name`，下面是使用 apt 来安装 `net tools` 的例子。 ![usage_debian_apt_install_nettools](./assets/usage/usage_debian_apt_install_nettools.png) 安装 `net tools` 后，就可以使用 `ifconfig` 命令了。 ![usage_debian_ifconfig_result_list](./assets/usage/usage_debian_ifconfig_result_list.png) 箭头指向的地方就是常说的 IP 地址了。 ## 更改开机 LOGO ## 操作 GPIO > 进阶使用 ## 获取设备 IP ## VNC 远程桌面 ## 通过 SSH 登录到系统 ### 远程登录到系统 ### 远程拷贝文件 ## Samba 文件共享 Samba 基于SMB/CIFS网络协议，不同设备之间可以通过该协议共享访问文件、串行端口等，这里通过它将 Windows 10 系统设备上的共享文件夹挂载至 Lichee Pi 4A。 下面的命令会自动安装 Samba 作为服务器和客户端的全部必需组件： ```bash sudo apt install samba samba common bin smbclient cifs utils ``` ## 搭建 FTP 服务 ## 配置 NGINX ## 安装 Docker ## 测试 GPU ## 编程语言体验 ### C ### Java ### Python ## 使用 Python 进行串口通信 ## 编译体验 Opencv ## 编译体验 Wiringpi ## 配置开机脚本 ### 开机自动挂载 U 盘"},"/hardware/zh/lichee/th1520/lpi4a/4_burn_image.html":{"title":"烧录镜像","content":" title: 烧录镜像 keywords: Linux, Lichee, TH1520, SBC, RISCV, image update: date: 2023 05 08 version: v1.0 author: wonder content: Release docs ## 准备工作 ### 获取镜像 参见上一章“镜像集合”，选取需要的镜像下载。 以下的烧录方式以 Debian 镜像 `LPi4A_Test_0425.7z` 为例。 ### 获取烧录工具 在镜像集合的网盘内可以获得 `burn_tool.zip`, 解压可得 win/linux/mac 三个系统下的 fastboot 烧录工具。 ## 进入烧录模式 注意不同版本硬件进入烧录模式的方式略有不同，参见以下章节。 ### 内测版硬件 按住板上的BOOT按键不放，然后插入 USB C 线缆上电（线缆另一头接 PC ），即可进入 USB 烧录模式。 ![press_boot](./assets/burn_image/press_boot.png) 在 Windows 下使用设备管理器查看，会出现 “USB download gadget” 设备。 在 Linux 下，使用 `lsusb` 查看设备，会显示以下设备： `ID 2345:7654 T HEAD USB download gadget` ### 正式版硬件 TODO ### Windows 下驱动安装 Windows 下初次使用需要安装驱动，注意由于该驱动未经过数字签名，需要用户手工禁用数字签名。 ![before_install_driver](./assets/burn_image/before_install_driver.png) ![install_driver](./assets/burn_image/install_driver.png) ## 烧录镜像 进入烧录模式后，可使用 burn_tool.zip 内的 fastboot 进行烧录操作，注意可能需要先赋予 fastboot 可执行权限。 以 linux 下为例： 在按住BOOT按键的条件下，系统在reset启动后，会默认进入fastboot模式， 这时侯我们可以通过fastboot下载并启动u boot镜像的命令，来进入到u boot的fastboot烧录模式（相比Brom阶段，会有更大下载buffer，速度会更快） 下面的指令会检查并格式化分区，请务必执行，否则后面烧录 rootfs 会很慢。 ```bash sudo ./fastboot flash ram ./images/u boot with spl.bin sudo ./fastboot reboot sleep 1 ``` 分别烧录下面三个镜像：启动引导镜像 uboot，启动分区 boot，操作系统根分区 root ```bash sudo ./fastboot flash uboot ./images/u boot with spl.bin sudo ./fastboot flash boot ./images/boot.ext4 sudo ./fastboot flash root ./images/rootfs.ext4 ``` `boot.ext4` 为 boot 分区，包含以下内容： ```bash fw_dynamic.bin #opensbi Image #kernel image kernel release #commit id of kernel light_aon_fpga.bin #fw for E902 aon light_c906_audio.bin #fw for C906 audio light lpi4a.dtb #1.85GHz dtb light lpi4a_2Ghz.dtb #2GHz overclock dtb light lpi4a ddr2G.dtb #history dtb ``` `rootfs.ext4` 为根文件系统，默认为 Debian 系统。 烧录镜像的典型 log 输出如下： ![](./assets/burn_image/burn_image_progress_result.png) <! ```bash (base) pc@n5105:~/work/$ sudo ./fastboot flash ram u boot with spl.bin Sending 'ram' (935 KB) OKAY [ 0.248s] Writing 'ram' OKAY [ 0.002s] Finished. Total time: 0.255s (base) pc@n5105:~/work/$ sudo ./fastboot reboot Rebooting OKAY [ 0.001s] Finished. Total time: 0.202s (base) pc@n5105:~/work/$ sudo ./fastboot flash uboot u boot with spl.bin Sending 'uboot' (935 KB) OKAY [ 0.054s] Writing 'uboot' OKAY [ 0.030s] Finished. Total time: 0.107s (base) pc@n5105:~/work/$ sudo ./fastboot flash boot boot_20230420.ext4 Sending 'boot' (40000 KB) OKAY [ 1.705s] Writing 'boot' OKAY [ 0.877s] Finished. Total time: 2.770s (base) pc@n5105:~/work/$ sudo ./fastboot flash root rootfs 20230425 001635 nogpu.ext4 Invalid sparse file format at header magic Sending sparse 'root' 1/37 (114572 KB) OKAY [ 4.793s] Writing 'root' OKAY [ 3.087s] Sending sparse 'root' 2/37 (105264 KB) OKAY [ 4.465s] Writing 'root' OKAY [ 2.330s] Sending sparse 'root' 3/37 (111970 KB) OKAY [ 4.814s] Writing 'root' OKAY [ 2.861s] Sending sparse 'root' 4/37 (114684 KB) OKAY [ 4.902s] Writing 'root' OKAY [ 2.658s] Sending sparse 'root' 5/37 (101490 KB) OKAY [ 4.305s] Writing 'root' OKAY [ 2.652s] Sending sparse 'root' 6/37 (114684 KB) OKAY [ 4.648s] Writing 'root' OKAY [ 2.657s] Sending sparse 'root' 7/37 (113862 KB) OKAY [ 4.755s] Writing 'root' OKAY [ 2.826s] Sending sparse 'root' 8/37 (111189 KB) OKAY [ 4.741s] Writing 'root' OKAY [ 2.695s] Sending sparse 'root' 9/37 (114625 KB) OKAY [ 4.865s] Writing 'root' OKAY [ 2.660s] Sending sparse 'root' 10/37 (104030 KB) OKAY [ 4.506s] Writing 'root' OKAY [ 4.108s] Sending sparse 'root' 11/37 (111701 KB) OKAY [ 4.744s] Writing 'root' OKAY [ 2.717s] Sending sparse 'root' 12/37 (107317 KB) OKAY [ 4.568s] Writing 'root' OKAY [ 2.583s] Sending sparse 'root' 13/37 (114629 KB) OKAY [ 4.830s] Writing 'root' OKAY [ 2.753s] Sending sparse 'root' 14/37 (109798 KB) OKAY [ 4.711s] Writing 'root' OKAY [ 2.778s] Sending sparse 'root' 15/37 (112203 KB) OKAY [ 4.795s] Writing 'root' OKAY [ 2.982s] Sending sparse 'root' 16/37 (112502 KB) OKAY [ 4.827s] Writing 'root' OKAY [ 2.991s] Sending sparse 'root' 17/37 (114110 KB) OKAY [ 4.849s] Writing 'root' OKAY [ 2.853s] Sending sparse 'root' 18/37 (114681 KB) OKAY [ 4.888s] Writing 'root' OKAY [ 2.802s] Sending sparse 'root' 19/37 (112042 KB) OKAY [ 4.799s] Writing 'root' OKAY [ 3.674s] Sending sparse 'root' 20/37 (109101 KB) OKAY [ 4.631s] Writing 'root' OKAY [ 2.582s] Sending sparse 'root' 21/37 (114225 KB) OKAY [ 4.623s] Writing 'root' OKAY [ 2.782s] Sending sparse 'root' 22/37 (114365 KB) OKAY [ 4.703s] Writing 'root' OKAY [ 2.667s] Sending sparse 'root' 23/37 (103529 KB) OKAY [ 4.133s] Writing 'root' OKAY [ 2.442s] Sending sparse 'root' 24/37 (114664 KB) OKAY [ 4.631s] Writing 'root' OKAY [ 2.581s] Sending sparse 'root' 25/37 (114550 KB) OKAY [ 4.749s] Writing 'root' OKAY [ 2.878s] Sending sparse 'root' 26/37 (114686 KB) OKAY [ 4.796s] Writing 'root' OKAY [ 2.853s] Sending sparse 'root' 27/37 (114466 KB) OKAY [ 4.800s] Writing 'root' OKAY [ 2.894s] Sending sparse 'root' 28/37 (110689 KB) OKAY [ 4.711s] Writing 'root' OKAY [ 2.616s] Sending sparse 'root' 29/37 (114687 KB) OKAY [ 4.880s] Writing 'root' OKAY [ 2.992s] Sending sparse 'root' 30/37 (110984 KB) OKAY [ 4.710s] Writing 'root' OKAY [ 2.451s] Sending sparse 'root' 31/37 (114685 KB) OKAY [ 4.920s] Writing 'root' OKAY [ 2.749s] Sending sparse 'root' 32/37 (114684 KB) OKAY [ 4.825s] Writing 'root' OKAY [ 2.503s] Sending sparse 'root' 33/37 (114684 KB) OKAY [ 4.816s] Writing 'root' OKAY [ 3.262s] Sending sparse 'root' 34/37 (114686 KB) OKAY [ 4.745s] Writing 'root' OKAY [ 2.825s] Sending sparse 'root' 35/37 (114684 KB) OKAY [ 4.913s] Writing 'root' OKAY [ 2.630s] Sending sparse 'root' 36/37 (114684 KB) OKAY [ 4.838s] Writing 'root' OKAY [ 2.593s] Sending sparse 'root' 37/37 (21324 KB) OKAY [ 0.926s] Writing 'root' OKAY [ 0.487s] Finished. Total time: 281.671s ``` > ## 启动机制 brom > uboot spl > uboot > opensbi > kernel TODO ## 批量烧录 如果你有商业需求，需要批量烧录固件，可以使用 sipeed 提供的 ARM/RV 版 fastboot 制作离线批量烧录器。 如果你需要烧录的数量很大，也可以直接联系 support@sipeed.com，我们提供预烧录镜像服务。"},"/hardware/zh/lichee/th1520/lpi4a/1_intro.html":{"title":"板卡介绍","content":" title: 板卡介绍 keywords: Linux, Lichee, TH1520, SBC, RISCV update: date: 2023 05 08 version: v1.0 author: wonder content: Release docs ## 简介 LicheePi 4A 是基于 [Lichee Module 4A](http://wiki.sipeed.com/hardware/zh/lichee/th1520/lm4a.html) 核心板的 高性能 RISC V Linux 开发板，以 [TH1520](https://www.t head.cn/product/yeying) 为主控核心（4xC910@1.85G， RV64GCV，4TOPS@int8 NPU， 50GFLOP GPU），板载最大 16GB 64bit LPDDR4X，128GB eMMC，支持 HDMI+MIPI 双4K 显示输出，支持 4K 摄像头接入，双千兆网口（其中一个支持POE供电）和 4 个 USB3.0 接口，多种音频输入输出（由专用 C906 核心处理）。 ![lpi4a](./assets/intro/lpi4a.png) LicheePi 4A 是截止目前（2023Q2）为止最强的 RISC V SBC。性能约为上一代 RISC V SBC [VisionFive2](https://www.starfivetech.com/en/site/boards)的2倍；未开启专用指令集加速的情况下，性能逼近基于 ARM A72 的树莓派 4，在开启相关指令集加速的情况下，可以与树莓派 4 持平。而且最高具备 16GB 超大内存，是树莓派 4 最高配置 8GB 内存的两倍！ ![benchmark](./assets/intro/benchmark.png) ![geekbench5](./assets/intro/geekbench5.png) LicheePi 4A 可以用作典型的 RISC V 验证平台，其强大的性能可以较快速地实现本地编译，而无需使用 QEMU 进行编译。 我们在近期（2023Q2）还会放出基于LM4A的集群计算板卡 LicheeCluster 4A，最大支持 7xLM4A 进行集群计算，编译，非常适合发行版编译农场场景，尽情期待。 在保持高性能的同时，我们也尽量进行了 CostDown 设计，8GB 内存版本价格在 ￥749~ 899（\\\\$100 ~ \\\\$130），16GB 内存版本在 ￥1100~1300 （\\\\$155 ~\\\\$185）, 性价比上超越了树莓派 4（8GB ~\\\\$150）! 无论你是否是 RISC V 粉丝，你都值得入手体验下 LicheePi 4A 这款划时代的高性能 RISC V SBC！ ![desktop](./assets/intro/desktop.png) ## 欢迎投稿 本文档为在线文档，托管在 github 上，大家可以点击右上角 `编辑本页` 链接来进行编辑~ 对成功提交文档的用户，我们视文档质量酌情提供 ￥5 ~ 150（\\\\$1 ~ 20）的优惠券~ ## 基础参数 <table> <thead> <tr> <th colspan 2>主控参数</th> </tr> </thead> <tbody> <tr> <td>主控芯片</td> <td>TH1520</td> </tr> <tr> <td>CPU处理器</td> <td>RISC V 64GCV C910*4@2GHz <br>· 每核支持 64KB I cache 和 64KB D Cache <br>· 四核共享 1MB L2 Cache <br>· 支持 TEE 和 REE，TEE/REE 支持核数启动时可配置<br>· 支持自定义且接口兼容 RISC V 的多核调试框架<br>· 独立电源域，支持 DVFS</td> </tr> <tr> <td>图形处理器</td> <td>· OpenCL 1.1/1.2/2.0<br>· OpenGL ES 3.0/3.1/3.2<br>· Vulkan 1.1/1.2<br>· Android NN HAL</td> </tr> <tr> <td>NPU处理器</td> <td>支持 4TOPS@INT8 通用 NNA 算力，主频 1GHz <br>· 支持 TensorFlow、ONNX、Caffe <br>· 支持 CNN、RNN、DNN 等</td> </tr> <tr> <td>视频解码器</td> <td>实时解码器，支持 H.265/H.264/VP9/8/7/6/AVS/AVS+/AVS2.0/VC1/MPEG4 <br>· 支持 H.264 BP/MP/HP@level 5.1 解码，最大 4K 分辨率<br>· 支持 H.265/HEVC Main Profile@level 5.1 解码，最大 4K 分辨率<br>· 支持 VP9 Profile 2 解码，最大 4K 分辨率<br>· 支持 AVS2.0 解码，最大 4K 分辨率<br>· 支持 VP6/7/8/AVS/AVS+/VC1/MPEG4 解码，最大 1920x1080 分辨率<br>· 解码性能最大 4K@75fps</td> </tr> <tr> <td>视频编码器</td> <td>· 支持 H.264 BP/MP/HP@level4.2 编码，最大 4K 分辨率<br>· 支持 H.265/HEVC Main Profile 编码，最大 4K 分辨率<br>· 仅支持 I 帧和 P 帧<br>· 编码性能最大 4K@40fps</td> </tr> <tr> <th colspan 2>硬件特性</th> </tr> <tr> <td>RAM</td> <td>· 8GB 64bits LPDDR4<br>· 16GB 64bits LPDDR4<br></td> </tr> <tr> <td>存储</td> <td>· eMMC: 可选 空贴、 8G、 32G、 128G<br>· 支持 TF 卡</td> </tr> <tr> <td>以太网</td> <td>· 2 x 千兆以太网接口，可选 POE</td> </tr> <tr> <td>USB</td> <td>· USB3.0 x 4<br>· USB2.0 x 1（仅用于烧录）</td> </tr> <tr> <td>音频接口</td> <td>· 1 x 3.5mm 耳机接口<br>· 一个扬声器接口<br>· 两个板载麦克风<br></td> </tr> <tr> <td>显示接口</td> <td>· 1 x HDMI2.0<br>· 1 x 4 lane MIPI DSI</td> </tr> <tr> <td>摄像头接口</td> <td>· 2 x 2 lane MIPI CSI<br>· 1 x 4 lane MIPI CSI</td> </tr> <tr> <td>GPIO</td> <td>· UART<br>· IIC<br>· SPI</td> </tr> </tbody> </table> ### 硬件资料下载 [板卡规格书](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/01_Specification) [底板原理图](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/02_Schematic) [底板点位图](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/03_Bit_number_map) [底板尺寸图](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/04_Dimensional_drawing) [模型文件](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/05_3D_model) ## 其他链接 [Github](https://github.com/sipeed/LicheePi4A) [淘宝](https://item.taobao.com/item.htm?id 715508771884) [Sipeed 下载站](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a) QQ群: 559614960 [点我自动加群](http://qm.qq.com/cgi bin/qm/qr?k 5YkapIhdtWHp8AEfM5_bFFYQIX3CUQN6) Telegram: https://t.me/linux4rv 论坛：bbs.sipeed.com 联系邮箱：support@sipeed.com"},"/hardware/zh/lichee/th1520/lpi4a/8_application.html":{"title":"典型应用","content":" title: 典型应用 keywords: Linux, Lichee, TH1520, SBC, RISCV, application update: date: 2023 05 08 version: v1.0 author: wonder content: Release docs ## llama.cpp llama 是 META 开源的大语言模型，[llama.cpp](https://github.com/ggerganov/llama.cpp) 是 ggerganov 开源的纯 cpp 运行的 llama 推理项目。 感谢 llama.cpp 这个优秀的项目，我们可以在 LicheePi 4A 上运行 LLM。 笔者在早些时候稍微修改了 llama.cpp [https://github.com/Zepan/llama.cpp](https://github.com/Zepan/llama.cpp)，使其可以在更小内存（低至 700MB 左右）运行 7B 模型。 可以看到 TH1520 花费约 6s 计算一个 token（未使用 V 扩展加速，V 扩展加速预计可加速 4～8 倍，如果你加入了 V 扩展支持，欢迎投稿！） ![llama_th1520](./assets/application/llama_th1520.png) 同时还简单测试了下在入门级 C906 内核上运行7B模型的可行性，由于 D1 的内存过小，使用了 mmap 方式只读扩展，所以引入了大量低速 IO 操作，使得运行速度大为降低，最后仅 18s/token ![llama_d1](./assets/application/llama_d1.png) ## Minecraft Server TODO ## Wine CE TODO ## 其它 欢迎投稿～ 投稿接受后可得￥5～150（$1~20）优惠券！"},"/hardware/zh/lichee/th1520/lpi4a/6_peripheral.html":{"title":"外设使用","content":" title: 外设使用 keywords: Linux, Lichee, TH1520, SBC, RISCV, Peripheral update: date: 2023 05 08 version: v1.0 author: wonder content: Release docs ## SoC 相关 ### CPU 运行频率 `sudo cat /sys/devices/system/cpu/cpu*/cpufreq/cpuinfo_cur_freq ` 单位为 KHz 注意系统自带温控策略，当系统过于空闲或者温度过高时，都会降频。请保持良好散热，使得 CPU 在 60 度以下，获得最佳性能。 ### 芯片温度 `cat /sys/class/thermal/thermal_zone0/temp` 单位为0.001摄氏度 ### CPU超频 TH1520 默认最大运行频率为 1.85GHz，但是经过初步测试发现，有 80% 左右的芯片可以在 2GHz 运行，有 50% 左右的芯片可以在 2GHz 通过压力测试。 这里放出简易超频步骤，仅供参考，不对稳定性和安全性做保证。 查看`/boot`下的文件： ```bash fw_dynamic.bin #opensbi Image #kernel image kernel release #commit id of kernel light_aon_fpga.bin #fw for E902 aon light_c906_audio.bin #fw for C906 audio light lpi4a.dtb #1.85GHz dtb light lpi4a_2Ghz.dtb #2GHz overclock dtb light lpi4a ddr2G.dtb #history dtb ``` 将 `light lpi4a_2Ghz.dtb` 拷贝覆盖为 `light lpi4a.dtb`，重启，即可修改开机后的最大频率。 注意有一定几率这样修改后无法启动，此时需要重新烧录固件来恢复。 如果成功启动，则可以查看下面的数值确认是否已成功超频： `sudo cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq` ## PWM 以散热风扇所接的 PWM1 为例，可以通过如下代码进行风扇使能操作： ```bash echo 1 > /sys/class/pwm/pwmchip0/export echo 1000000 > /sys/class/pwm/pwmchip0/pwm1/period echo 1000000 > /sys/class/pwm/pwmchip0/pwm1/duty_cycle echo 1 > /sys/class/pwm/pwmchip0/pwm1/enable ``` ## GPIO LicheePi 4A 板载 2x10pin 插针，其中有 16 个原生 IO，包括 6 个普通 IO，3 对串口，一个 SPI。 > 注意：SOC的所有原生IO均是1.8V电平，请注意电平转换。 > 插针上的串口输入侧已经进行了1/2分压处理，可以接3.3V的串口。 TH1520 SOC 具有4个GPIO bank，每个bank最大有32个IO： Bank Address kernel io num GPIO0 0xffec005000 456 487 GPIO1 0xffec006000 424 455 GPIO2 0xffe7f34000 392 423 GPIO3 0xffe7f38000 360 391 AO_GPIO 0xfffff41000 328 359 AO_GPIO4 0xfffff52000 296 327 AUDIO_GPIO0xffcb013000 其中 0x0 偏移处的 4Byte（32bit）是 GPIO 数据寄存器，0x4 偏移处的 4Byte（32bit）是 GPIO 方向寄存器 SOM 上的 GPIO 对应表格为： 名称 GPIO 01 GPIO0_27 02 GPIO0_28 03 GPIO2_0 04 AOGPIO4 05 GPIO2_1 06 GPIO1_22 07 GPIO0_24 08 GPIO0_25 09 GPIO3_2 10 GPIO3_3 11 GPIO1_3 12 GPIO1_4 13 GPIO1_5 14 GPIO1_6 LicheePi 4A上的插针的 GPIO 对应关系为： ![io_map](./assets/peripheral/io_map.png) > 以文档的标注为准，内测版的丝印标注可能有误 GPIO 操作： > 注意，可能需要事先设置 pinmux ```bash num xxx echo ${num} > /sys/class/gpio/export echo out>/sys/class/gpio/gpio${num}/direction echo 1 > /sys/class/gpio/gpio${num}/value echo 0 > /sys/class/gpio/gpio{num}/value ``` 也可以直接操作寄存器： > devmem 可以从此处下载编译：https://github.com/VCTLabs/devmem2/blob/master/devmem2.c ```bash ./devmem 0xffe7f38000 w ``` 系统内GPIO信息查看： ```bash sipeed@lpi4a:~$ sudo cat /sys/kernel/debug/gpio ``` 下面是示例结果: ![peripheral_gpio_information](./assets/peripheral/peripheral_gpio_information.png) <! ```bash sipeed@lpi4a:~$ sudo cat /sys/kernel/debug/gpio gpiochip8: GPIOs 296 327, parent: platform/fffff52000.gpio, fffff52000.gpio: AO_GPIO4 gpiochip7: GPIOs 328 359, parent: platform/fffff41000.gpio, fffff41000.gpio: AO_GPIO gpio 332 ( hubswitch ) out hi gpiochip6: GPIOs 360 391, parent: platform/ffe7f38000.gpio, ffe7f38000.gpio: GPIO3 gpiochip5: GPIOs 392 423, parent: platform/ffe7f34000.gpio, ffe7f34000.gpio: GPIO2 gpio 395 ( cs ) out hi ACTIVE LOW gpio 406 ( aon:soc_vdd5v_se_en ) out lo gpio 407 ( spi0 CS0 ) out hi ACTIVE LOW gpio 417 ( Volume Up Key ) in lo IRQ ACTIVE LOW gpio 421 ( aon:soc_wcn33_en ) out lo gpiochip4: GPIOs 424 455, parent: platform/ffec006000.gpio, ffec006000.gpio: GPIO1 gpio 443 ( Volume Down Key ) in hi IRQ ACTIVE LOW gpio 446 ( aon:soc_vbus_en ) out hi gpiochip3: GPIOs 456 487, parent: platform/ffec005000.gpio, ffec005000.gpio: GPIO0 gpio 457 ( spi2 CS0 ) out hi ACTIVE LOW gpio 486 ( aon:soc_vdd_3v3_en ) out hi gpiochip2: GPIOs 488 495, parent: i2c/3 0018, 3 0018, can sleep: IO expend 3 gpio 490 ( regulator hub vdd12 ) out hi gpio 491 ( regulator hub vcc5v ) out hi gpio 492 ( regulator pwr en ) out hi gpio 493 ( aon:soc_lcd0_vdd33_e) out hi gpio 494 ( aon:soc_lcd0_vdd18_e) out hi gpio 495 ( reset ) out hi ACTIVE LOW gpiochip1: GPIOs 496 503, parent: i2c/1 0018, 1 0018, can sleep: IO expend 2 gpio 496 ( aon:soc_cam2_dvdd12_) out lo gpio 501 ( wlan_default_wlan_po) out hi gpio 502 ( bt_default_poweron ) out lo gpiochip0: GPIOs 504 511, parent: i2c/0 0018, 0 0018, can sleep: IO expend 1 gpio 504 ( aon:soc_dvdd12_rgb ) out lo gpio 505 ( aon:soc_avdd28_rgb ) out lo gpio 506 ( aon:soc_dovdd18_rgb ) out lo gpio 507 ( aon:soc_dovdd18_ir ) out lo gpio 508 ( aon:soc_dvdd12_ir ) out lo gpio 509 ( aon:soc_avdd25_ir ) out lo gpio 510 ( aon:soc_cam2_dovdd18) out lo gpio 511 ( aon:soc_cam2_avdd25_) out lo ``` > ## UART ### 系统串口 LicheePi 4A 的系统串口是 UART0,在侧边插针中有引出。 你可以使用 USB 转串口模块连接该串口，即 `U0 RX` 和 `U0 TX`，注意交叉连接，以及 GND 连接。 ![ttl_link](./assets/peripheral/ttl_link.png) 连接完成后，即可使用串口工具进行通信，Windows 下推荐 `XShell`，`mobaterm`，Linux下推荐 `minicom` 设置串口波特率为 `115200`，即可在串口终端下登录并进行指令操作： > 注：刚连接后可以敲几个回车查看是否有反应，如果没有反应则检查接线或者串口配置 ![ttl_login](./assets/peripheral/ttl_login.png) ### 一般串口 LicheePi 4A的侧边插针中还引出了 UART1/2/3, 同样可以操作。 默认镜像中仅使能了 UART1, 其它串口可能需要重新配置设备树操作。 > 注意：SOC串口电平为1.8V，刚好处于3.3V的高电平阈值附近，可能某些串口模块无法正确输入输出，建议使用我们提供配套串口模块，或者微调其他串口模块的3.3V电压到2.8V #### 查看串口设备 ```bash ls /dev/ttyS* ``` #### 查看串口的波特率等信息 ```bash stty F /dev/ttyS1 a ``` #### 设置串口波特率、数据模式 ```bash stty F /dev/ttyS1 ispeed 115200 ospeed 115200 cs8 ``` #### 查看串口数据 ```bash cat /dev/ttyS1 ``` #### 发送串口数据 ```bash echo \"12345\" > /dev/ttyS1 ``` #### 其它方法 也可以使用`minicom`，或者pyserial库进行串口操作，请用户自行查找相关资料使用。 ## I2C LicheePi 4A 上有多个 I2C 设备（I2C0/1/2/3），其中 0/1/3 用于连接 I2C IO 扩展芯片，I2C2 预留在对外插针上。 这里我们使用 i2c tools 来进行 i2c 验证操作，镜像默认预装了 i2c tools: ```bash sipeed@lpi4a:/usr$ ls /sbin/i2c* /sbin/i2c stub from dump /sbin/i2cdetect /sbin/i2cdump /sbin/i2cget /sbin/i2cset /sbin/i2ctransfer ``` 列出所有I2C总线： ```bash sipeed@lpi4a:~$ /sbin/i2cdetect l i2c 0 unknown Synopsys DesignWare I2C adapter N/A i2c 1 unknown Synopsys DesignWare I2C adapter N/A i2c 2 unknown Synopsys DesignWare I2C adapter N/A i2c 3 unknown Synopsys DesignWare I2C adapter N/A i2c 4 unknown Synopsys DesignWare I2C adapter N/A i2c 5 unknown Synopsys DesignWare I2C adapter N/A i2c 6 unknown Synopsys DesignWare I2C adapter N/A i2c 7 unknown DesignWare HDMI N/A ``` 检测 I2C 总线上的设备，可见 PCA9557PW 的 I2C 地址为 0x18，与原理图相符： ```bash sipeed@lpi4a:~$ sudo /sbin/i2cdetect r y 0 0 1 2 3 4 5 6 7 8 9 a b c d e f 00: 10: UU 20: 30: 40: 50: 60: 70: ``` ![i2c_io](./assets/peripheral/i2c_io.png) 此外还可以使用 `i2cdump` 来 dump 指定 i2c 地址的所有寄存器，用 `i2cget` 来读出指定 i2c 地址的指定寄存器值，用 `i2cset` 来写入指定 i2c 地址的指定寄存器值。 不过由于 IO 扩展芯片已经被内核使用，所以无法直接使用这些命令验证。用户可以自行在 I2C2 上外接外设来验证。 ## SPI LicheePi4A上预留了两路SPI，一路是背面空贴的SPI Flash焊盘，一路是插针上的SPI。 ```bash sipeed@lpi4a:~$ ls /dev/spidev2.0 /dev/spidev2.0 ``` TODO ## USB TODO ### USB SSD ### USB 网卡 ### USB 摄像头 ### USB 声卡 ## ETH LicheePi4A 具有双千兆网口，其中 Eth0 还具备 PoE 功能。 TODO ### PoE TODO ## Audio LicheePi 4A 上有两个模拟硅麦，使用 ES7210 CODEC，以及有一路板载的扬声器，和立体声耳机，使用 ES8156 CODEC。 > 注：板载扬声器与立体声耳机使用了互斥设计，插入耳机后，音频输出自动切换到耳机，板载扬声器失能。 使用 aplay 和 arecord 可以进行简易录放测试， 注意板载扬声器是右声道。 ```bash #!/bin/bash echo \"Play Test Audio\" aplay /usr/share/sounds/alsa/Side_Right.wav # Record Audio echo \"Start record auido, auto replay after 3 seconds\" arecord Dhw:0,1 d 3 r 48000 f S16_LE t wav test.wav & > /dev/null & sleep 4 # Play Audio aplay test.wav echo \"Start Play\" ``` 你还可以使用alsa相关工具，如`alsamixer`，进行音量调整等操作。 ## HDMI > 注：早期镜像的HDMI音频不生效，请升级到较新版本使能HDMI音频功能。 ## MIPI CSI LicheePi 4A 具有 CAM0/CAM1/CAM2 三个摄像头接口， CAM0 最大 4lane，CAM1/2 为 2lane，默认使用 CSI0 接口，接 OV5693 摄像头。 TODO ## MIPI DSI LicheePi 4A 具有 MIPI DSI0 接口，支持 4K 视频输出，可以选配 10.1 寸 1280x800 或者 1920x1200 的屏幕。 TODO ## GPU `sudo watch cat /sys/kernel/debug/pvr/status` TODO ## NPU TODO ## 其它 欢迎投稿～ 投稿接受后可得￥5～150（$1~20）优惠券！"},"/hardware/zh/lichee/th1520/lpi4a/10_test_report.html":{"title":"板卡性能测试","content":" title: 板卡性能测试 keywords: Linux, Lichee, TH1520, SBC, RISCV, report update: date: 2023 05 08 version: v1.0 author: wonder content: Release docs ## 功耗测试 ### 静态功耗 场景(静态) 电压 电流 功耗 备注 待机 5.11V 0.46A 2.35W 开启风扇，后续所有测试中风扇均不关闭 单网口连接网线 5.06V 0.52A 2.63W 双网口连接网线 5.08V 0.53A 2.69W 连接 HDMI 显示器 5.04V 0.53A 2.67W ### 动态功耗 场景(动态) 电压 电流 功耗 备注 待机 5.04V 0.71A 3.58W 连接显示器、键盘、鼠标 使用一个网口 STRESS NG 压测<br>( CPU 矩阵运算) 4.95V 1.22A 6.04W CPU 频率上限 1.845GHz，电压 1V 浏览器播放视频 4.96V 1.06A 5.26W 使用 GPU、无硬件解码, firefox 浏览器 ## eMMC ```bash #4k写入 dd if /dev/zero of test bs 4k count 100000 oflag direct #4k读取 dd if test of /dev/null bs 4k count 100000 iflag direct #删除测试文件 rm test #连续写入(4MB) dd if /dev/zero of test bs 4096k count 100 oflag direct #连续读取(4MB) dd if test of /dev/null bs 4096k count 100 iflag direct #删除测试文件 rm test #连续写入(64MB) dd if /dev/zero of test bs 65536k count 10 oflag direct #连续读取(64MB) dd if test of /dev/null bs 65536k count 10 iflag direct #删除测试文件 rm test ``` **8GB eMMC** Test Item Result 4KB W 22.4 MB/s 4KB R 22.4 MB/s 4MB W 53.9 MB/s 4MB R 296 MB/s 64MB W 229 MB/s 64MB R 298 MB/s **32/128GB eMMC** Test Item Result 4KB W 24.0 MB/s 4KB R 40.3 MB/s 4MB W 209 MB/s 4MB R 296 MB/s 64MB W 229 MB/s 64MB R 298 MB/s ## LPDDR4X ![lpddr4x](./assets/test_report/lpddr4x.png) ## GbE `iperf3 c 192.168.3.18 t 15` ![iperf](./assets/test_report/iperf.png) ## 温度 散热器: 风扇+铝散热片(25*25*5) 硅脂垫: Laird 500 待机状态： ![temp_idle](./assets/test_report/temp_idle.png) 压测结束： ![temp_press](./assets/test_report/temp_press.png) ## 其它 欢迎投稿～ 投稿接受后可得￥5～150（$1~20）优惠券！"},"/hardware/zh/lichee/th1520/lpi4a/7_develop_other.html":{"title":"系统开发","content":" title: 系统开发 keywords: Linux, Lichee, TH1520, SBC, RISCV, Kernel, SDK, Develop update: date: 2023 05 12 version: v1.0 author: wonder content: Release docs "},"/hardware/zh/lichee/th1520/lpi4a/7_develop.html":{"title":"系统开发","content":" title: 系统开发 keywords: Linux, Lichee, TH1520, SBC, RISCV, Kernel, SDK, Develop update: date: 2023 05 08 version: v1.0 author: wonder content: Release docs ## Yocto Linux TH1520 的官方开发环境是平头哥的基于 yocto 的开发环境，大家可以在这里获取开发环境： https://gitee.com/thead yocto/ 本节简单介绍如何搭建 Linux Yocto 环境并使用 Yocto 构建可在开发板上运行的完整镜像。 ### 搭建Yocto编译环境 Linux SDK 使用 Yocto 构建镜像。Yocto 编译环境使用 Ubuntu18.04，推荐在 Linux 上使用 Docker 部署,也可直接在 Ubuntu18.04 下搭建环境（见[T Head曳影1520Yocto用户指南.pdf](https://gitee.com/thead yocto/documents/blob/master/zh/user_guide/T Head%E6%9B%B3%E5%BD%B11520Yocto%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf)2.2）。 这里仅介绍 Linux 上使用 Docker 部署的方式。**建议编译机器预留200G磁盘空间，内存为4G以上，编译时间因网络情况差异很大，在使用代理的情况下编译典型linux系统配置（最小系统加上必要的相关基础组件）时间约为1.5h（CPU为i5 11400，时间供参考）**。 使用官方脚本安装 docker \t```bash \tcurl fsSL https://get.docker.com bash s docker mirror Aliyun \t``` 下载 dockerfile 并修改用户名和 ID \t点击下载 [linux dev master.7z](https://gitee.com/thead yocto/documents/blob/master/linux dev master.7z) 并解压后，进入到 `linux dev master` 目录，打开 `Dockerfile`，找到如下语句 \t```bash \tENV DOCKER_USER2 \"your the same user name asyour host\"` \tENV USER2_ID \"your user id\" \t``` \t将 \"your the same user name asyour host\" 改为用户 host os 的用户名，\"your user id\" 的值对应该用户的密码。 构建 docker 镜像环境 \t```bash \tdocker build t linux dev base:base . \t``` \t这里下载的软件包的时候可能会有些报错，可以在 Dockerfile 中进行相应的修改，等到创建好 docker 后登录到 docker 中再进行下载。这个 docker 镜像可以编译 thead 发布的 buildroot、yocto 等 Linux SDK。默认密码为 `123`。 启动 docker \t```bash \tdocker run u thead dt name linux dev {your_name} v {your_lock_home}:{your_home} linux dev base:base /bin/bash \t``` \t{your_name} 为容器名称，起名时不要重名。 \t通过 v 选项可以挂载宿主机的目录，起到类似共享文件的作用，{your_lock_home} 为宿主机的本地路径，{your_home} 为挂载在 docker 里的路径。 查看启动的 docker 容器 \t```bash \tdocker ps grep linux dev base \t``` 就能够看到刚刚启动的 docker 容器。 登录 docker \t```bash \tdocker exec it linux dev {your_name} /bin/bash \t``` 下载开源软件包（仅在第一次获取 SDK 时才需要下载） \t构建固件时会从网上下载开源软件包，若网络较差，下载时间会比较长。为了加速这一过程，可以先到 gitee 下载离线开源软件包（假设下载到用户目录） \t```bash \tcd ~ \tgit clone https://gitee.com/thead yocto/yocto downloads.git \t``` 下载 Yocto 构建包 \t```bash \tgit clone https://gitee.com/thead yocto/xuantie yocto.git b Linux_SDK_V1.1.2 \t``` 加载目标设备的配置文件和环境变量（编译前记得检查是否加载） \t```bash \tcd xuantie yocto \tsource openembedded core/oe init build env thead build/light fm \t``` 将前面下载的开源软件包通过共享 downloads 目录的方式软链接到 SDK 目录 \t```bash \tln s ~/yocto downloads ../downloads \t``` 至此，搭建环境已经完成。 ### Machine/Target支持列表 在上面的加载环境变量步骤中，设置完成后可看到以下信息 ```bash ### Shell environment set up for builds. ### You can now run 'bitbake <target>' Common targets are: thead image linux thead image multimedia thead image gui machines: light beagle light b product light a val light lpi4a ``` 相关说明如下 target（SDK 支持的镜像列表）： 命名描述 thead image linux典型linux系统配置，最小系统加上必要的相关基础组件 thead image multimedia典型linux系统+视频视觉配置，加上视频子系统的组件（Gstreamer等） thead image gui加上GUI相关组件的完整配置版本，包括Gnome桌面、weston、QT等应用组件等等 machines（SDK 支持的板级配置）： 命名描述 light a valTH1520 A EVB板 light b productTH1520 B EVB板 light beaglebeagleV Ahead开发板 light lpi4aLichee Pi 4A开发板 ### 构建镜像 构建命令格式如下： ```bash MACHINE {machine} bitbake {target} ``` 将其中的 {machine} 和 {target} 部分替换为上面两个表格中对应的命名即可。例如，编译一个在 LicheePi 4A 开发板上运行的典型 Linux 镜像的命令如下： ```bash MACHINE light lpi4a bitbake thead image linux ``` #### 构建镜像时可能会出现的问题 由于网络原因，这一步可能仍会出现下载失败或下载很慢的情况，有条件的话推荐使用代理。 报错信息 \t```bash \tPlease use a locale setting which supports utf 8. \tPython can't change the filesystem locale after loading so we need a utf 8 when python starts or things won't work. \t``` \t首先运行如下命令 \t```bash \tsudo apt get install locales \tsudo dpkg reconfigure locales \t``` \t然后在打印出来的列表中找到`en_US.UTF8`这一项（大概在第158项）,输入这一项对应的序号后回车，接下来也选择这一项后回车。 \t完成上述设置步骤后接着运行如下命令（也可考虑将下面的命令加入到docker的`.bashrc`中） \t```bash \tsudo locale gen en_US.UTF 8 \tsudo update locale LC_ALL en_US.UTF 8 LANG en_US.UTF 8 \texport LANG en_US.UTF 8 \t``` \t完成上述步骤后再编译就不会出现原来的报错。 报错信息 \t```bash \tplease install them in order to proceed: lz4c pzstd zstd \t``` \t安装对应的依赖即可 \t```bash \tsudo apt update && sudo apt install y zstd liblz4 tool \t``` ### 镜像打包 在 [light_deploy_images](https://gitee.com/thead yocto/light_deploy_images/tree/master/tarball) 仓库中，包含了一些预发布镜像。对于刚刚编译好的镜像，可以利用这个仓库中的 `sdk.sh` 脚本来进行打包。 首先切换到已经编译好的镜像中的 `light fm` 目录下，将该仓库中的 `sdk.sh` 移动到这里即可。直接运行该脚本 `./sdk.sh` 即可，打包后会生成相应的镜像，相应文件的位置以及镜像目录的结构参考 [light_deploy_images](https://gitee.com/thead yocto/light_deploy_images/tree/master/tarball) 仓库。 最后，可以将 docker 编译好的镜像及相关文件复制到先前通过 v 选项挂载的共享文件夹中，宿主机即可使用该文件进行烧录。 到这里，我们已经完成了编译和打包，得到了一个可以烧录到开发板中运行的镜像。 ### 单独编译 如何单独编译thead官方发布的组件 OpenSBI Uboot \t```bash \tgit clone https://gitee.com/thead yocto/u boot \tcd u boot \tmake CROSS_COMPILE riscv64 unknown linux gnu ARCH riscv light_lpi4a_defconfig \tmake CROSS_COMPILE riscv64 unknown linux gnu ARCH riscv \t``` \t生成的固件路径为，u boot with spl.bin，可使用fastboot进行烧录 Kernel ### 设备树解析 TODO ### 其他参考资料 **light_deploy_images 仓库：** 包含已经构建好可烧录的 Linux Image，打包镜像脚本以及其他相关工具，详见仓库。 仓库地址：[https://gitee.com/thead yocto/light_deploy_images](https://gitee.com/thead yocto/light_deploy_images) **documents 仓库：** 包含所有发布的 SDK 相关文档 仓库地址：[https://gitee.com/thead yocto/documents](https://gitee.com/thead yocto/documents) ## Mainline 如何使用主线正在开发的版本 ### OpenSBI 下载，编译 ```bash \tgit clone https://github.com/riscv software src/opensbi \tcd opensbi \tmake CROSS_COMPILE riscv64 unknown linux gnu PLATFORM generic \t``` \t生成的固件路径为，build/platform/generic/firmware/fw_dynamic.bin，拷贝到/boot/ ### U boot 下载，编译 \t```bash \tgit clone b th1520 https://github.com/dlan17/u boot.git \tcd u boot \tmake CROSS_COMPILE riscv64 unknown linux gnu ARCH riscv light_lpi4a_defconfig \tmake CROSS_COMPILE riscv64 unknown linux gnu ARCH riscv \t``` \t生成的固件路径为，u boot dtb.bin，拷贝到/boot/ 使用板载的 U boot 启动主线开发中的 U boot \t开发板内预烧录的 U boot 已经包含 Ethernet 功能，可以通过 tftp 协议获取新 U boot 镜像。 \t在开发机启动一 tftp 实例，以 Alpine 为例，安装包 `tftp hpa` 并启用相应服务 \t```bash \tapk add tftp hpa \trc update add in.tftp \trc service in.tftp start \t``` \ttftp 默认使用 `/var/tftpboot` 作为文件根目录，将编译好的 U boot `u boot dtb.bin` 拷贝到 `/var/tftpboot`。 \t连接好 LicheePi 4A 开发版的串口和网线，上电启动并在串口显示 \t``` \tPress any key to stop autoboot \t``` \t时按任意键停止自动启动进入 U boot Shell。 \t输入 `dhcp` 使用 DHCP 协议配置网卡。开发中的主线 U boot 加载地址为 0x1c00000，在 U boot 输入 \t``` \ttftp 0x1c00000 TFTP_SERVER_IP:u boot dtb.bin \tgo 0x1c00000 \t``` \t将 U boot 载入 0x1c00000 地址并跳转启动之。 ### Linux ## OpenWRT TODO ## Andriod TODO ## OpenHarmony TODO ## Others 欢迎投稿～ 投稿接受后可得￥5～150（$1~20）优惠券！"},"/hardware/zh/lichee/th1520/lm4a.html":{"title":"LicheePi Module 4A","content":" title: LicheePi Module 4A keywords: LicheePi, Sodimm, TH1520, RISCV, SBC update: date: 2023 03 31 version: v0.1 author: wonder content: 初次编写文档 ## 简介 LicheePi Module 4A 是一款采用 [平头哥半导体](https://www.t head.cn/) 的 [曳影1520](https://www.t head.cn/product/yeying) 作为主控的核心模组，主控核心包含四核玄铁 C910 CPU, 搭载 4TOPS@int8 AI 算力的 NPU，拥有 4K 视频处理能力，最大支持 16GB LPDDR4X 内存和 128G eMMC 存储，支持双千兆以太网和最大 4K 分辨率视频输出等特性，核心还额外包含一颗 C906 处理器用于音频处理。得益于 SODIMM 样式的封装， LicheePi Module 4A 可以用于多种场合，适用于多款底板。 ## 基本参数 <table> <thead> <tr> <th colspan 2>主控参数</th> </tr> </thead> <tbody> <tr> <td>主控芯片</td> <td>曳影 1520</td> </tr> <tr> <td>CPU处理器</td> <td>RISC V 64GCV C910*4@2GHz <br>· 每核支持 64KB I cache 和 64KB D Cache <br>· 四核共享 1MB L2 Cache <br>· 支持 TEE 和 REE，TEE/REE 支持核数启动时可配置<br>· 支持自定义且接口兼容 RISC V 的多核调试框架<br>· 独立电源域，支持 DVFS</td> </tr> <tr> <td>图形处理器</td> <td>· OpenCL 1.1/1.2/2.0<br>· OpenGL ES 3.0/3.1/3.2<br>· Vulkan 1.1/1.2<br>· Android NN HAL</td> </tr> <tr> <td>NPU处理器</td> <td>支持 4TOPS@INT8 通用 NNA 算力，主频 1GHz <br>· 支持 TensorFlow、ONNX、Caffe <br>· 支持 CNN、RNN、DNN 等</td> </tr> <tr> <td>视频解码器</td> <td>实时解码器，支持 H.265/H.264/VP9/8/7/6/AVS/AVS+/AVS2.0/VC1/MPEG4 <br>· 支持 H.264 BP/MP/HP@level 5.1 解码，最大 4K 分辨率<br>· 支持 H.265/HEVC Main Profile@level 5.1 解码，最大 4K 分辨率<br>· 支持 VP9 Profile 2 解码，最大 4K 分辨率<br>· 支持 AVS2.0 解码，最大 4K 分辨率<br>· 支持 VP6/7/8/AVS/AVS+/VC1/MPEG4 解码，最大 1920x1080 分辨率<br>· 解码性能最大 4K@75fps</td> </tr> <tr> <td>视频编码器</td> <td>· 支持 H.264 BP/MP/HP@level4.2 编码，最大 4K 分辨率<br>· 支持 H.265/HEVC Main Profile 编码，最大 4K 分辨率<br>· 仅支持 I 帧和 P 帧<br>· 编码性能最大 4K@40fps</td> </tr> <tr> <th colspan 2>硬件特性</th> </tr> <tr> <td>RAM</td> <td>· 8GB 64bits LPDDR4<br>· 16GB 64bits LPDDR4<br></td> </tr> <tr> <td>ROM</td> <td>eMMC: <br>· 0G<br>· 8G<br>· 32G<br>· 128G</td> </tr> <tr> <td>以太网</td> <td> 千兆 PHY x 2</td> </tr> </tbody> </table> ## 相关链接 [Github](https://github.com/sipeed/LicheePi4A) [Sipeed 下载站(暂时空白)]()"},"/hardware/zh/lichee/Nano/Nano.html":{"title":"Lichee Nano","content":"# Lichee Nano ## 概述 Lichee Nano是基于全志科技的F1C100s(ARM 926EJS内核)高性能soC芯片设计的迷你开发板。开发板设计小巧精致，将芯片的所有资源都引出，板载USB、Flash、TF卡、4OP LCD接口等，并把所有IO资源引出，方便开发者拓展使用，非常适合初学者学习linux或者商用于产品开发。 > 默认用户名称:root 用户密码:licheepi <img src \"./../assets/Nano/Nano_2.png\" width 400> <img src \"./../assets/Nano/Nano_3.png\" width 400> ## 参数 ### F1C100s参数 Lichee Nano开发板板载的F1C100s芯片功能很强大，芯片内置32MBDDR，拥有SDIO、SPI、UART、Speaker、Mic等接口，支持外挂 8~32MB SPI Nor Flash;在视频处理方面表现出现，支持720P视频输出，支持H.264、MJPEG等高清格式的解码。 ![](./../assets/Nano/F1C100s.png) 项目 参数 CPU •ARM9 CPU architecture<br>•16KByte D Cache<br>•32KByte I Cache Memory •SIP 32MB DDR1<br>•SD2.0,eMMC 4.41 Video •H.264 1280x720@30fps decoding<br>•MPEG1/2/4 1280x720@30fps decoding<br>•MJPEG 1280x720@30fps encoding<br>•JPEG encode size up to 8192x8192 Camera •8 bit CMOS sensor interface<br>•CCIR656 protocol for NTSC and PAL Audio •Integrated analog audio codec with two DAC channels and one ADC channel,maximum 192kHz DAC sample rate and 48kHz ADC sample rate<br>•One I2S/PCM interface Display •LCD RGB interface up to 1280x720@60fps<br>•TV CVBS output, support NTSC/PAL, with auto plug detecting Connectivity •USB OTG, SDIO,IR, 3 x TWI, 2 x SPI, 3 x UART ### 开发板参数 项目 参数 CPU 全志 F1C100s， ARM 926EJS , 主频 408MHz， 可超频至 600Mhz 内存及存储 集成 32MB DDR<br>板载 16MB NOR FLASH， 可从 FLASH 启动<br>板载 TF 卡座，可从 TF 启动 显示 通用 40P RGB LCD FPC 0.5mm 座子<br>可直接使用常见的 40P 4.3/5/7 寸屏幕（板载背光驱动）<br>支持常见的 272x480, 480x800, 1024x600 等分辨率<br>板载电阻式触摸屏芯片 视频处理能力 H.264 1280x720@30FPS 解码<br>MPEG1/2/4 1280x720@30FPS 解码<br>MJPEG 1280x720@30 FPS 解码<br>JPEG encode size up to 8192x8192 通信接口 SDIO，可搭配配套 SDIO WiFi+BT 模块<br>SPI x2<br>TWI x3<br>UART x3<br>OTG USB x1<br>TV out 其它接口 PWM x2<br>LRADC x1<br>Speakerx2 + Mic x1 ![](./../assets/Nano/Nano_pin.png) ### 软件参数 开发环境 参数 Linux 支持3.10 BSP Linux<br>支持4.19 主线 Linux 裸机 Xboot 裸机 RT Thread ## 使用教程 [Lichee Nano](./../../../../soft/Lichee/zh/Nano Doc Backup/index.html) ## 产品技术支持 Lichee Nano 开发板可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务 <support@sipeed.com>。"},"/hardware/zh/lichee/ZeroPlus/ZeroPlus.html":{"title":"Lichee ZeroPlus","content":"# Lichee ZeroPlus ## 概述 Lichee Zero Plus是基于全志科技的S3 (ARM Cortex A7内核)的高性能CPU芯片设计的高集成度核心板。 使用双NGFF金手指设计，引出134pin引脚，方便开发者拓展使用。S3是V3s的升级版，1.2GHz主频，内置128MB ddr3内存，引脚相对V3s全很多。 支持MIPI摄像头，普通并口摄像头，RGB屏幕，内置ePHY. <img src \"./../assets/Zero Plus/Plus_1.jpg\" width 400> ## 参数 ### 芯片 S3芯片架构 ![](./../assets/Zero Plus/Plus_2.png) 项目 参数 CPU • ARM® Cortex™ A7 @1.2GHz GPU • Supports 1080p@60fps or 2 channel 1080p@30fps H.264 video encoding, supports 8M JPEG encoding <br>• Supports H.264 1080p@60fps decoding, MJPEG 1080@30fps decoding ISP • Integrated ISP up to 8M pixels<br>• Supports two channel outputs for display and encoding respectively<br>• Supports various input and output formats<br>• Supports AE/AF/AWB<br>• Supports saturation adjustment/ noise reduction/ defect pixel correction/distortion correction Video Input/Output • Supports 8/10/12 bit parallel CSI and 4 lane MIPI CSI2<br>• Supports BT1120 input<br>• Supports up to 8M CMOS sensor<br>• Supports RGB/i80/LVDS LCD up to 1024x768 resolution<br>• Supports Allwinner's next gen SmartColor display technology for better visual effects for images & videos Memory • SIP 16 bit DDR3, up to 1333Mbp Audio Codec • Integrated 92dB audio codec<br>• Supports two ADC channels and two DAC channels<br>• Supports 3 MIC in, a stereo Line in, a headphone output and a stereo line out output Security Engine • Supports AES/DES Connectivity • 3 x SD card controllers<br>• LRADC/SPI/TWI/UART/PWM<br>• USB, EMAC+PHY ### 核心板 项目 参数 CPU ARM Cortex A7 处理器(1.2Ghz)， VFPv4 浮点处理器 内存 芯片内置 128Mbyte DDR3 内存 (时钟频率最高 672MHz) 存储 可选 SPI Nor Flash(8/16/32MB)，SD Nand(128/512MB)，eMMC(4/8GB)<br>Micro SD 卡 电源 5V 电源输入， 3 路 DCDC 稳压输出 (1.2,1.5,3.3) 复位 板载复位芯片 晶振 板载 24M 主晶振， 32.768KHz RTC 晶振 接口 NGFF M.2 B KEY x 2 共引出 67x2 134pin<br>板载 micro usb 接口和系统串口，可供下载固件及调试 系统支持 支持最新 Linux 5.2 mainline kernel, Linux 3.4 bsp kernel<br>支持 debian 发行版 ## 使用教程 [Lichee Zero](/soft/Lichee/zh/Zero Doc/Start/intro_cn.md) ## 产品技术支持 Lichee ZeroPlus 开发板可以在多种场景实现客户不同方面的需要，在 AIoT 上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务 <support@sipeed.com>。"},"/hardware/zh/maixII/M2A/Usages.html":{"title":"基本使用","content":"# 基本使用 进行完前面的 [配置系统](./config_system.html) 后，我们已经成功登录到板子然后可以使用命令行来操作板子了。 ## 扩容系统 使用不含有 MaxiPy3 的系统镜像启动后会会自动扩容，可以跳过 `扩容系统` 这一步。 使用内置 MaxiPy3 的镜像系统不会自动扩充系统容量到最大值，因此需要执行一下 `/usr/lib/armbian/armbian resize filesystem start` 命令来扩容一下系统大小，会花费一下时间；执行时不要强行退出，执行完毕后会自动退回到终端 ## 连接网络 这里我们使用 `nmtui` 命令来配置 wifi ![202108051626](./assets/202108051626.gif) <details> <summary><font color \"#4F84FF\">点开查看图文版操作</font></summary> <p>命令行中输入 nmtui 来打开可视化 wifi 连接界面</p> <img src \"./assets/wifi/nmtui.png\" alt \"nmtui\"> <img src \"./assets/wifi/active_wifi.png\" alt \"active_wifi\"> <p>如上图所示我们选择 Activate a connection 来设置连接</p> <p>先择目标 wifi </p> <img src \"./assets/wifi/choose_wifi.png\" alt \"choose_wifi\"> <img src \"./assets/wifi/input_password_1.png\" alt \"input_password_1\"> <p>输入正确的密码</p> <img src \"./assets/wifi/input_password_2.png\" alt \"input_password_2\"> <p>会显示 connecting</p> <img src \"./assets/wifi/connect_wifi.png\" alt \"connect_wifi\"> <p>成功后会发现右边的 active 变成了 Deactive，到此基本说明已经连上了 wifi</p> <p>连接失败的话重新输入正确的 wifi 密码再尝试连接</p> <img src \"./assets/wifi/succeed_connecting.png\" alt \"succeed_connecting\"> <p>然后我们重新退出回命令行终端</p> <img src \"./assets/wifi/quit_connecting.png\" alt \"quit_connecting\"> <img src \"./assets/wifi/quit_nmtui.png\" alt \"quit_nmtui\"> <img src \"./assets/wifi/back_terminal.png\" alt \"back_terminal\"> <p>可以使用 ifconfig 命令来查看板子的 IP</p> <img src \"./assets/wifi/ifconfig.png\" alt \"ifconfig\"> <img src \"./assets/wifi/see_ip.png\" alt \"see_ip\"> <p>到这里看到了 IP 就说明已经连接上了(上图中的红框位置)</p> </details> ## 新建用户 一般来说不建议使用 root 来登录 linux 系统，因为这样很容易把系统玩崩了。 我们来新建一个用户来进行日常使用。这里我们使用 `adduser` 这个命令来添加用户。 添加用户名为 `xxx` 的用户 ```bash adduser xxx ``` 一些 log 显示完后会让我们设置密码： ```bash New password: Retype new password: ``` 成功设置密码后所显示的 log 会包括下面的内容。 ```bash passwd: password updated successfully ``` 接下来所有的都使用默认的即可（全部都 回车 确定就行） ```bash Enter the new value, or press ENTER for the default Full Name []: Room Number []: Work Phone []: Home Phone []: Other []: Is the information correct? [Y/n] ``` 到这里我们就已经成功创建名称为 xxx 的用户了。 使用命令 login 来登录刚刚新建的用户: ```bash login xxx ``` 想要退出登录的话使用命令 `logout` 就可以 ```bash logout ``` ### 授予管理员权限 有时候新建的用户需要使用到管理员权限来执行一些操作，下面内容就是授予用户管理员权限。 这里我们编辑 `/etc` 目录下的 `sudoers` 文件就可以修改相关权限。 ```bash sudo nano /etc/sudoers ``` 在文件里找到下面的内容 ```vim # User privilege specification root ALL (ALL:ALL) ALL ``` 在里面添加上 `xxx ALL (ALL:ALL) ALL`（其中xxx是你之前添加的用户名） ```vim # User privilege specification root ALL (ALL:ALL) ALL xxx ALL (ALL:ALL) ALL ``` 接着保存后退出即可。 ## 安装应用 这里我们使用安装 `armbian config` 为例。直接执行下面的命令即可 ```bash sudo apt install armbian config y ``` 上面的命令的意思是使用 root 权限来运行 apt 应用的 install 命令来安装 armbian config 且后面所有需要选择的内容均为 yes 选项 ## 设置时区 命令行中输入 `armbian config`，选中 Personal，再选择 Timezone > Asia >Shanghai 设置上海时间（Debian中没有北京时间），按住 TAB 键切换到 ok 后，保存即可。 在 `armbian config` 设置界面中一直按键盘上的 `Esc` 键也能有退出的效果。 ![202108062005](./assets/202108062005.gif) ## 设置中文显示 命令行中输入`armbian config`，选中Personal > Locales，下滑到最下面（可以试着使用键盘上的 `PageDown` 按键加快下滑），使用键盘空格键来选中 zh.GBK 和 zh.UTF 8 ，回车确认后再选择 zh_CN.UTF8 为系统默认语言，然后多次按下 `Esc` 键来退回到命令行终端界面。<! 执行命令 `sudo apt install fonts wqy zenhei` 来下载中文字体， > 然后使用 `reboot` 命令来重启后系统后就会发现命令行终端有中文显示了。 ![202108062054](./assets/202108062054.gif) ## 配置蓝牙 打开 `armbian config`，选中 Network，选择 BTinstall 安装蓝牙支持包。 ![202108071034](./assets/202108071034.gif) 然后就可以使用 Bluetoothctl 配置蓝牙。 <html> <details> <summary><font color \"#4F84FF\">点开查看常用命令</font></summary> <pre class \"line numbers language bash\"> devices 列出活动的蓝牙设备 paired devices 列出已配对蓝牙设备 pairable &lt;on/off&gt; 是否允许配对 discoverable &lt;on/off&gt; 是否允许被发现 discoverable timeout [value]设置暴露时间 pair [dev] 配对设备 trust [dev] 信任设备 untrust [dev] 取消设备信任 remove &lt;dev&gt; 移除设备 connect &lt;dev&gt; 连接设备 disconnect [dev] 断开设备连接 quit 退出 help 查看帮助 </pre> </details> </html> ### 连接蓝牙设备 使用 `bluetoothctl` 连接蓝牙设备。 ```bash scan on #扫描设备 scan off #停止扫描 trust XX:XX:XX:XX #信任设备 pair XX:XX:XX:XX #配对设备 connect XX:XX:XX:XX #连接设备 ``` ![202108071610](./assets/202108071610.gif) ### 设置蓝牙音频输入/输出 启用蓝牙音频前，需要先安装 `pulseaudio` 和蓝牙组件 ```bash sudo apt install pulseaudio sudo apt install pulseaudio module bluetooth ``` 然后使用 pactl 命令查看是否有蓝牙输出设备 ```bash pactl list short sinks ``` 切换音频输出到蓝牙，下面的 `<dev>` 在此处应该为 `2` ```bash pactl set default sink <dev> ``` log 如下： ```bash maixsense:~:# apt install pulseaudio maixsense:~:# apt install pulseaudio module bluetooth maixsense:~:# pactl list short sinks 0\talsa_output.platform 7032000.codec.stereo fallback\tmodule alsa card.c\ts16le 2ch 44100Hz\tSUSPENDED 2\tbluez_sink.00_26_04_00_73_B1.a2dp_sink\tmodule bluez5 device.c\ts16le 2ch 44100Hz\tSUSPENDED maixsense:~:# pactl set default sink 2 ``` ![202108071726](./assets/202108071726.gif) 然后就可以播放音频到蓝牙设备，或者通过蓝牙连接手机当作蓝牙音箱使用。 ## 配置音量 这里使用 `alsamixer` 这个应用来改变音量 ![202108071440](./assets/202108071440.gif) <html> <details> <summary><font color \"#4F84FF\">点开查看常用命令</font></summary> <pre> Help xxEsc 离开 ▒x xxF1 ? H 帮助 ▒x xxF2 / 系统信息 ▒x xxF3 回放控制 ▒x xxF4 捕获控制 ▒x xxF5 所有控制 ▒x xxTab 切换显示模式 ▒x xxF6 S 选择声卡 ▒x xxL 刷新屏幕 ▒x xxLeft 移动到上一个的控制 ▒x xxRight 移动到下一个的控制 ▒x xxUp/Down 改变音量 ▒x xx+ 改变音量 ▒x xxPage Up/Dn 大幅改变音量 ▒x xxEnd 设置音量为0 ▒x xx0 9 从0到9依次设置音量 ▒x xxQ W E 增加 左/全部/右声道音量 ▒x xxZ X C 减少 左/全部/右声道音量 ▒x xxB 左右声道平衡 ▒x xxM 切换静音 ▒x x< > 切换左/右静音 ▒x xxSpace 切换捕获 ▒x xx; ' 切换左/右捕获 ▒x </pre> </details> </html> 如果需要控制蓝牙设备音量，需要使用 `pactl` 。 因为 `pcatl` 也支持控制声卡，所以建议使用这个应用来控制音量。 ```bash ##查看输入/输出设备索引 pactl list short sources/sinks ##设置输入/输出音量 pactl set source/sink volume index volume pactl set default source/sink ##设置默认输入/输出 ``` 示例，设置蓝牙耳机为输出设备，音量为10%,然后增加20%，最后减少30% ```bash maixsense:~:# pactl list short sinks 0\talsa_output.platform 7032000.codec.stereo fallback\tmodule alsa card.c\ts16le 2ch 44100Hz\tSUSPENDED 2\tbluez_sink.00_26_04_00_73_B1.a2dp_sink\tmodule bluez5 device.c\ts16le 2ch 44100Hz\tRUNNING ##蓝牙设备一般为bluez_sink maixsense:~:# pactl set default sink 2 maixsense:~:# pactl set sink volume 2 10% maixsense:~:# pactl set sink volume 2 +8192 maixsense:~:# pactl set sink volume 2 0x3000 ##可选 百分比，十进制数，十六进制数控制，效果相同，并且可以超过100% ``` ## 媒体播放 媒体播放常用 mplayer 这个应用。 下载 mplayer ```bash sudo apt install mplayer y ``` 安装后我们需要把想要播放的文件传到板子上。 文件可以在[下载站](https://dl.sipeed.com/shareURL/MaixII/MaixII Dock/example)获取到下面的示例文件 这里可以用 [mobaxterm](../M2/tools/mobaxterm.html) 软件来使用无线网络把文件传输到板子上。 然后执行 `sudo mplayer badapple_240_60fps.mp4 vo fbdev2` 来播放视频或者 `sudo mplayer Short.mp3` 播放音频 ```bash mplayer badapple_240_60fps.mp4 vo fbdev2 ``` 想要退出的话使用键盘上的 `Ctrl+C` 组合键来退出。 也在在命令行后面加上`< /dev/null > /dev/null 2>1 &`以便在后台播放 ```bash mplayer badapple_240_60fps.mp4 vo fbdev2 < /dev/null > /dev/null 2>1 & ``` 上面的指令是在后台播放的。想要停止的话可以先使用 `fg` 命令来切换到任务，再使用 `Ctrl+C` 来终止程序 ![202108091128](./assets/202108091128.gif) 如果没播放成功的话，尝试增加设备音量（前文提过alsamixer）或者确认一下文件路径是否正确 ## 编写c代码 一般命令行都是用 vim 来作为编辑器。有兴趣的可以额外学习一下这款强大的编辑器 如果提示没有安装 vim 的话，可以使用命令 `sudo apt install vim y` 来安装 vim。 然后我们使用 vim 来新建一个名为 `helloworld.c` 的源文件 ```bash vim helloworld.c ``` vim 有命令模式（Command mode） ， 输入模式（Insert mode） 和 底线命令模式（Last line mode）。 新建文件后默认的模式为 命令模式，此时我们按下键盘上的 `i` 键可进入输入模式。 将下面的代码正常输入到文件内容中。 ```c #include <stdio.h> int main() { printf(\"Hello, world\\n\"); return 0; } ``` 然后使用键盘上的 esc 键来退出输入模式到命令模式， 然后使用 `:` 来进入底线命令模式，接着输入 `wq` 来保存文件且退出到命令行 然后接可以在命令行中使用 gcc 来编译我们的代码了。 如果没有 gcc 的话使用 apt 命令来安装一下。 有关 gcc 的详细说明请自行搜索。 ```bash gcc hello.c o hello.o ``` 结束编译后直接运行即可 ```bash ./hello.o ``` ![202108091201](./assets/202108091201.gif) ## 编写python代码 详细解释看上面的C代码样例 ```bash vim helloworld.py #新建一个python文件并且用vim打开 i print(\"hello world!\\n\") esc :wq python3 helloworld.py ``` ![202108091339](./assets/202108091339.gif) ## 使用 python 点亮第一个灯 首先安装 GPIO 的 python 支持库 ```bash pip install gpiod ``` 把 led 正极插入 PH5,负极插入 GND 创建 `led.py` 文件 ``` bash vim led.py ``` 将下面代码输入到所创建的文件中 ```python import time import gpiod as gpio PH_BASE (8 1)*32 # \"PH\" gpiochip1 gpio.chip(\"gpiochip1\") led gpiochip1.get_line((PH_BASE + 5)) # \"PH5\" config gpio.line_request() config.request_type gpio.line_request.DIRECTION_OUTPUT led.request(config) while led: led.set_value(0) time.sleep(1) print(\"led on\") led.set_value(1) time.sleep(1) print(\"led off\") ``` 保存退出到命令行终端后执行代码 ```bash python3 led.py ``` 效果如下： ![202108091956](./assets/202108091956.gif) ## 设置开机启动 需要会一些脚本语言。 首先启用开机自启动脚本，这里我们来编辑相关文件就可以修改相关设置。 ```bash vim /lib/systemd/system/rc local.service ``` 在最后面添加 ```bash [Install] WantedBy multi user.target Alias rc.local.service ``` 这样就成功启用了开机自启动脚本 接下来我们只需要把想要开机运行的内容添加到 rc.local 文件就可以了 编辑自启动脚本 ```bash vim /etc/rc.local ``` 在`exit 0`前面添加需要启动的服务 ```bash echo \"hello world!\" ``` 然后重启即可。 例如进行上面的修改后，此脚本会在用户登录前执行，执行示例日志如下 ```bash [ OK ] Finished Permit User Sessions. [ 38.569457] rc.local[1322]: hello world! ``` 要注意的是在开机脚本里面最好不要循环占用串口，这会导致我们无法再通过串口来操作板子。 ## 更多的使用方法 请到[MaixPy3](/soft/maixpy3/zh/readme.md)和[极术社区](https://aijishu.com/a/1060000000221780)中自行查看"},"/hardware/zh/maixII/M2A/Hardware_test.html":{"title":"硬件测试","content":"# 硬件测试 ## 测试屏幕 可以使用`echo \"hello sipeed\" > /dev/tty0` 重定向信息到屏幕上。 <img src \"./assets/image 20210805150728052.png\" alt \"image 20210805150728052\" style \"zoom:50%;\" /> ## 测试摄像头 armbian 内置了 ffmpeg ，可以快速捕捉 sensor 数据并输出到屏幕上 使用如下命令快速捕捉 sensor 并输出到屏幕上 ffmpeg i /dev/video0 vframes 1 s 240*240 pix_fmt rgb565le vf transpose 2,transpose 2 f fbdev /dev/fb0 ![image 20210805165654537](./assets/image 20210805165654537.png) ## 测试网络 使用 `nmtui` 指令可以进入可视化的配网界面， 选择 Activate a connection ， 选择对应的 WIFI名称 ，输入连接密码，确认即可。 ![202108051626](./assets/202108051626.gif) 设置完毕后使用 ifconfig 查看本机操作，然后就可以使用 ssh 等操作了。 ![image 20210805162936212](./assets/image 20210805162936212.png) 也可以使用apt下载各种应用 ```bash sudo apt install neofetch armbian config ``` ![image 20210805165620823](./assets/image 20210805165620823.png) 如果遇到终端显示错位，还需要`sudo apt get install xterm`安装下xterm，然后`resize`即可。 ![202108061015](./assets/202108061015.gif) ## 测试AIPU 获取1000类物体分类模型 下载站链接[zhouyi_test.tar.xz](https://dl.sipeed.com/shareURL/MaixII/MaixII A/example),使用任意方式上传到板子中 ```bash tar Jxvf zhouyi_test.tar.xz #解压压缩包 cd zhouyi_test #打开解压后的文件目录 chmod 777 run.sh #授予执行权限 ./run.sh #执行1000类物体分类 ``` 识别出鼠标 <img src \"./assets/recognize_mouse.jpg\" alt \"识别鼠标\" style \"zoom:65%;\"> <br> 对于linux命令行，使用`Ctrl + C`来退出当前程序。"},"/hardware/zh/maixII/M2A/Usages-copy.html":{"title":"Armbian 配置及使用","content":"# Armbian 配置及使用 ## 配置网络 我们使用 `nmtui` 命令来配置 wifi ![202108051626](./assets/202108051626.gif) ## 新建用户 一般来说不使用root来登录linux系统，因为这样很容易把系统玩崩了。 因此新建一个用户来避免一直使用root账户来进行操作。 ```bash adduser xxx # 添加用户名为 xxx 的用户 # ... # 省略一些 log New password: # 新建用户密码 Retype new password: # 重新输入密码 # ... # 省略一些 log Enter the new value, or press ENTER for the default # 添加信息，或者直接按 ENTER 选择默认信息 # ... # 按五次 enter 选择默认即可 Is the information correct? [Y/n] y # 输入 y 完成创建 ``` 到这里我们就已经成功创建名称为 xxx 的用户了 ### 授予管理员权限 有时候用户需要使用到管理员权限，下面内容就是授予用户管理员权限 ```bash sudo nano /etc/sudoers # 修改 /etc/sudoers 文件。编辑器个人喜好 ``` 在文件里找到下面的内容 ```vim # User privilege specification root ALL (ALL:ALL) ALL ``` 在里面添加上 ```vim # User privilege specification root ALL (ALL:ALL) ALL xxx ALL (ALL:ALL) ALL ``` 接着保存后退出即可。 ## 使用SSH连接 想要使用 ssh 来连接板子的话需要板子里面存在的用户名称和密码。 默认的 root 用户没有密码， 所以想用 root 账户的话需要自己使用passwd命令自己添加密码； 使用串口连接板子后执行 ifconfig 来或许板子的 IP 地址。 接着就可以使用 ssh 来连接板子了。 用户也可以尝试使用 MobaXterm 这个软件来方便电脑与板子传输文件 ## MaixPy3 IDE 连接 只能通过远程连接来用 MaixPy3 IDE 连接 MaixSense ，使用有线连接会连接不上。 每个人的网络环境都存在差异，都可能存在连接不上的情况。 ### 准备 烧录好带有 MaixPy3 的 Armbian 系统 连接网络进行 MaixPy3更新，确保 MaixPy3 的版本大于 0.3.4。 运行 `ifconfig` 获取开发板的 IP 地址 ### 连接 在MaixSense上运行 `python3 c \"import maix.mjpg;maix.mjpg.start()\"` 启动板子上的远程 RPyc 服务 在电脑 IDE 中新建代码区，运行下面的代码来连接开发板 ```python $connect(\"192.168.43.44\") # 此处填入开发板的 IP 地址 import platform print(platform.uname()) ``` 运行输出结果如下： ![MaixPy3 IDE](./assets/MaixPy3 IDE.jpg) ## 设置时区 命令行中输入`armbian config`，选中Personal，再选择Timezone > Asia >Shanghai设置上海时间（Debian中没有北京时间），按住TAB键切换到ok，保存即可。\t\t ![202108062005](./assets/202108062005.gif) ## 设置中文显示 命令行中输入`armbian config`，选中Personal > Locales > 下滑到最下面，空格选中zh.GBK和zh.UTF 8,，然后勾选zh_CN.UTF8设置为系统默认语言，按住TAB键切换到ok，保存，exit退出，下载中文字体，`apt get install fonts wqy zenhei`，重启后系统环境就变成中文的了。 ![202108062054](./assets/202108062054.gif) ## 配置蓝牙 打开`armbian config`，选中Network，选择BTinstall安装蓝牙支持包。 ![202108071034](./assets/202108071034.gif) 可以使用Xftp传输，安装完毕后断电重启即可。 然后就可以使用Bluetoothctl配置蓝牙。 常用命令： ```bash devices \t\t列出活动的蓝牙设备 paired devices \t\t列出已配对蓝牙设备 pairable <on/off> \t\t是否允许配对 discoverable <on/off> 是否允许被发现 discoverable timeout [value]设置暴露时间 pair [dev] 配对设备 trust [dev] 信任设备 untrust [dev] 取消设备信任 remove <dev> 移除设备 connect <dev> 连接设备 disconnect [dev] 断开设备连接 quit 退出 help \t\t\t\t查看帮助 ``` ### 连接蓝牙设备 使用`bluetoothctl`连接蓝牙设备。 ```bash scan on #扫描设备 scan off #停止扫描 trust XX:XX:XX:XX # 信任设备 pair XX:XX:XX:XX #配对设备 connect XX:XX:XX:XX #连接设备 ``` ![202108071610](./assets/202108071610.gif) ### 设置蓝牙音频输入/输出 启用蓝牙音频前，需要先安装`pulseaudio`即及蓝牙组件 ```bash sudo apt install pulseaudio sudo apt install pulseaudio module bluetooth ``` 然后使用pactl查看是否有蓝牙输出设备 ```bash pactl list short sinks ``` 切换音频输出到蓝牙 ```bash pactl set default sink <dev> ``` log如下： ```bash maixsense:~:# apt install pulseaudio maixsense:~:# apt install pulseaudio module bluetooth maixsense:~:# pactl list short sinks 0\talsa_output.platform 7032000.codec.stereo fallback\tmodule alsa card.c\ts16le 2ch 44100Hz\tSUSPENDED 2\tbluez_sink.00_26_04_00_73_B1.a2dp_sink\tmodule bluez5 device.c\ts16le 2ch 44100Hz\tSUSPENDED maixsense:~:# pactl set default sink 2 ``` ![202108071726](./assets/202108071726.gif) 然后就可以播放音频到蓝牙设备，或者通过蓝牙连接手机当作蓝牙音箱使用。 ## 配置音量 `alsamixer` ![202108071440](./assets/202108071440.gif) 常用命令 ``` Help xxEsc 离开 ▒x xxF1 ? H 帮助 ▒x xxF2 / 系统信息 ▒x xxF3 回放控制 ▒x xxF4 捕获控制 ▒x xxF5 所有控制 ▒x xxTab 切换显示模式 ▒x xxF6 S 选择声卡 ▒x xxL 刷新屏幕 ▒x xxLeft 移动到上一个的控制 ▒x xxRight 移动到下一个的控制 ▒x xxUp/Down 改变音量 ▒x xx+ 改变音量 ▒x xxPage Up/Dn 大幅改变音量 ▒x xxEnd 设置音量为0 ▒x xx0 9 从0到9依次设置音量 ▒x xxQ W E 增加 左/全部/右声道音量 ▒x xxZ X C 减少 左/全部/右声道音量 ▒x xxB 左右声道平衡 ▒x xxM 切换静音 ▒x x< > 切换左/右静音 ▒x xxSpace 切换捕获 ▒x xx; ' 切换左/右捕获 ▒x ``` 如果需要控制蓝牙设备音量，需要使用`pactl` ，并且`pcatl`也支持控制声卡，所以推荐使用此app控制音量。 ```bash ##查看输入/输出设备索引 pactl list short sources/sinks ##设置输入/输出音量 pactl set source/sink volume index volume pactl set default source/sink ##设置默认输入/输出 ``` 示例，设置蓝牙耳机为输出设备，音量为10%,然后增加20%，最后减少30% ```bash maixsense:~:# pactl list short sinks 0\talsa_output.platform 7032000.codec.stereo fallback\tmodule alsa card.c\ts16le 2ch 44100Hz\tSUSPENDED 2\tbluez_sink.00_26_04_00_73_B1.a2dp_sink\tmodule bluez5 device.c\ts16le 2ch 44100Hz\tRUNNING ##蓝牙设备一般为bluez_sink maixsense:~:# pactl set default sink 2 maixsense:~:# pactl set sink volume 2 10% maixsense:~:# pactl set sink volume 2 +8192 maixsense:~:# pactl set sink volume 2 0x3000 ##可选 百分比，十进制数，十六进制数控制，效果相同，并且可以超过100% ``` ## 媒体播放 媒体播放常用mplayer 下载mplayer > sudo apt install mplayer 然后执行 `sudo mplayer badapple_240p.mp4 vo fbdev2` 来播放视频 或者`sudo mplayer G.E.M.邓紫棋\\ \\ 光年之外.flac` 播放音频 在后面加上`< /dev/null > /dev/null 2>1 &`以便在后台播放 ```bash mplayer /root/badapple_240p.mp4 vo fbdev2 < /dev/null > /dev/null 2>1 & ``` ![202108091128](./assets/202108091128.gif) ## 编写c代码 ```bash vim helloworld.c #使用 vim 创建一个文件并打开 i #在vim中这个指令的意思是输入，之后就可以敲代码了 ``` 可以将下面的代码输入到刚刚新创建的文件中 ```c #include <stdio.h> int main() { printf(\"Hello, world\\n\"); return 0; } ``` 输完上面的代码后需要按下 esc 键来退出编辑模式 就这再输入 `:wq` 来保存文件且退出vim ```bash gcc hello.c o hello.o #编译C文件 ./hello.o #运行编译出来的C文件 ``` ![202108091201](./assets/202108091201.gif) ## 编写python代码 详细解释看上面的C代码样例 ```bash vim helloworld.py i print(\"hello world!\\n\") esc :wq python3 helloworld.py ``` ![202108091339](./assets/202108091339.gif) ## 使用python点亮第一个灯 安装GPIO的python支持库 ```bash pip install gpiod ``` 把led正极插入PH5,负极插入GND 编写代码 ``` bash vim led.py ``` 复制代码进去 ```python import time import gpiod as gpio PH_BASE (8 1)*32 # \"PH\" gpiochip1 gpio.chip(\"gpiochip1\") led gpiochip1.get_line((PH_BASE + 5)) # \"PH5\" config gpio.line_request() config.request_type gpio.line_request.DIRECTION_OUTPUT led.request(config) while led: led.set_value(0) time.sleep(1) print(\"led on\") led.set_value(1) time.sleep(1) print(\"led off\") ``` 执行代码 ```bash python3 led.py ``` 效果如下： ![202108091956](./assets/202108091956.gif) ## 运行神经网络实例 获取1000类物体分类模型 下载站链接[zhouyi_test.tar.xz](https://dl.sipeed.com/shareURL/MaixII/MaixII A/example),使用任意方式上传到板子中 ```bash tar Jxvf zhouyi_test.tar.xz #解压压缩包 cd zhouyi_test #打开解压后的文件目录 chmod 777 run.sh #授予执行权限 ./run.sh #执行1000类物体分类 ``` ## 设置开机启动 启用开机自启动脚本 ```bash vim /lib/systemd/system/rc local.service ``` 在最后面添加 ```bash [Install] WantedBy multi user.target Alias rc.local.service ``` 编辑自启动脚本 ```bash vim /etc/rc.local ``` 在`exit 0`前面添加需要启动的服务 然后重启即可 注意，此脚本会在用户登录前执行，执行日志如下 ```bash [ OK ] Finished Permit User Sessions. [ 38.569457] rc.local[1322]: hello world! ``` ## 更多的使用方法 请到[MaixPy3](/soft/maixpy3/zh/readme.md)和[极术社区](https://aijishu.com/a/1060000000221780)中自行查看"},"/hardware/zh/maixII/M2A/flash_system.html":{"title":"系统烧录","content":"# 系统烧录 ## 系统简介 Lichee MaixSense（以下简称R329）提供了以下两种系统镜像 名称 armbian Tina : : : 简介 专门用于ARM开发板的轻量级 Debian 全志魔改OpenWRT1404的系统 特点 主线化Linux，功能丰富 厂商魔改，比较精简 适用人群 极客，嵌入式入门玩家等 深度开发，需要自行定制等开发人员 > ！！！一定要严格按照步骤操作！！！armbian系统请使用大于 4G 的 TF/SD 卡进行烧录，Tina系统请使用大于 1G 的 TF/SD 卡进行烧录, 质量较差的启动卡会有糟糕的实际使用体验 对于 R329 芯片， 建议使用 Etcher 软件来烧录镜像。 ## 获取镜像 ### armbian 系统镜像 armbian 镜像获取： > 链接：[百度网盘](https://pan.baidu.com/s/1p4cCSFLIPVOnVXB_TT546g) 提取码：`r329` 其中以 maixpy3 开头命名的镜像文件的是已经装载了 MaixPy3 库和相关驱动的镜像包。 armbian 镜像所打包的方法为 [dd](https://baike.baidu.com/item/DD/2654972); 可以选用适合当前系统的 [Etcher](https://www.balena.io/etcher/ \"Etcher\") 软件来烧录。 ### Tina 系统镜像 Tina 系统需要自己进行编译，具体编译方式参考 [https://github.com/sipeed/R329 Tina jishu](https://github.com/sipeed/R329 Tina jishu) ## 烧录镜像 ### armbian 镜像烧录 #### 资源获取 下载[Etcher](https://www.balena.io/etcher/ \"Etcher\") #### 烧录步骤 首先解压所下载的镜像压缩包，得到 `.img` 镜像文件，打开 [Etcher](https://www.balena.io/etcher/ \"Etcher\") 软件，点击 `Flash from file` ,选中解压出来的 `.img ` 文件镜像，然后点击 `Select target` 选中sd卡，最后点击 `Flash` 进行烧录，等待完成即可。 下面只是用原始的 armbian 作为展示，有需求的话可也已选择下载带有 MaixPy3 的镜像文件。 ![burn](./assets/95133.gif) 最终下载结束后的效果会和下图一样，显示 `Flash Complete!`： ![下载结束](./assets/finish_flash.png) 如果烧录失败了，请手动格式化一下 sd 卡。Windows 和 MacOS 可以使用 [SD Card Formatter](https://www.sdcard.org/downloads/formatter/eula_windows/SDCardFormatterv5_WinEN.zip)来格式化 sd 卡，Linux 系统可以使用 [Gparted](https://gparted.org/)来格式化。 ### Tina 镜像烧录 Tina 系统的烧录方式和 MaixII Dock 通用，可参考[MaixII M2dock 烧录系统 Sipeed Wiki](./../M2/flash.html)，这里不多做介绍"},"/hardware/zh/maixII/M2A/config_system.html":{"title":"配置系统","content":"# 配置系统 Lichee MaixSense 的引脚图如下: <img src \"./assets/R329 pin.png\" alt \"pinmap\" width 60%> ## 连接串口 连接串口是为了使电脑与板子能够进行通信。 相关操作： 使用 Type C 线将电脑与上图所标注处的 `USB转系统串口` 相连即可，然后根据电脑系统执行不同的下方操作 ### Linux & macOS Linux 不需要装驱动，系统自带了，使用 `ls /dev/ttyUSB*` 命令即可看到设备号 ### Windows Lichee MaixSense 使用了 CH340 作为串口芯片。Windows 用户需要安装 CH340 的驱动。 Windows 下载 [ch340 ch341 driver](https://api.dl.sipeed.com/shareURL/MAIX/tools/ch340_ch341_driver) 安装即可，然后可以在设备管理器中看到串口设备和端口号。 ## Tina 系统配置 一般建议使用 armbian 系统，对于 Tina 系统用户需要有一定的使用基础才能够使用。 Lichee MaixSense 的 Tina 系统配置和 [M2dock](./../M2/usage.html) 基本相同，这里不另作赘述。 <! 可以将板子上的摄像头拆下来后再将电脑与该接口相连然后使用 [adb](https://developer.android.google.cn/studio/releases/platform tools?hl zh cn) 工具来操作板子，此操作仅限 Tina 系统。因为不推荐小白使用 Tina 系统，所以此处不再细说 > ## armbian 系统配置 根据本文开头描述来将电脑与板子连接且安装 [CH340 驱动](https://dl.sipeed.com/fileList/MAIX/tools/ch340_ch341_driver/CH341SER.EXE) 后，可以在串口软件比如 Xshell 或者 [Mobaxterm](./../M2/tools/mobaxterm.html)中，设置波特率 (baudrate) 为115200，选择板子的串口，连接上板子。 由于所提供的下载镜像分为内置 MaixPy3 的镜像和无 MaixPy3 的镜像，所以下面分为两种来说明相关操作。 ### 默认含有 MaixPy3 的镜像 用户名和密码均为 `root` ，登陆进去即可。输入的时候要是输错了就是直接按回车重来吧，最好输入时无更改。 成功登录的 log 参考如下： ```bash Armbian 21.08.0 trunk Bullseye ttyS0 maixsense login: root Password: __ __ _ ____ \\/ __ _(_)_ __/ ___ ___ _ __ ___ ___ \\/ / _` \\ \\/ /\\___ \\ / _ \\ '_ \\/ __/ _ \\ (_ > < ___) __/ \\__ \\ __/ _ _\\__,__/_/\\_\\____/ \\____ ____/\\___ Welcome to Armbian 21.08.0 trunk Bullseye with bleeding edge Linux 5.14.0 rc7 sun50iw11 No end user support: built from trunk & unsupported (bullseye) userspace! System load: 133% Up time: 0 min Memory usage: 53% of 231M Zram usage: 23% of 115M IP: 192.168.0.251 CPU temp: 50°C Usage of /: 77% of 2.9G [ 0 security updates available, 66 updates total: apt upgrade ] Last check: 2022 08 31 01:45 [ General system configuration (beta): armbian config ] Last login: Tue Aug 30 10:34:06 UTC 2022 on ttyS0 root@maixsense: ``` ### 不含 MaixPy3 的镜像 首次使用需要设置密码，第一次使用没有设置密码的话只能重新烧录重新获取设置密码的机会。 密码过短或者过于简单的话会被要求重新设置。 ```bash New to Armbian? Documentation: https://docs.armbian.com Support: https://forum.armbian.com New root password: ********** Repeat password: ********** ``` 设置完密码后需要自行设置默认 shell,一般选择 bash ```bash Choose default system command shell: 1) bash 2) zsh Shell: BASH ``` 然后会要求新建一个用户，自定义用户名和登录密码即可。 ```bash Creating a new user account. Press <Ctrl C> to abort Please provide a username (eg. your forename): ll Create password: ********* Repeat password: ********* ``` 新建用户后默认给新建的用户授予了 root 权限，以后可以直接使用新建的用户来操作板子。 我们可以用 `passwd` 命令来删除或者修改密码。 例如我们可以使用 `passwd d root` 来删除我们开始所创建的 root 用户的密码，也可以使用 `passwd root` 命令来重新设置 root 用户的密码 下面是部分 `passwd` 命令例子 log ```bash root@maixsense:~# passwd root New password: Retype new password: passwd: password updated successfully ``` 下面是部分示例~ ![2021080511 46 52](./assets/2021080511 46 52.gif)"},"/hardware/zh/maixII/M2A/R329.html":{"title":"芯片介绍","content":"# 芯片介绍 ## R329 全志 R329 双核 Cortex A53 处理器的 64 位，配备双 HIFI4 DSP 用于音频后处理和预处理，以及 Arm 中国的 AIPU（人工智能处理单元）以极低的功耗提供高达 0.256 TOPS。可以对神经网络进行硬件加速，驱动 720p 的摄像头。 ![R329框架](./assets/R329_1.png) 项目 参数 CPU Dual core ARM Cortex™ A53@1.5GHz<br>32KB L1 I cache + 32KB L1 D cache per core<br>256KB L2 cache DSP Dual core HiFi4@400MHz<br> 32KB L1 I cache + 32KB L1 D cache per core<br> 2MB SRAM NPU 搭载周易™Z1 AIPU，最大支持0.25TOPS@600MHz 内存<br>Memory 内置 DDR3 128MB<br> 支持 SPI Nand/Nor/eMMC Audio Supports 5 audio ADC and 2 audio DAC<br>Supports 5 analog audio inputs and 2 analog audio output<br>Up to 3 I2S/PCM controllers for Bluetooth and external audio codec<br>Integrated digital microphone, supports maximum 8 digital microphones Enthernet 10/100/1000 Mbps USB OTG \\* 1<br>Host \\* 1 SDIO SDIO 3.0 * 2 I2S I2S*3(I2S0, I2S1, S I2S0) SPI SPI*2(SPI0, SPI1) TWI TWI*3(TWI0, TWI1, S TWI0) GPADC 4 ch SCR SCR*1 PWM PWM*15(PWM[8:0], S PWM[5:0])"},"/hardware/zh/maixII/M2A/maixsense.html":{"title":"MaixSense 简介","content":"# MaixSense 简介 这个板子和之前的 Maix I 系列不同，它的主控不但带有 AI 加速功能，还支持运行 armbian 系统。 ## M2A 板卡 M2A 板卡以全志 R329 为核心主控，还集成电源芯片、FEL烧录按键、wifi模组、存储焊盘和 RMGII 接口等组件。 ![M2A](./assets/M2A.jpg) ### R329 芯片 R329 芯片是由全志科技所设计双核 Cortex A53 64 位处理器 ，配备有双 HIFI4 DSP 可用于音频后处理和预处理，以及 Arm 中国以极低的功耗却可达到 0.256 TOPS 算力的 AIPU（人工智能处理单元），能够用来硬件加速神经网络，对摄像头获取到的 720p 分辨率的图像进行相应的处理。 ![R329框架](./assets/R329_1.png) 条目 参数 CPU Dual core ARM Cortex™ A53@1.5GHz<br>32KB L1 I cache + 32KB L1 D cache per core<br>256KB L2 cache DSP Dual core HiFi4@400MHz<br> 32KB L1 I cache + 32KB L1 D cache per core<br> 2MB SRAM NPU 搭载周易™Z1 AIPU，最大支持0.25TOPS@600MHz 内存 内置 DDR3 256MB 储存 支持 SPI Nand/Nor/eMMC 音频 5路ADC，2路DAC<br>3个 I2S/PCM 控制器 以太网 10/100/1000 Mbps USB OTG \\* 1<br>Host \\* 1 SDIO SDIO 3.0 * 2 I2S I2S*3(I2S0, I2S1, S I2S0) SPI SPI*2(SPI0, SPI1) TWI TWI*3(TWI0, TWI1, S TWI0) GPADC 4 ch SCR SCR*1 PWM PWM*15(PWM[8:0], S PWM[5:0]) ## MaixSense开发板介绍 MaixSense 开发板可能是市面上最小的 Linux 卡片电脑。本套件包含一个搭载全志 R329 的高度集成 SOM 核心板，以及一个多功能 IO 扩展底板，可以运行 Linux 系统, 并具备出色的扩展功能。您可以将它用于搭建个人服务器、开发智能语音助手、设计机器人等场景。它通过内置的周易 AIPU 处理器同时支持智能语音和视频图像处理，开发者可以直接在开发板上跑通 CV , NLP 等 AI 模型。 **Tina Linux**：全志科技基于 Linux 内核开发的针对智能硬件类产品的嵌入式软件系统。Tina Linux基于 openwrt 14.07 版本的软件开发包,包含了Linux系统开发用到的内核源码、驱动、工具、系统中间件与应用程序包。可以从 [https://github.com/sipeed/r329 linux 4.9](https://github.com/sipeed/r329 linux 4.9) 获取到 Tina sdk。 但是 MaixSense 不只是可以运行 Tina ，还可以运行 **armbian**，这是一个真正**完整**的 linux 系统，armbian 是基于 debian/ubuntu 进行开发的。 名称 armbian Tina 简介 专门用于`ARM`开发板的`Debian` 全志深度修改OpenWRT1404的系统 特点 主线化Linux，功能丰富 厂商深度修改，软硬件契合度高 适用人群 极客，嵌入式入门玩家等 深度开发，需要自行定制等开发人员 ## MaixSense外观预览 <div align \"center\"> <img src \"./assets/M2A 1.gif\" alt \"Maixsense outlook\" > </div> ## MaixSense 基本参数 <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">MaixSense基本参数</th> </tr> </thead> <tbody> <tr> <td>处理器 CPU</td> <td>双核 ARM CortexTM A53™ </td> </tr> <tr> <td>AIPU(NPU)</td> <td>搭载周易TZ1AIPU，最大支持0.25TOPS@600MHz</td> </tr> <tr> <td>DRAM</td> <td>SIP 256MB DDR3</td> </tr> <tr> <td>存储</td> <td>可使用核心板搭载的 SPINAND (默认空贴)存储<br>可使用底板搭载的SD卡座</td> </tr> <tr> <td>视频编码器</td> <td>H264/5 &JPEG,最大720p@30fps</td> </tr> <tr> <td>摄像头</td> <td>出厂默认OV9732，最高支持720P@30fps HD<br>采用USB C连接器,支持正反插(可分别用作前后摄)</td> </tr> <tr> <td>麦克风</td> <td>两个模拟MEMS麦克风，平均灵敏度91dB SPL@1kHz</td> </tr> <tr> <td>屏幕</td> <td>1.5寸SPI总线屏幕,屏幕接口采用0.5mm 12P FPC，分辨率240*240</td> </tr> <tr> <td>按键</td> <td>1个复位按键和4个用户按键(ADC按键)，1个下载按键(FEL)</td> </tr> <tr> <td>以太网接口</td> <td>在核心板以24P 0.5mm间距FPC的形式引出，用于连接相应PHY</td> </tr> <tr> <td>IO引出</td> <td>3*10P 2.54mm 焊盘<br>1个4PMx1.25插座(引出2*GPIO和5V/GND)<br>具体可看下方引脚图</td> </tr> </tbody> </table> ## 引脚图参考 ![R329 pin](./assets/R329 pin.png) 摄像头接口图： ![camera_pin_order](./assets/camera_pin_order.png) ## 相关资料 [MaixSense 硬件资料](https://dl.sipeed.com/shareURL/MaixII/MaixII A) [极数社区 R329 上手帖](https://aijishu.com/a/1060000000221780) [极数社区 R329 芯片FAQ](https://aijishu.com/a/1060000000291439) [极数社区矽速科技](https://aijishu.com/blog/xisukeji)（很多资料） ## 产品技术支持 M2A 开发板可以在多种场景实现客户不同方面的需要，在 AIoT 上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maixII/M2A/ssh.html":{"title":"如何使用SSH","content":"# 如何使用SSH > 编辑于2022.04.29 这里讲一下怎么使用ssh，和一些常碰到的问题。 ## 简介 SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。 通常我们用这个来远程登陆别的linux设备。 ## 用法 ### 目标设备进行的操作 #### 目标设备安装ssh 一般来说大多数设备都已经内置了ssh，但是对于需要的话一般可以用下面命令安装ssh. ```bash sudo apt install ssh y ``` #### 开启端口 修改 /etc/ssh/sshd_config 里面的 #22 为 22 . 一般来说这样就没啥问题了，有其他的问题的话先重启试试（解决99%的问题）。剩下1%的问题网上搜搜 ### 主机端操作"},"/hardware/zh/maixII/M2/no_sd_flash.html":{"title":"无 SD 卡系统烧录方式","content":"# 无 SD 卡系统烧录方式 **目前没有在V831上进行过flash系统烧录，V833可以使用一下方式进行烧录，镜像需要发送邮件获取** 如需烧录到V831上，需要自行设计底板，引出fel烧录按键 ## 获取烧录工具 从网上获取 PhoenixSuit(Windows) 烧录工具。 [baidu PhoenixSuit](https://www.baidu.com/s?wd PhoenixSuit) [bing PhoenixSuit](https://www.bing.com/search?q PhoenixSuit&FORM BESBTB&mkt zh CN) [github PhoenixSuit](https://github.com/colorfulshark/PhoenixSuit) [lo4d PhoenixSuit](https://phoenixsuit.en.lo4d.com/windows) ## Windows 上使用 PhoenixSuit 烧录 获取系统镜像（.img） 和烧录工具（.exe） 。解压到你知道的地方。 ![](./../img/no_sd_flash.png) 解压后打开 PhoenixSuit_V1.10 烧录工具 PhoenixSuit.exe 选择烧录的 .img 镜像。 ![](./../img/no_sd_flash_1.png) 这时候开始插入硬件， 同时按下硬件的两个按键， 其中一个是 fel 烧录模式的触发， 要注意接线头是否联通。 （若是裸板如右图所示先按 FEL 后按 RST 复位） ![](./../img/no_sd_flash_2.png) 按住后， 此时插入电脑的 USB 口， 相当于上电（RST 复位） 进入烧录模式， 务必注意先按键再通电， 之后需要安装相应的 USB 驱动。 > 如果该电脑插入后设备管理器显示驱动未安装， 请手动指向 PhoenixSuit_V1.10 / Drivers 的驱动文件夹完成安装， 安装完成如下显示 Android ADB Interface ， 如果实在搞不定就使用市面上常见的驱动安装软件（如驱动精灵） 帮助安装。 ![](./../img/no_sd_flash_3.png) 这时候 PhoenixSuit 软件会提示是否格式化更新， 一直选是即可， 不成功可以重试或检测接线是否牢固。 ![](./../img/no_sd_flash_4.png) 进度状态如下， 直到成功。 ![](./../img/no_sd_flash_5.png) <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a>"},"/hardware/zh/maixII/M2/resources.html":{"title":"Maix-II-Dock(M2dock) 介绍","content":" title: Maix II Dock(M2dock) 介绍 keywords: MaixII, MaixPy3, Python, Python3, M2dock desc: 板级资源介绍 Maix II Dock 定位于高性价比的 AIOT 开发板， 支持常规 Linux 开发的同时， 有特有的 **AI 硬件加速** 特性，配合 Sipeed 提供的完整的软件生态，让你快速实现你的边缘 AI 应用。 * **硬件**上， 基于全志 V831 芯片， 以【核心板】+【底板】的形式组成开发板，可以直接使用开发板，也可以只使用核心板根据需求自行设计底板，方便快速完成开发。 * **软件**上， 除了可以直接使用全志提供的资料进行开发（部分可能需要找全志获取）外，Sipeed 提供了非常方便的 Python SDK（[MaixPy3](/maixpy3)）以及 C SDK （[libmaix](https://github.com/sipeed/libmaix)）； 更是提供了在线模型训练服务（[MaixHub](https://maixhub.com)），方便刚入门也能快速训练能使用的 AI 模型。 * **购买**：[sipeed.taobao.com](https://item.taobao.com/item.htm?id 635874427363) <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 298543445&bvid BV1sF411u7xb&cid 586467021&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> </p> ## M2 核心板 <img style \"max height: 260px\" src \"./asserts/maix_v831.jpg\" alt \"core_board\"/> > 核心板硬件资料下载 [Sipeed_Maix_II_3101](https://api.dl.sipeed.com/shareURL/MaixII/MaixII Dock/HDK/Sipeed_MaixII_V831/Sipeed_Maix_II_3101) ### V831 芯片介绍 全志 V831, 单核 Cortex A7 800MHz， 64MiB 片内 DDR2 内存， 高性价比能跑 Linux 的SOC，同时支持硬件 AI 加速（0.2Tops 算力），可以当成普通 Linux SOC 使用， 也可以用于边缘 AI 应用， 更详细的参数请看手册和下文。 芯片手册： [V833／V831 Datasheet V1.0.pdf](https://linux sunxi.org/images/b/b9/V833%EF%BC%8FV831_Datasheet_V1.0.pdf) 内部结构图： <img style \"max height: 400px\" src \"./asserts/V831_struct.png\" alt \"V831 struct\"/> ### M2核心板参数 与 Maix I 对比 项目 Maix I (K210) Maix II (V831) 主控芯片<br> CPU 400~600Mhz 800~1000Mhz 视频编码器 <br>Video encoder None H.264, up to 1080p@30fps<br>H265, up to 1080p@30fps<br>JPEG, up to 1080p@30fps AI加速器<br>NPU 0.23TOPS<br>support Conv+BN+ACT+POOL 0.2TOPS<br>support Conv,Inner_Product,Pool,Eltwise,ACT,BN,Split,Concat 内存<br>Memory 8MB SRAM SIP 64MB DDR2 存储<br>Storage 16MB SPI Nor Flash 可选的16M flash(默认空贴) 摄像头<br>Camera DVP, 最高输入30W像素 2lane MIPI, 最高支持1080P@60fps 显示<br>Display 8bit MCU LCD 8bit MCU LCD, 配转接板可接最大10寸RGB LCD SDIO None SMHC x2 (SDC0, SDC1) SPI SPIx3 SPI x2 (SPI0, SPI1) I2C I2C x3 I2C x4 (TWI0, TWI1, TWI2, TWI3) I2S 8bit I2S I2S x1 (I2S0) Ethernet None 10/100 Mbit/s Ethernet port with RMII interface ADC None 1 ch 6bit LRADC for key Audio None LINEOUTP + MICIN1P/N 开发软件 Maixpy/C MaixPy3/linux ## 底板 一般情况下可以认为底板屏幕为正面，带摄像头为背面。 ![m2dock](./../../../assets/maixII/m2dock.jpg) > 底板硬件资料下载 [点我跳转](https://api.dl.sipeed.com/shareURL/MaixII/MaixII Dock/HDK/Sipeed_MaixII_Dock_V831) > 感谢热心网友分享的 [ M2 模块底板母座 PCB 封装](https://bbs.elecfans.com/jishu_2036119_1_1.html) ### 底板硬件参数 ![Pin](./asserts/M2Dock_pin.jpg) 标号 Maix II 部件 功能 备注 1 M.2 B KEY 母座*1 用于连接 V831 核心版 出厂已连接 2 核心板M2 铜柱螺母*1 用于配合 M2 螺丝固定 V831 核心板 出厂已固定 3 电源指示 LED 灯*1 用于指示底板是否正常通电 4 状态指示 LED灯*1 用户可编程LED灯，一般用于状态指示 5 CPU 复位键*1 按下可重启 V831 芯片 6 用户按键*2 可以控制两路 IO 电平，自定义功能 7 Wi Fi 模块*1 型号 RTL8189FTV，用于给模组提供 Wi Fi 功能 SDIO 接口 8 BTB 摄像头接口*1 用于连接 BTB 摄像头模块 出厂已连接 9 摄像头 M2 铜柱螺母*2 用于固定 BTB 摄像头 出厂已固定 10 FHD 摄像头*1 默认SP2305 Sensor BTB形式，1080P 默认含6mm焦距M12镜头，用户可选配其他焦距镜头 11 USB 转 UART 芯片*1 提供串口通信功能 出厂已烧录固件 12 Type C 接口(USB OTG) *1 用于 V831 的 USB OTG功能 可用于模组供电 13 Type C 接口(UART) *1 用于对V831通常的串口调试 可用于模组供电 14 三轴加速度传感器*1 I2C接口，可提供3轴的加速度数据 15 microSD 卡槽*1 用于外接 microSD卡 模组的系统默认从SD卡引导 16 LCD 接口*1 FPC0.5mm 24Pin，MCU 接口 17 IPS 高清屏幕\\*1 1.3寸IPS屏幕，分辨率240\\*240 出厂已连接 18 IPEX Wi Fi天线座 IPEX(一代) Wi Fi天线 19 外拓排母 引出 V831 的 通用IO口，可用于连接外设 20 扬声器接口*1 MX1.25 2P接口（间距1.25mm） 21 扬声器*1 8Ω1W 1609复合铝膜扬声器 出厂已连接 22 麦克风*1 模拟驻极体麦克风 ## 资源汇总 硬件: [MaixII 硬件资料库](https://api.dl.sipeed.com/shareURL/MaixII/MaixII Dock/HDK) 软件： * Python SDK： [MaixPy3 软件文档](/maixpy3) * C SDK: [libmiax](https://github.com/sipeed/libmaix) * MaixHub 模型平台（AI 模型下载、在线训练、项目分享）： [MaixHub](https://maixhub.com) * 全志 tina V83x SDK： [Tina Linux/tina V83x](https://github.com/Tina Linux/tina V83x) * 工具链： [dl.sipeed.com](https://dl.sipeed.com/shareURL/MaixII/MaixII Dock/SDK/Toolchain) 或者 [github](https://github.com/sipeed/libmaix/releases/download/v0.1.0/toolchain sunxi musl pack 2021 01 09.tar.xz) ## Maix II Dock 上手开发路线指南 * 因为需要使用 linux 系统（tina linx）， 所以需要先学习烧录系统镜像，就类似学会电脑重装系统一样，这样在遇到问题就可以重来，在左侧目录找到“烧录系统”文章查看 <! 这里不给烧录系统的链接，让用户学会查看左边目录 > * 学会基础的 Linux 操作，比如如何打开终端，基础的终端命令，以及如何传输文件到开发板等，比如 串口使用， adb 使用等等基础操作 * 选择开发语言： * 如果你熟悉 C 有一定的开发经验，可以选择使用[libmaix](https://github.com/sipeed/libmaix) * 如果你希望快速上手，并使用 Python 语言开发， 请使用[MaixPy3](/maixpy3)，仔细阅读其文档即可 * 如果需要使用 AI 功能，可以搭配 [MaixHub](https://maixhub.com) 在线训练平台使用，平台提供了 AI 模型或者项目分享功能，节约大家不少时间。"},"/hardware/zh/maixII/M2/usage.html":{"title":"进阶使用","content":" title: 进阶使用 keywords: MaixII, MaixPy3, Python, Python3, M2dock, Tina, Openwrt desc: maixpy MaixII M2dock 上手使用 > 没有 Linux 系统使用基础的同学，不推荐以下的使用方式 阅读 [MaixII Dock Maixpy3](https://wiki.sipeed.com/soft/maixpy3/zh/tools/0.MaixII Dock.html) 来查看更多用法 ## 认识 openwrt 系统 > 全志 V831 使用 Tina Linux 系统，移植自 [OpenWrt](https://openwrt.org) 。 OpenWrt 可以被描述为一个嵌入式的 Linux 发行版，详情可看 [官方网址](https://openwrt.org) 和 [官方开源仓库](https://github.com/openwrt/openwrt)。 OpenWRT 是一个高度模块化、高度自动化的嵌入式 Linux 系统，拥有强大的网络组件和扩展性，常常被用于工控设备、电话、小型机器人、智能家居、路由器以及 VOIP 设备中。 同时，它还提供了 100 多个已编译好的软件，而且数量还在不断增加，而 OpenWrt SDK 更简化了开发软件的工序。 V831 tina 系统支持使用 adb 来操作系统。需要将主机于板子的OTG标识的接口相连。 Windows 系统需要先下载最新的 adb 然后将其解压并添加到系统路径，接着就可以在命令行中使用 adb shell 连接上 v831. 对于 linux 直接安装 adb 即可，然后在终端执行 adb shell 连接 V831 ## M2Dock 联网 M2Dock 带有 2.4G 无线模组，可以用来连接 2.4G 频段的无线网络。 因为镜像更新会更改部分内容，所以下面以 V0.5.4 版本的系统镜像和 V0.5.4 之前的镜像来分别说明怎么样来使用 M2Dock 连接到无线网络。 ### V0.5.4 在 0.5.4 (时间戳为 20230207 )的镜像中，移除了之前编辑配置文件然后再连接网络的方法，改为用命令行来连接无线网络。 可以看到板子中内置了许多 wifi 相关的命令（按 TAB 补全剩余命令，没有就自己手动敲完整） ![wifi_test_command_list](./asserts/usage/wifi_test_command_list.jpg) 这里只使用 `wifi_connect_ap_test` 命令来连接无线网络，在使用之前可以先直接执行 `wifi_scan_results_test` 命令来扫描周围网络，确定板子可以识别到目标无线网络。 使用下面的命令来连接名称为 `Sipeed_Guest`， 且密码为 `qwert123` 的无线网络。 ```bash wifi_connect_ap_test Sipeed_Guest qwert123 ``` ![wifi_test_connect_wireless](./asserts/usage/wifi_test_connect_wireless.jpg) 在连接的信息中可以看到 `192.168.3.158` 这串数字，这是板子在当前网络环境中的 IP 地址。 执行 `ifconfig` 命令可以看到 wlan0 的 IP 地址为 `192.168.3.158`，与连接 WiFi 时候的信息一样。 ![wifi_test_ifconfig](./asserts/usage/wifi_test_ifconfig.jpg) ### V0.5.4 之前的镜像 开发板上的 OTG 接口与电脑连接之后，就会在资源管理器中得到一个 U 盘 设备。通过编辑器打开里面名为 `wpa_supplicant.conf` 文件 ![wap_conf_png](./asserts/usage/wap_conf.png) 可以看到里面有 `yourWIFIname` 和 `yourWIFIpassword` 两项，将他们更改成你想要连接的无线网络和对应的无线网络密码并保存后，使用电脑系统自带的弹出 U 盘操作方式来移除 U 盘，这样可以避免损坏 U 盘的文件系统。接着在 m2dock 命令行终端执行 `reboot` 命令来重启板卡，开机后就自动连接 WiFi 了。 ![wap_conf_gif](./asserts/usage/wap_conf.gif) ### 如何更新 MaixPy3 包 可以手动下载最新的 MaixPy3 [安装包](https://pypi.org/project/maixpy3/#history) ![maixpy3_download](./asserts/usage/maixpy3_download.png) 下载带有 cp8 的安装包，cp9 是给别的平台使用的。将这个安装的名字修改成 `maixpy3 9.9.9 cp38 cp38 linux_armv7l.whl`,直接存放到开发板中，重启开发板就会自动更新和安装 MaixPy3。 ![maixpy3_install](./asserts/usage/maixpy3_install.png) 更新前请关闭 IDE 或不接 OTG 口，防止有其他操作影响系统的软件更新，在放入 U 盘后，断电开机会看到如下画面，如果超过 3 分钟画面没有变化，那可能就是失败了，就请重烧系统吧。（2022 年 1 月 14 日至今还没出现过失败样本） ### 更多连接方式 使用 mobaxterm 可以进行串口连接和 ssh 连接，具体教程查看【<a href 'https://wiki.sipeed.com/hardware/zh/maixII/M2/tools/mobaxterm.html' target _blank>如何使用 mobaxterm</a>】 ![mobaxterm_connect](./asserts/usage/mobaxterm_connect.png) ## 部分常用 Linux 命令 <details> <summary>点击查看部分常用命令</summary> <pre> ls 查看目录下文件 cd 打开目录 pwd 打印当前目录 mv 移动/重命名 文件/文件夹 cp 复制 文件/文件夹 rm 删除 vi 编辑文件内容 #需要使用特定的adb版本能正常显示内容 top 查看系统内存 df 查看磁盘信息 time 查看时间 ifconfig 查看网络信息 free 查看剩余内存 ps 查看运行的进程 kill 终止进程 killall 终止所有进程 chmod 更改 文件/文件夹 权限 passwd 设置/更改 用户密码 cat 查看文件内容 ping 检测某网址是否连通 wget 下载某链接文件 grep 搜索文件内容 ln 建立文件链接 </pre> </details> ## Opkg 包管理器 Opkg 是一个轻量快速的套件管理系统，目前已成为 Opensource 界嵌入式系统标准。常用于 路由、 交换机等 嵌入式设备中，用来管理软件包的安装升级与下载。 ### 相关常用命令 opkg update 更新可以获取的软件包列表 opkg upgrade 对已经安装的软件包升级 opkg list 获取软件列表 opkg install 安装指定的软件包 opkg remove 卸载已经安装的指定的软件包 例如： ```bash root@sipeed:/# opkg list MaixPy3 0.2.5 1 alsa lib 1.1.4.1 1 busybox 1.27.2 3 busybox init base files 167 1612350358 ca certificates 20160104 curl 7.54.1 1 dropbear 2015.71 2 e2fsprogs 1.42.12 1 eyesee mpp external 1.0 1 eyesee mpp middleware 1.0 1 eyesee mpp system 1.0 1 ``` ## pip 包管理器 [pip](https://pypi.org/project/pip/) 是 Python 包管理工具，该工具提供了对 Python 包的查找、下载、安装、卸载的功能。 > 以下讯息由[YanxingLiu](https://github.com/YanxingLiu)提供与测试。 ### pip换源 在安装系统后可以更换镜像源，加速 pip 安装。 ### 临时使用 ```python pip install i https://pypi.tuna.tsinghua.edu.cn/simple some package ``` some package 请自行更换成你想要安装的包 ### 设为默认 升级 pip 到最新的版本 (> 10.0.0) 后进行配置： ```python pip install i https://pypi.tuna.tsinghua.edu.cn/simple pip U ``` 设置清华镜像源为默认： ```python pip config set global.index url https://pypi.tuna.tsinghua.edu.cn/simple ``` ## 测试屏幕方法 请测试前观察系统上电后屏幕是否会闪烁一次；这表示屏幕已经通电、驱动起来，并对其复位（RST）后产生的。 在 Linux Shell 运行 `cat /dev/urandom > /dev/fb0` 就会输入随机数据到 fb0 产生雪花屏了，这表示屏幕显示是正常的。 <center><img src \"./asserts/lcd_test.jpg\" width \"400\"></center> <details> <summary>帧缓冲相关知识</summary> 帧缓冲（framebuffer）是 Linux 为显示设备提供的一个接口，把显存抽象后的一种设备。 它允许上层应用程序在图形模式下直接对显示缓冲区进行 读写操作。framebuffer 是 LCD 对应的一种 HAL（硬件抽象层），提供抽象的，统一的接口操作，用户不必关心硬件层是怎么实施的。这些都是由 Framebuffer 设备驱动来完成的。帧缓冲设备对应的设备文件为 /dev/fb*，如果系统有多个显示卡，Linux下还可支持多个帧缓冲设备，最多可达 32 个，分别为 /dev/fb0 到 /dev/fb31，而 /dev/fb 则为当前缺省的帧缓冲设备，通常指向 /dev/fb0，在嵌入式系统中支持一个显示设备就够了。帧缓冲设备为标准字 符设备，主设备号为 29 ，次设备号则从 0 到 31 。分别对应 /dev/fb0 /dev/fb31 。 </details> ## 运行 Python3 解释器 在 Linux 上使用 Python 编程只需要在 adb shell 命令行交互的接口输入 python3 即可启动，可直接复制代码粘贴后按回车键运行。 ```python import platform print(platform.uname()) ``` 2022年7月6日 实际操作结果： ```bash __ _ / / (_)__ __ ____ __ / /__/ / _ \\/ // /\\ \\ / sipeed.com (Neptune) /____/_/_//_/\\_,_//_\\_\\ root@sipeed:/# python3 Python 3.8.5 (default, Jun 14 2022, 09:51:56) [GCC 6.4.1] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> import platform >>> print(platform.uname()) uname_result(system 'Linux', node 'sipeed', release '4.9.118', version '#3242 PREEMPT Tue Jun 28 04:03:38 UTC 2022', machine 'armv7l', processor '') ``` ## 测试拍照功能 这里我们使用 [MaixPy3](/maixpy3) 来测试一下摄像头，先以交互模式启动一下 Python, ```python from maix import camera, display, image display.show(camera.capture()) ``` <center><img src \"./asserts/hello_world.jpg\" width \"500\"></center> > 如果屏幕没有显示内容。那么首先确认一下镜像镜像版本，并且确认一下外设和驱动对的上 ## 怎么样使用 USB 摄像头 M2Dock 有两个 TypeC 接口。其中一个标识有 UART，作为板子与电脑进行串口通信的接口。另一个口有 OTG 标识，默认是作为 USB 从机来使用的，比如我们能够在电脑上使用 `adb` 来操作 M2Dock 就是因为这个接口默认是从机模式。 想要连接摄像头，需要手动更改这个端口为主机模式。从板子上的串口 USB 来操作板子，并执行下面的命令就可以将 OTG 口作为主机模式使用。 ```bash echo \"usb_host\" > /sys/devices/platform/soc/usbc0/otg_role ``` 接着就能向通常的 linux 系统一样操作 /dev 目录下的摄像头了。 ## 如何将 USB OTG 口作为从机 M2Dock 默认的 OTG 口就是 USB 从机设备了，要是有因为其他原因需要重新设置成从机设备的话，在 M2Dock 上执行下面的命令就可以了。 ```bash echo \"usb_device\" > /sys/devices/platform/soc/usbc0/otg_role ``` ## 工具链 [这里](https://dl.sipeed.com/shareURL/MaixII/MaixII Dock/SDK/Toolchain)提供了在 linux 系统下的编译工具链，有能力的可以自己试一下。无相关支持 建议使用 [MaixPy3](/soft/maixpy3/zh/index.html) 来操作设备 ## MaixPy3 本设备建议使用 [MaixPy3](/soft/maixpy3/zh/index.html) 来进行相应的快速开发，相关文档请仔细阅读 ## 源码 V831 的源码已经放在 https://github.com/Tina Linux/tina V83x ，有需要的可以自行尝试一下"},"/hardware/zh/maixII/M2/PhoenixSuit.html":{"title":"MaixII M2dock 烧录系统","content":" title: MaixII M2dock 烧录系统 keywords: MaixII, MaixPy3, Python, Python3, M2dock desc: maixpy MaixII M2dock 烧录系统 > ！！！一定要严格按照步骤操作！！！请使用大于 1G 的 TF/SD 卡进行烧录，开源版本要求使用 TF/SD 卡来启动系统。 V831 为全志的 SOC， 所以 Windwos 使用 **PhoenixSuit**, Linux 上使用 **Livesuit** 烧录镜像文件。 从下载站获取最新的 V831 系统镜像 [SDK_MaixII/release](http://dl.sipeed.com/shareURL/MAIX/SDK_MaixII/release) ，找不到就搜索 V831 获取最新的镜像。 解压 V831 镜像压缩包，得到一个 xxxx.img 文件。 从网上获取 PhoenixSuit(Windows) 烧录工具。 [baidu PhoenixSuit](https://www.baidu.com/s?wd PhoenixSuit) [bing PhoenixSuit](https://www.bing.com/search?q PhoenixSuit&FORM BESBTB&mkt zh CN) [github PhoenixSuit](https://github.com/colorfulshark/PhoenixSuit) [lo4d PhoenixSuit](https://phoenixsuit.en.lo4d.com/windows) ## Windows 上使用 PhoenixSuit 烧录 解压 PhoenixSuit(Windows) 工具压缩包，不插入 SD 卡，将 V831 USB OTG 接口连接到 PC，打开设备管理器，安装驱动文件 ![](./asserts/flash_01.png) ![](./asserts/flash_03.png) 打开烧录软件, 并浏览打开镜像文件 ![](./asserts/flash_05.png) 重新插拔板子（上电不插入 SD 卡），软件提示是否要清空烧录，提示是否需要升级，点击 `YES` ![](./asserts/flash_07.png) 插入 sd 卡，提示是否强制格式化，再次点击 `YES`开始烧录（大约 40S） ![](./asserts/flash_09.png) 可能需要等待几秒才会更新状态，然后等待提示“固件升级成功”，即可断开 USB ，至此固件烧录完毕 ![](./asserts/flash_11.png) ![](./asserts/flash_13.png)"},"/hardware/zh/maixII/M2/tools/vscode.html":{"title":"如何使用 vscode","content":" title: 如何使用 vscode keywords: vscode, MaixPy3, Python, Python3 desc: maixpy 如何使用 vscode ## 前言 它是微软出品的一款可扩展的轻量级开源编辑器，并且支持全平台系统。这些特性使得 VSCode 颇受欢迎，这也使其成为了一个很棒的 Python 开发平台。 关于如何安装和使用它的教程已经数不胜数，这里只推荐[【用 VSCode 愉快地写 Python 代码】](https://zhuanlan.zhihu.com/p/66157046)。 ## 为什么要使用它？ 除了专业 Python 代码开发环境，它还支持打开 jupyter notebook 文档运行代码。 与浏览器运行的 jupyter notebook 一样，执行 Python 代码的时候要选择对应的执行核心，如 [ipython/ipykernel](https://github.com/ipython/ipykernel) 或者 [rpyc_ikernel](https://github.com/sipeed/rpyc_ikernel) 的核心。 下面就来说说如何使用它。 ### 创建 notebook 文档 ![](https://tukuimg.bdstatic.com/scrop/abb1e4146fb8679109fa99aa0b03f59f.gif) ### 运行 Python 代码 ![](https://tukuimg.bdstatic.com/scrop/a1e2381bfac1a332a323774ee1b49c9f.gif) ### 运行后预览图表 ![](https://tukuimg.bdstatic.com/scrop/9c5bf21507c776f98d55bcfc0e51c5ff.gif) ## 你可以学到什么？ 在 VS Code 中使用 Jupyter 笔记本时需要进行的基本操作。如果您使用 VS Code 来满足其他开发需求，那么在 VS Code 中尝试使用 Jupyter Notebook 是非常方便的，这样您就可以只使用一个 IDE。特别是其代码自动补齐的功能可以让你的开发更快捷。 > 需要注意的是，截止 2021年3月3日 在 VSCODE 里的 jupyter notebook 文档进行中断存在一些问题，并不是很流畅，如果出现了运行无响应的问题可以重新打开文档解决问题。"},"/hardware/zh/maixII/M2/tools/pyqt_rtsp.html":{"title":"如何使用 pyqt_rtsp","content":" title: 如何使用 pyqt_rtsp keywords: pyqt_rtsp, MaixPy3, Python, Python3 desc: maixpy 如何使用 pyqt_rtsp > 这是一个图传客户端工具，脱离 jupyter 的编程环境，使用的时候只需要在电脑上安装好就可以链接到硬件中获取图传信息。 ![](./asserts/pyqt_rtsp.png) 这个工具是通过 Python 实现的 rtsp + rtp 流媒体服务，支持文件、图像、显示器、摄像头的图像传输，适用于支持 Python3 的系统。 ## 安装方法 首先知道它是一个 C/S 结构图传客户端，你需要在某个硬件上安装 maixpy3 和启动服务，与之对应的客户端访问该硬件获取它的流媒体，这个硬件可以是你的嵌入式 linux 设备，也可以是你的 linux 计算机。 ### 服务端配置过程 在 linux 设备上安装 maixpy3 执行 maixpy3_rpycs 即可启动作为服务端。 ```bash (venv) $ pip3 install maixpy3 (venv) $ maixpy3_rpycs ``` ### 客户端配置过程 接着要在其他电脑上通过 Python 安装 [rtsp_pyqt](https://github.com/sipeed/MaixPy3/tree/main/examples/rtsp_pyqt) 客户端工具。 ```bash (venv) $ pip3 install r requirements.txt (venv) $ python3 mainLogic.py ``` ### 使用方法 运行后可见下图，然后输入 IP （如：192.168.0.127）进行链接： ![](./asserts/pyqt_rtsp_login.png) 按下【setup】链接到目标设备自动获取摄像头流，支持播放、暂停等操作，拍照和录像自动保存到目录下的文件夹。 ## 多余的讯息 > 如 IP 可以这样获取，我只是想炫耀一下我的拼装技术，逃~ ![](./asserts/rtsp_get_ip.jpg)"},"/hardware/zh/maixII/M2/tools/mobaxterm.html":{"title":"如何使用 mobaxterm","content":" title: 如何使用 mobaxterm keywords: Jupyter, MaixPy3, Python, Python3 desc: maixpy 如何使用 mobaxterm ## mobaxterm 是什么？ 这是在 Windows 下使用的全能终端管理软件，对开发与运维人员必备，可以在 [mobaxterm.mobatek.net/download](https://mobaxterm.mobatek.net/download.html) 获取免费版本使用，在国内网站上有中文版。 ![](https://mobaxterm.mobatek.net/img/moba/features/feature terminal.png) 主要通过它提供的下列功能： serial 通过串口连接 Linux 系统的终端 ssh 远程登录 Linux 系统的终端 ftp 远程访问文件服务上的资源 ## 连接 串口(Serial) 开源硬件产品大多都会预留串口（Serial）用作 Linux 系统的终端交互接口，下面介绍串口【session】的创建。 ![](./asserts/mobaxterm serial 4.png) 在「session setting」 对话框里选择【serial】，再选好串口号及波特率，点击【OK】就完成连接了。 ![](./asserts/mobaxterm serial 5.png) 同样【session】会保存在左侧的【session】标签页里，方便下次连接。 ## 连接 SSH 除了有线串口的方式，还可以通过无线访问 SSH 登录 Linux 系统。 在板子终端输入 `hostname I` 查看自己 ip 地址 (先连上网)，然后输入自己用户名和密码。 ```bash root@maixsense:~# hostname I 192.168.0.197 ``` 然后我们就可以来新建SSH会话然后远程登录到板子了 新建SSH会话 ![](./asserts/mobaxterm_ssh.jpg) 登录到板子终端 ![](./asserts/mobaxterm_ssh_login.png) > 输入密码的时候是看不到的（没有输入显示），在输入结束之后，按回车即可 就可以看到 Linux 的登录会话终端了。 传输文件的时候可以直接把文件拖入或者拉出下图的左红框中。 ![](./asserts/mobaxterm_ssh_view.jpg) ## 连接 FTP 与 SSH 同理。 ![](./asserts/mobaxterm_ftp.png) 进入后就可以看到文件夹了。 ![](./asserts/mobaxterm_ftp.jpg) 可以拖拽文件上传和下载。 ![](./asserts/mobaxterm_ftp_ud.png) <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a>"},"/hardware/zh/maixII/M2/tools/adb.html":{"title":"adb 操作介绍","content":"# adb 操作介绍 ADB.exe 在 MaixPy3 IDE 中的 maixpy3_examples 和 PhoenixSuit 文件夹下 ## 链接开发板 将开发板上的 OTG 接口接上电脑， 然后再命令行中输入 adb shell，会自动进入到开发板的 linux 系统中 ```shell BusyBox v1.27.2 () built in shell (ash) run profile file __ ___ _ __ _ / / /__ _(_)_ __ / / (_)__ __ ____ __ / /_/ / _ `/ /\\ \\ / / /__/ / _ \\/ // /\\ \\ / /_/ /_/\\_,_/_//_\\_\\ /____/_/_//_/\\_,_//_\\_\\ root@sipeed:/# ``` 这时可以开始使用 MaixPy3 进行开发了"},"/hardware/zh/maixII/M2/introduce.html":{"title":"芯片平台介绍","content":" title: 芯片平台介绍 keywords: MaixII, MaixPy3, Python, Python3, M2dock desc: maixpy 芯片平台介绍 V831 芯片介绍 从 2019 年至今的时间，可以开始看到几个相机 SoC 与一个内置的转专业或 SIMD 指令加快人脸检测、物体检测等等，从低分辨率 Kendryte K210 处理器 2.5 k Ingenic T31 MIPS 视频处理器，甚至 4k 能力 iCatch V37 相机 SoC 。 Allwinner 过去推出了几个摄像头处理器(V3， V316， S3…)，但没有一个包含 NPU (又名 AI 加速器)。现在这已经改变了，Allwinner V831 Cortex A7 全高清摄像头 SoC 还包括一个小的 200 GOPS NPU 。 > 取自 [allwinner v831 ai full hd camera soc powers sochip v831 development board](https://www.cnx software.com/2020/04/28/allwinner v831 ai full hd camera soc powers sochip v831 development board/) ## v831 Chip ![V831_struct.png](./asserts/V831_struct.png) ## 参数表 项目 参数 备注 CPU 最高 800Mhz Video encoder H.264, up to 1080p@30fps</br>H265, up to 1080p@30fps</br>JPEG, up to 1080p@30fps NPU 0.2T EISE Up to 1080p@30fps SDRAM SIP 64MB DDR2 SIP封装（System In a Package系统级封装） SMHC SMHC x2 (SDC0, SDC1) 主机控制器（SMHC）接口；物理层规范V2.0，SDIO卡规范V2.0 SPI SPI x2 (SPI0, SPI1) LCD Serial RGB, i8080 DSPO BT656 I2S I2S x1 (I2S0) Parallel CSI No support Ethernet 10/100 Mbit/s Ethernet port with RMII TWI TWI x4 (TWI0, TWI1, TWI2, TWI3) RSB No support GPADC 1 ch Audio codec Output: LINEOUTP</br>Input: MICIN1P/N MIPI CSI 2 lane, up to 1080p@60fps MIPI DSI No support Package QFN88 [V833／V831 Datasheet V1.0.pdf](https://linux sunxi.org/images/b/b9/V833%EF%BC%8FV831_Datasheet_V1.0.pdf) ## 产品技术支持 M2dock开发板可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务。"},"/hardware/zh/maixII/M2/other.html":{"title":"其他事项","content":" title: 其他事项 keywords: MaixII, MaixPy3, Python, Python3, M2dock desc: maixpy 其他事项 > 编辑于 2022年8月23日 这里讲述 V831 开发板的一些额外使用事项和相关解决方法 以下替换设备相关操作完成后，名称为 `maixhub` 的镜像里的 app 应用不再可用 ## 切换屏幕 目前开发板支持的屏幕有 1.3寸、2.4寸、2.8寸 的 IPS 屏，且只是支持在[我们淘宝](https://sipeed.taobao.com/)上售卖的显示屏；对于别的屏幕有需求的，可以走商务通道进行定制。 ### 准备 需要切换的屏幕与对应的转接板 开发板 最新[系统镜像](./flash.html) ### 屏幕连接 开发板可以直接与 1.3寸 屏幕连接，但是与 2.4寸 或 2.8寸 屏幕连接的话需要使用转接板 转接板上的接口一个 1 的标识符，是来确保不被反插的。屏幕排线上的 1 要和转接板、开发板的上 1 相位置对应。 屏幕标识的 1 如下所示 <html> <img src \"./asserts/other/1.3.png\" width 45%> <img src \"./asserts/other/2.4.jpg\" width 45%> </html> 转接板上面的 1 如下所示 <img src \"./asserts/other/change.jpg\" width 600> 板子上的 1 如下所示 <img src \"./asserts/other/V831.jpg\" width 600> 具体接线参考下面两张图 <html> <img src \"./asserts/other/not connected.jpg\" width 45%> <img src \"./asserts/other/connected.jpg\" width 45%> </html> ### 切换设备树 update_dtb 程序是给 Allwinner tina linux 专门写的应用。 编译好的设备树文件，可以在[下载站](https://dl.sipeed.com/shareURL/MaixII/MaixII Dock/SDK/Toolchain)中进行下载 该设备树文件是通过内核编译出来的，不推荐个人用户自行编译。设备树文件命名规则如下： 文件名字 可用屏幕 可用摄像头 : : : : : : sipeed_2.8_240x320_vs3205.dtb 2.8寸 vs3205 sipeed_2.8_240x320_sp2305.dtb 2.8寸 sp2305 sipeed_2.4_240x320_vs3205.dtb 2.4寸 vs3205 sipeed_2.4_240x320_sp2305.dtb 2.4寸 sp2305 sipeed_1.3_240x240_vs3205.dtb 1.3寸 vs3205 sipeed_1.3_240x240_sp2305.dtb 1.3寸 sp2305 sipeed_1.3_240x240_ov2685.dtb 1.3寸 ov2685 将设备树文件存放到开发板中在电脑中显示的虚拟U盘中。 接着在 adb 终端里面执行下面命令 ```bash sync #刷新一下文件 update_dtb /dev/mmcblk0 /root/sipeed_240x240_vs3205.dtb reboot #重启设备来更新配置 ``` 即可切换设备树。 如果发现屏幕显示效果不对 说明选错了对应的设备树文件。重新换成正确的设备树即可 这里贴一张正常显示的图样 ![show](./asserts/show.jpg) ## 更换摄像头 目前 MaixII Dock 开发板目前支持的摄像头有 sp2305、vs3205、ov2685（只支持在官方店上再售卖的摄像头，有别的摄像头需求可以进行商务定制），摄像头之间的切换同样时需要更换设备树文件，更换方式上面的更换屏幕一样的。 ### 准备 需要切换的摄像头模块 开发板 最新的[系统镜像](./flash.html) 编译好的设备树文件，可以在[下载站](https://dl.sipeed.com/shareURL/MaixII/MaixII Dock/SDK/Toolchain)中进行下载 ### 连接摄像头 > **注意的是要摄像头的接法，不要把摄像头给接反了，摄像头的底板上有一个白点，开发板卡上也有一个白点，这两个白点要在同一边。如果接反了，摄像头烧毁了请自行再买一个吧** <html> <div class \"imbox\"> <img src \"./asserts/other/camera_outlook_1.jpg\" width 350 alt \"camera top\"> <img src \"./asserts/other/camera_outlook_2.jpg\" width 350 alt \"camera bottom\"> </div> </html> ### 切换设备树 > update_dtb 程序是给 Allwinner tina linux 专门写的小工具。 将设备树文件存放到开发板中在电脑中显示的虚拟U盘中。 接着在 adb 终端里面执行下面命令 ```bash sync #刷新一下文件 update_dtb /dev/mmcblk0 /root/sipeed_240x240_vs3205.dtb reboot #重启设备来更新配置 ``` 即可切换设备树，该设备树文件是通过内核编译出来的，不推荐个人用户自行编译 文件名字 可用屏幕 可用摄像头 : : : : : : sipeed_2.8_240x320_vs3205.dtb 2.8寸 vs3205 sipeed_2.8_240x320_sp2305.dtb 2.8寸 sp2305 sipeed_2.4_240x320_vs3205.dtb 2.4寸 vs3205 sipeed_2.4_240x320_sp2305.dtb 2.4寸 sp2305 sipeed_1.3_240x240_vs3205.dtb 1.3寸 vs3205 sipeed_1.3_240x240_sp2305.dtb 1.3寸 sp2305 sipeed_1.3_240x240_ov2685.dtb 1.3寸 ov2685 ## 编译链 在[下载站](https://dl.sipeed.com/shareURL/MaixII/MaixII Dock/SDK/Toolchain)里有一个名为 `toolchain sunxi musl pack 2021 01 09.tar.xz` 的文件，这是在 Linux 系统下为 V831 所使用的编译链。 有需求的可以自行尝试，但是对于 V831 还是推荐使用 MaixPy3 和 MaixHub。"},"/hardware/zh/maixII/M2/flash.html":{"title":"MaixII-Dock 烧录系统","content":" title: MaixII Dock 烧录系统 keywords: MaixII, MaixPy3, Python, Python3, M2dock desc: maixpy MaixII M2dock 烧录系统 > 编辑时间2022.04.27 文档更新时间 负责人 更新内容 : : : : : : 2021.03.20 大老鼠 新建文档，开始编写内容 2021.12.8 Rui & 点灯鼠 整理并更新烧录方式 2022.3.8 Rui 修改烧录的注意事项 注意事项！！！ 1、非必要的情况下，请不要随意镜像烧录。 2、部分 AMD 平台的电脑存在无法烧录的情况 3、不能保证所有的卡都可以成功的烧录镜像，所以建议用户直接购买官方的镜像卡 ## 获取镜像文件 从下载站获取最新的 V831 系统镜像 [SDK_MaixII/release](https://dl.sipeed.com/shareURL/MaixII/MaixII Dock/SDK/release) ,得到一个压缩包，解压之后就得到一个 .img 文件，这个就是系统镜像文件 > 如果下载站下载的很慢，建议使用百度网盘进行下载，下载站的下载带宽有限。链接：[点我](https://pan.baidu.com/s/1Yrqpk26BL3sOCm4P1cMpBQ)，提取码 `v831` ### 镜像文件命名说明 对于 V831 的镜像文件名字是有对应的规则，以后大家可以根据自己的需求来进行下载 就拿`v831 m2dock maixhub 0.5.1 20220701.zip`和 ` v831 m2dock maixpy3 0.5.1 20220701.zip` 这两个镜像文件来说 名称 含义 maixpy3 0.5.1 此镜像是给 [MaixPy3](https://wiki.sipeed.com/maixpy3) 专用，并内置了`0.5.1`的版本，但其中 **无** 内置 maixhub app maixhub 0.5.1 此镜像是给 [MaixPy3](https://wiki.sipeed.com/maixpy3) 专用，并内置了`0.5.1`的版本，但其中 内置 maixhub app m2dock 可使用 MaixII Dock 开发板平台 20220701 镜像更新日期 > 上述镜像均为开源版，只适用于 TF 卡烧录启动 ## Windows 上使用 PhoenixCard 烧录镜像 PhoenixSuit 和 PhoenixCard 是常用来烧录全志科技芯片的两种工具，前者通过 USB 烧录到板载的 flash，后者用于烧录镜像到 TF 卡中。 零售开源版的 M2 模组上没有焊接 Flash，因此需要使用 TF 卡来作为启动介质，需要用 PhoenixCard 烧录镜像到 TF 卡中来启动 ### 准备工作 1. 烧录工具 [PhoenixCard](https://dl.sipeed.com/shareURL/MaixII/MaixII Dock/SDK/tools) 2. 系统 [镜像](https://dl.sipeed.com/shareURL/MaixII/MaixII Dock/SDK/release) 3. 内存卡格式化工具 [SD Card Formatter](https://www.sdcard.org/downloads/formatter/eula_windows/SDCardFormatterv5_WinEN.zip) ### 系统烧录 1. 将内存卡通过读卡器接到电脑的 USB 口，如果弹出格式化通知的话，点击取消即可 ![windows_format_tf](./asserts/windows_format_tf.png) 2. 打开 SD Card Formatter 软件，对内存卡进行格式化。Refresh（刷新）后点击Format（格式化），注意不要格式化错了分区。 ![image 20210802102810041](./../../../assets/maixII/V831/image 20210802102810041.png) 3. 打开PhoenixCard 选择 `启动卡` 选项 选择正确的盘符 点击 `烧卡` 根据状态栏的颜色可以判断烧录结果：红色的话说明烧录失败了，建议使用[SD card Formatter](https://www.sdcard.org/downloads/formatter/eula_windows/SDCardFormatterv5_WinEN.zip)格式化后再重新烧录一次；绿色表示则一切正常。 ![image 20210802104155132](./../../../assets/maixII/V831/image 20210802104155132.png) ## Linux(Ubuntu) 使用 Livesuit 烧录 ### 安装烧录工具 Livesuit > **每次更新系统 linux kernel 之后需要重新安装软件** 1. 安装依赖 dkms ```shell sudo apt install dkms ``` 1. 安装 libpng1.2（一定要使用这个版本） ```shell wget http://archive.ubuntu.com/ubuntu/pool/main/libp/libpng/libpng_1.2.54.orig.tar.xz tar xvf libpng_1.2.54.orig.tar.xz ``` ```shell cd libpng 1.2.54 ./autogen.sh ./configure make j8 sudo make install ``` 更新链接库: ```shell sudo ldconfig ``` 1. 安装 **livesuit** ```shell git clone https://github.com/linux sunxi/sunxi livesuite.git cd sunxi livesuite chmod +x LiveSuit.sh sudo ./LiveSuit.sh ``` ### 使用 Livesuit 烧录 `sudo livesuit` 打开烧录工具，并点击“固件”选择镜像文件 ![](./asserts/flash_15.png) 不插入 SD 卡，将 V831 USB OTG 接口连接到 PC, 提示是否格式化分区，这时候插入 SD 卡，之后点击 `YES` ![](./asserts/flash_17.png) 等待烧录完成，提示“固件升级成功”，即可断开 USB ，至此固件烧录完毕 ![](./asserts/flash_19.png) ![](./asserts/flash_21.png) ## 附录 ### 烧录系统到 flash 中 [烧录方式](./no_sd_flash.html) ### 无读卡器烧录方式 [烧录方式](./PhoenixSuit.html) ### 使用 dd 烧录 官方没有做 MaixII Dock 的 dd 镜像相关支持，有需要的可以自行去学习如何制作 dd 镜像的[制作](https://www.cnblogs.com/USTHzhanglu/p/15431249.html)。"},"/hardware/zh/maixII/index.html":{"title":"Maix-II 系列硬件产品","content":"Maix II 系列硬件产品 ## Maix II 简介 继经典的 K210 Maix I 系列 AIOT 板卡之后，Sipeed 继续推出多款可运行完整 Linux 系统的边缘计算板卡，将以 MAIX II，MAIX III 按照性能依次命名。 MAIX II 系列包含多款硬件产品，目前有: * **Maix II Dock**： **本系列推荐产品**, 芯片为全志 V831, 高性价比能跑 Linux 的SOC，同时支持硬件 AI 加速（0.2Tops 算力），目前软件支持最容易入门，提供 C SDK 和 Python SDK， 以及在线模型训练服务([MaixHub](https://maixhub.com)) * **MaixSense**： 芯片为全志R329，也有提供硬件 AI 加速，0.25Tops 算力。 * **Maix II S**：芯片为全志 V833，V831 升级版， 主要用于商业定制用途，个人用户慎重选择。 ## MaixII Dock 芯片为全志 V831, 单核 Cortex A7 800MHz， 64MiB 片内 DDR2 内存， 高性价比能跑 Linux 的SOC，同时支持硬件 AI 加速（0.2Tops 算力），可以当成普通 Linux SOC 使用， 也可以用于边缘 AI 应用。 **本系列推荐产品**, 最具性价比， 目前软件支持最容易入门， 支持 C 语言开发，提供 C SDK([libmaix](http://github.com/sipeed/libmaix))； 同时提供 [MaixPy3](/maixpy3) 支持，使用 Python 语言即可开发，可以直接使用大量 Python 库，并且配套 jupyter IDE， 同时 [MaixHub](https://maixhub.com) 完全支持此设备 * 产品功能速览 <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 298543445&bvid BV1sF411u7xb&cid 586467021&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> </p> * 实拍图： ![m2dock](../../assets/maixII/m2dock.jpg) * 购买链接: [sipeed.taobao.com](https://item.taobao.com/item.htm?ft t&id 635874427363) * 详情： [MaixII Dock](./M2/resources.html) ## MaixSense 芯片为全志 R329，双核 A53@1.5GHz，片内 256MiB DDR3 内存，双核 HiFi4@400MHz 也有提供硬件 AI 加速，0.25Tops 算力， 更加擅长音频领域， 支持 armbian 系统。 官方开放资料很多，目前比较适合动手能力比较强的开发者。 ![](./M2A/assets/M2A 1.gif) * 购买链接: [sipeed.taobao.com](https://sipeed.taobao.com) * 详情： [MaixSense](./M2A/maixsense.html) ## MaixII S 可以理解成 V831 的性能升级版， V831 上的程序可以直接在 V833 上运行，此开发板仅支持商业用户，个人用户建议选择 Maix II Dock 开发板 <img style \"max height: 300px\" src \"./M2S/assets/M2s_Dock.jpg\" alt “M2s_Dock”/> * 详情： [MaixII S](./M2S/V833.html)"},"/hardware/zh/maixII/M2S/reources.html":{"title":"M2S介绍","content":"# M2S介绍 MaixII S是基于 V833 芯片设计的一款【板卡】+【底板】的开发板产品。 ## 板卡 ![](./assets/M2s_Dock.jpg) > 资料[下载](https://dl.sipeed.com/shareURL/MaixII/MaixII A) ### 参数 项目 参数 CPU 全志 V833 Arm Cortex A7 1.2Ghz 主频 NPU 0.4TOPS 算力 内存 标配单片 16bit 128MB DDR3（可选最大 16bit 512MB DDR3） 存储核心板板载 128MB SD NAND（可选 512MB 和 4GB）底板板载 TF 卡座子，可扩展存储 摄像头接口MIPI：标配 200W 像素可见光摄像头(可选配宽动态摄像头)，76 度视场角<br>DVP：标配 30W 像素红外摄像头 补光灯接口 板载 2 个 DC DC 恒流降压驱动电路+2 个 2P 1.25mm 卧贴母座 <br>（每路最大驱动能力达到 5V 0.5A） 显示屏幕接口 MIPI：默认引出 4 lane MIPI 接口，已适配 5 寸和 7 寸屏 触摸屏接口 6P 0.5mm FPC 座子：可以连接电容触摸屏或者电阻触摸屏，目前已适配 GT911 音频接口 板载 3W 单声道音频功放，有 2P 1.25mm 卧贴母座可以连接喇叭 <br>板载驻极体麦克风电路，有 2P 1.25mm 卧贴母座可以连接麦克风 以太网 板载百兆 PHY 和百兆网口变压器，有 6P 1.25mm 卧贴母座可以连接以太网口 继电器 板载继电器，触电切换能力 2A 30VDC RTC 实时时钟 板载专用 RTC 芯片+1220 纽扣电池座子 按键 • 复位按键<br>• FEL 按键（进入下载模式）<br>• 2 个用户可编程按键（可以用作防拆报警键等自定义功能） 扩展接口 <br>• 4P 座子：1 组 UART、1 组 485、1 组 USB、1 组 IIC<br>• 9P 座子：2 个供电引脚+2 个继电器引脚+1 个按键的 2 引脚+2 个信号引脚<br>• 9P 座子：7 个信号引脚（可以复用为 1 组 SPI 总线+多个 CS 脚）+2 个电源引脚<br>• 9P 座子：6 个信号引脚+3 个电源引脚 ## 产品技术支持 M2S开发板可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maixII/M2S/V833.html":{"title":"M2S核心介绍","content":"# M2S核心介绍 ## V833 Chip V833智能视觉AI专用处理器是基于存算紧耦AI引擎的视频识别处理器，采用业界优秀的半导体工艺，创新突破了存算紧耦架构、神经网络权重量化技术、人脸检测技术和人脸图像质量评估技术、图像畸变矫正技术、图像防抖技术和可变帧率的编码技术等关键技术，有效地解决了神经网络计算复杂度高、网络性能差、人脸检测效率低和准确度不高、广角和鱼眼镜头的图像畸变、智能识别/安防产品功耗高等问题，综合技术水平达国内优秀水平，是一款能耗低、运算效率高、检测效率高、图像效果佳的人工智能视频识别处理器。 > 取至<http://www.elecfans.com/d/1557234.html> ![](./assets/V833.png) ## 参数 项目 参数 CPU 单核Cortex A7@1.2GHz Video encoder H.264, up to 5M@20fps<br>H.265, up to 5M@30fps <br>JPEG, up to 1080p@60fps NPU 0.4T EISE Up to 1080p@60fps SDRAM DDR2/DDR3/DDR3L SMHC SMHC x3 (SDcO, SDC1, SDC2) SPI SPI x3 (SPIO with 2 CS, SPIO supportsquad output/quad input SPl mode) LCD Parallel RGB, Serial RGB, i8080 DSPO BT1120,BT656 l2S l2S x2 (12S0,I2S1) Parallel CSI Support Ethernet 10/100/1000 Mbit/s Ethernet port with RGMll and RMll interfaces TWI TWI x5 (TWIO,TWI1,TWI2,TWI3,s_TwWIO) RSB support GPADC 2 ch Audio codec Output : LINEOUTP/N<br>Input: MICIN1P/N, LINEINL MIPI CSI 4 lane, up to 8M@30fps MIPI DSI Support Package LFBGA273 "},"/hardware/zh/maix/index.html":{"title":"Sipeed Hardware","content":" title: Sipeed Hardware keywords: Sipeed, Hardware, 矽速, 硬件资料, 文档, 资料下载 desc: 矽速科技的硬件资料站 # Maix—I [English](./../../en/maix/index.html) ## K210 核心模组 [M1/M1w](./core_module.html) [M1n](./core_modules/k210_core_modules.html) ## Maix 系列开发板 <table role \"table\" class \"center_table\"> <tbody> <tr> <th scope \"col\">型号</th> <th scope \"col\">图片</th> </tr> <tr> <td> Maix Go</td> <td><a href \"./maixpy_develop_kit_board/maix_go.html\" target \"_blank\"><img src \"./assets/dk_board/maix_go/Go.jpg\" width \"260\"></a></td> </tr> <tr> <td>Maix Dock</td> <td><a href \"./maixpy_develop_kit_board/Maix_dock.html\" target \"_blank\"><img src \"./assets/dk_board/maix_dock/Dan_Dock.png\" width \"260\"></a></td> </tr> <tr> <td>Maix Duino</td> <td><a href \"./maixpy_develop_kit_board/maix_duino.html\" target \"_blank\"><img src \"./assets/dk_board/maix_duino/maixduino_0.png\" width \"260\"></a></td> </tr> <tr> <td>Maix Bit</td> <td> <a href \"./maixpy_develop_kit_board/maix_bit.html\" target \"_blank\"><img src \"./assets/dk_board/maix_bit/Bit.png\" width \"260\"></a> </td> </tr> <tr> <td>Maix Cube</td> <td><a href \"./maixpy_develop_kit_board/maix_cube.html\" target \"_blank\"><img src \"./assets/dk_board/maix_cube/maix_cube.png\" width \"260\"></a></td> </tr> <tr> <td>Maix Amigo</td> <td><a href \"./maixpy_develop_kit_board/maix_Amigo.html\" target \"_blank\"><img src \"./assets/dk_board/maxi_amigo/maix_amigo_0.png\" width \"260\"></a></td> </tr> <tr> <td>Maix nano</td> <td><a href \"./maixpy_develop_kit_board/maix_nano.html\"><img src \"./assets/dk_board/maix_nano/maix_nano.jpg\" width \"260\" alt \"Maxi nano\"></a></td> </tr> </tbody> </table> ## 产品技术支持 Maix系列产品可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maix/m1s/m1s_module.html":{"title":"M1s 模组","content":" title: M1s 模组 keywords: M1s ,模组, bl808, BL808 update: date: 2022 11 09 version: v0.2 author: wonder content: 修改部分描述错误 增加注意事项 增加软件描述栏目 date: 2022 10 18 version: v0.1 author: wonder content: 初次编写文档 ## 模组概述 Sipeed M1s 模组是基于[博流智能科技](http://www.bouffalolab.com/)的 BL808 芯片所设计的一款 AIOT 模组，主控芯片包含三个核心，具有 WiFi/BT/BLE/Zigbee 等无线互联单元，包含多个 CPU 以及音频编码译码器、视频编码译码器和 AI 硬件加速器（BLAI 100），适用于各种高性能和低功耗应用领域。 购买链接：[淘宝](https://item.taobao.com/item.htm?id 691108452443) <img src \"./assets/m1s_module/m1s_module_outlook.png\" alt \"m1s_module_outlook\" width 35%> ## 模组特点 主芯片 BL808 RV64 480MHz + RV32 320MHz + NPU BLAI 100GOPS 板载 SPI FLASH（默认 16MByte） 支持 2.4G WIFI / BT / BLE 支持 IPEX 一代天线座子和 PCB 板载天线 邮票孔引出所有 IO ## 模组参数 <table> <thead> <tr> <th colspan \"2\" > M1s 模组 </th> </tr> </thead> <tbody> <tr> <td rowspan \"8\" style \"white space:nowrap\">主控 BL808 处理器</td> </tr> <tr> <td>三核异构RISC V CPUs：<br>· RV64GCV 480MHz <br>· RV32GCP 320MHz <br>· RV32EMC 160MHz</td> </tr> <tr> <td>AI NN 通用硬件加速器：<br>· BLAI 100 用于视频/音频检测/识别，100GOPS 算力</td> </tr> <tr> <td>内置 768KB SRAM + 64MB UHS PSRAM</td> </tr> <tr> <td>编解码：<br> MJPEG and H264(Baseline/Main)<br> 1920x1080@30fps + 640x480@30fps </td> </tr> <tr> <td>接口：<br> 摄像头接口 ：DVP 和 MIPI CSI<br> 显示接口：SPI、DBI、DPI(RGB)</td> </tr> <tr> <td>无线：<br> 支持 Wi Fi 802.11 b/g/n<br> 支持 Bluetooth 5.x Dual mode(BT+BLE)<br> 支持 Wi Fi / 蓝牙 共存</td> </tr> <tr> <td>USB 2.0 HS OTG</td> </tr> <tr> <td rowspan \"3\" style \"white space:nowrap\"> 板载部件 </td> </tr> <tr> <td>板载 SPI FLASH（可选容量）</td> </tr> <tr> <td>支持 IPEX 一代天线座子和 PCB 板载天线</td> </tr> </tbody> <tr> <td rowspan \"6\" style \"white space:nowrap\"> 其他说明 </td> </tr> <tr> <td> 尺寸：31mm (L) x 18mm (W) </td> </tr> <tr> <td> 3D 模型文件下载：<a href \"https://dl.sipeed.com/shareURL/MAIX/M1s/M1s/5_3D_file\">点击跳转</a> </td> </tr> <tr> <td>外部供电需求：<br>VDDIO4/VDDIO3/VDDIO1/ 和 3V3 这几路电源必须给模块提供才能正常工作</td> </tr> <tr> <td>温升: &lt;30K</td> </tr> <tr> <td>工作温度范围: 10℃ ~ 65℃</td> </tr> </tbody> </table> <img src \"./assets/m1s_module/m1s_module_size.png\" alt \"m1s_module_size\" width 35%> ## 主控核心 三核异构 M0，D0，LP。 M0 D0 LP 平头哥 [E907](https://occ.t head.cn/product?id 3900588052540035072)@320MHz 平头哥 [C906](https://occ.t head.cn/product?id 3817197695983423488)@480MHz 平头哥 [E902](https://occ.t head.cn/product?id 3806460569050419200)@160MHz ## 引脚分布 前往原理图查看：[点我](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s/2_Schematic) <! <img src \"./assets/m1s_module/m1s_pins.png\" alt \"m1s_pins\" width 55%> > ## 产品对比 <table> <thead> <tr> <th style \"text align:left\">项目</th> <th style \"text align:left\">M1(K210)</th> <th style \"text align:left\">M1s(BL808)</th> <th style \"text align:left\">ESP32 S3 WROOM N16R8</th> </tr> </thead> <tbody> <tr> <td style \"text align:left\">CPU</td> <td style \"text align:left\">RV64@400MHz x2</td> <td style \"text align:left\">· RV64GCV@480MHz<br>· RV32GCP@320MHz<br>· RV32EMC@160MHz</td> <td style \"text align:left;white space:nowrap\">Xtensa LX7@240MHz x2</td> </tr> <tr> <td style \"text align:left\">RAM</td> <td style \"text align:left\">8MB SRAM</td> <td style \"text align:left;white space:nowrap\">· 768KB SRAM <br>· 64MB UHS PSRAM(2000MHz)</td> <td style \"text align:left\">· 512KB SRAM<br>· 8MB PSRAM</td> </tr> <tr> <td style \"text align:left\">Flash</td> <td style \"text align:left\">16MB</td> <td style \"text align:left\">16MB</td> <td style \"text align:left\">16MB</td> </tr> <tr> <td style \"text align:left\">OS</td> <td style \"text align:left\">· FreeRTOS<br>· No mmu Linux</td> <td style \"text align:left\">· FreeRTOS<br>· Linux</td> <td style \"text align:left\">RTOS</td> </tr> <tr> <td style \"text align:left\">NPU</td> <td style \"text align:left;white space:nowrap\">230GOPS with limited OPS</td> <td style \"text align:left;white space:nowrap\">100GOPS with rich OPS</td> <td style \"text align:left\"></td> </tr> <tr> <td style \"text align:left\">Camera</td> <td style \"text align:left\">DVP, up to VGA</td> <td style \"text align:left\">MIPI + DVP, up to 1080P h264</td> <td style \"text align:left\">DVP</td> </tr> <tr> <td style \"text align:left\">Display</td> <td style \"text align:left\">· SPI<br>· 8bits MCU LCD</td> <td style \"text align:left\">· SPI<br>· 8bits MCU LCD<br>· RGB LCD</td> <td style \"text align:left\">· SPI<br>· 8bits MCU LCD</td> </tr> <tr> <td style \"text align:left\">Audio</td> <td style \"text align:left\">I2S</td> <td style \"text align:left\">· I2S<br>· Analog Audio Input/Output</td> <td style \"text align:left\">I2S</td> </tr> <tr> <td style \"text align:left\">Wireless</td> <td style \"text align:left\"></td> <td style \"text align:left\">WIFI+BLE+Zigbee</td> <td style \"text align:left\">WIFI + BLE</td> </tr> <tr> <td style \"text align:left\">USB</td> <td style \"text align:left\"></td> <td style \"text align:left\">USB2.0 OTG HS</td> <td style \"text align:left\">USB1.1 OTG</td> </tr> <tr> <td style \"text align:left\">Accelerator</td> <td style \"text align:left\">FFT</td> <td style \"text align:left\">· Scaler<br>· OSD<br>· MJPED<br>· G2D<br>· H264</td> <td style \"text align:left\"></td> </tr> <tr> <td style \"text align:left\">Perpheral</td> <td style \"text align:left\">UART, SPI, IIC</td> <td style \"text align:left\">UART, SPI, IIC, SDIO ETH(RMII), ADC/DAC</td> <td style \"text align:left\">UART, SPI, IIC, SDIO, ADC</td> </tr> <tr> <td style \"text align:left\">Size</td> <td style \"text align:left\">25.4 x 25.4 mm</td> <td style \"text align:left\">31 x 18 mm</td> <td style \"text align:left\">25.5 x 18 mm</td> </tr> <tr> <td style \"text align:left\">Price</td> <td style \"text align:left\">$6</td> <td style \"text align:left\">$6</td> <td style \"text align:left\">$4.3(digikey)</td> </tr> </tbody> </table> ## 软件描述 <table> <thead> <tr> <th colspan \"2\" > M1s 模组 </th> </tr> </thead> <tbody> <tr> <td>OS</td> <td>· 完备支持FreeRTOS<br>· 基础支持Linux</td> </tr> <tr> <td>开发方式</td> <td>· 原生C SDK<br>· MaixHAL C 模块<br>· PikaPython </td> </tr> <tr> <td>固件下载</td> <td>· 串口下载<br>· 虚拟磁盘拖拽式更新</td> </tr> <tr> <td>AI 推理框架</td> <td>· 支持原生SDK的BLAI加速推理引擎<br>· 支持通用TinyMaix推理引擎</td> </tr> <tr> <td>AI 模型下载</td> <td>· <a href \"https://maixhub.com/\">MaixHub</a> 下载。支持 人脸检测，识别，姿态检测，手势检测 等</td> </tr> <tr> <td>Sipeed 参考示例</td> <td>· https://gitee.com/sipeed/M1s_BL808_example</td> </tr> </tbody> </table> ## 支持算子列表 <table> <thead> <tr> <th>Type</th> <th>Operators</th> <th>Applicable Subset Spec.</th> <th>Processor</th> </tr> </thead> <tbody> <tr> <td rowspan \"10\">Convolution</td> <td rowspan \"4\">Conv </td> <td>Kernel: 1x1,3x3,5x5,7x7</td> <td rowspan \"4\">:strong:<code>NPU</code></td> </tr> <tr> <td>Stride: 1x1, 2x2</td> </tr> <tr> <td>Dilation: 1x1, 2x2</td> </tr> <tr> <td>Pad: same</td> </tr> <tr> <td rowspan \"4\">Depthwise Conv</td> <td>Kernel: 1x1,3x3 (5x5, 7x7 TBD)</td> <td rowspan \"4\">:strong:<code>NPU</code></td> </tr> <tr> <td>Stride: 1x1, 2x2</td> </tr> <tr> <td>Dilation: 1x1 (2x2 TBD)</td> </tr> <tr> <td>Pad: same</td> </tr> <tr> <td rowspan \"2\">Transpose Conv</td> <td>Kernel: 3x3</td> <td rowspan \"2\">strong:<code>NPU</code></td> </tr> <tr> <td>Stride: 2x2</td> </tr> <tr> <td rowspan \"4\">Pooling</td> <td rowspan \"2\">MaxPool (NPU TBD)</td> <td>Kerenl: 2x2</td> <td rowspan \"2\">DSP</td> </tr> <tr> <td>Stride: 2x2</td> </tr> <tr> <td rowspan \"2\">MaxPool</td> <td>Kerenl: 3x3</td> <td rowspan \"2\">:strong:<code>NPU</code></td> </tr> <tr> <td>Stride: 1x1, 2x2</td> </tr> <tr> <td rowspan \"2\">Activation</td> <td>Relu</td> <td></td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Relu 6</td> <td></td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td rowspan \"5\">Other processing</td> <td>BatchNormalization</td> <td>fused with conv</td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Add (shortcut)</td> <td></td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Concat (route)</td> <td>Channel wise (AXIS 3 in BHWC)</td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Fully Connected</td> <td></td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Upsample</td> <td>Nearest</td> <td>:strong:<code>NPU</code></td> </tr> </tbody> </table> ## 模组资料 [模组规格书](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s/1_Specification) [模组原理图](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s/2_Schematic) [模组封装库](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s/7_Package) [模组点位图](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s/3_Bit_number_map) [模组尺寸图](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s/4_Dimensional_drawing) [3D 模型文件](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s/5_3D_file) [模组芯片数据手册](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s/6_Chip_Manual) [博流官方文档](https://dev.bouffalolab.com/home/) [BL808 数据手册](https://gitee.com/wonderfullook/bl_docs/tree/main/BL808_DS/zh_CN) (gitee) [BL808 参考手册](https://gitee.com/wonderfullook/bl_docs/tree/main/BL808_RM/zh_CN) (gitee) [Sipeed SDK](https://gitee.com/sipeed/M1s_BL808_SDK) (gitee) [Sipeed Examples](https://gitee.com/sipeed/M1s_BL808_example)（gitee） [Bouffalolab SDK](https://github.com/bouffalolab/bouffalo_sdk)（Github） [Linux SDK](https://github.com/sipeed/M1s_BL808_Linux_SDK)（Github） 交流 QQ 群：`592731168` 。[点我加群](https://jq.qq.com/?_wv 1027&k uyKNhTeu) 论坛：[bbs.sipeed.com](https://bbs.sipeed.com/) [在线模型平台](https://maixhub.com/) ## 注意事项 <table> <tr> <th>项目</th> <th>注意事项</th> </tr> <tr> <td>静电防护</td> <td>请避免静电打到 PCBA 上；接触 PCBA 之前请把手的静电释放掉</td> </tr> <tr> <td>容忍电压</td> <td> 每个 GPIO 的工作电压已经在原理图中标注出来，请不要让 GPIO 的实际工作的电压超过额定值，否则会引起 PCBA 的永久性损坏 </td> </tr> <tr> <td>FPC 座子</td> <td>在连接 FPC 软排线的时候，请确保排线无偏侈地完整地插入到排线中</td> </tr> <tr> <td>插拔</td> <td>请完全断电后才进行插拔操作</td> </tr> <tr> <td>避免短路</td> <td>请在上电过程中，避免任何液体和金属触碰到 PCBA 上的元件的焊盘，否则会导致路，烧毁 PCBA</td> </tr> <tr> <td>设计建议</td> <td>为该模组设计底板时，建议先看这个帖子 <a href \"https://bbs.sipeed.com/thread/1721\">https://bbs.sipeed.com/thread/1721</a></td> </tr> <tr> <td>BANK 划分</td> <td> VDDIO1：GPIO 0 8，1.8V/3.3V<br> VDDIO2：GPIO 11 15，GPIO 40 41, 3.3V only<br> VDDIO3：GPIO 16 23，1.8V/3.3V<br> VDDIO4：GPIO 24 39，1.8V/3.3V<br> </td> </tr> <tr> <td>BOOT 模式选择</td> <td> 在启动时，芯片判定 BOOT 引脚的电平，选择两个启动选项之一<br> · BOOT 高电平：从 FLASH 存储启动 · BOOT 低电平：进入串口下载模式 </td> </tr> </table> ## 联系方式 M1s 模组可以在多种场景实现客户不同方面的需要，技术支持和商业合作请联系使用邮箱 [support@sipeed.com](support@sipeed.com)"},"/hardware/zh/maix/m1s/other/others.html":{"title":"M1s DOCK 安装外壳","content":" title: M1s DOCK 安装外壳 keywords: M1s DOCK ,BL808, M1s update: date: 2022 11 22 version: v0.1 author: wonder content: 新建文档 这里说明一下摄像头和屏幕的拆装方法，并补充下外壳的安装方法。 ## 拆卸屏幕 默认发货的板卡的摄像头和屏幕是同一方向的，有时候因为一些原因比如调整摄像头方向需要拆卸屏幕，这里写一下注意事项。 屏幕与摄像头同向 摄像头放在背部 ![screen_camera_same](./assets/others/screen_camera_same.jpg) ![camera_in_back](./assets/others/camera_in_back.jpg) 屏幕与板卡是通过泡沫胶粘在一起的，因此拆卸屏幕的时候需要撕开泡沫胶。这时需要注意应该对屏幕背板的金属层用力，而不是扣屏幕边缘。 <table> <tr> <td><img alt \"sponge_glue_strip\" src \"./assets/others/sponge_glue_strip.jpg\" width \"150%\"></td> <td><img alt \"sponge_glue_strip_top\" src \"./assets/others/sponge_glue_strip_top.jpg\" width \"150%\"></td> <td>旁边两张图可以看到<br>屏幕与板子是通过泡沫胶粘在一起的</td> </tr> </table> <table> <tr> <td><img alt \"screen_back_plane\" src \"./assets/others/screen_back_plane.png\" width \"150%\"></td> <td>中间为屏幕背板金属层，<br>旁边的黑色部分为屏幕边缘，<br>拆卸的时候后需要对屏幕背板金属层用力</td> </tr> </table> <table> <tr> <td><img alt \"screen_connector\" src \"./assets/others/screen_connector.jpg\" ></td> <td>打开后注意屏幕与板子的连接方式如左图所示，<br>不要连接反了</td> </tr> </table> ## 更换摄像头方向 进行完前面的[拆卸屏幕](#拆卸屏幕)后，可以将摄像头调整的前后方向了。 唯一要注意的就是在连接摄像头排线的时候别接反了。 <table> <tr> <td><img alt \"camera_direction_connector\" src \"./assets/others/camera_direction_connector.jpg\" ></td> <td>连接的时候注意将摄像头上的 1 与板子上的 1 对上就行</td> </tr> </table> ## 安装外壳 在购买 M1s Dock 的时候可以选购外壳，这里补充一下组装方法。 摄像头有两个方向可以自行选择，下面会进行说明。 拆成散件，首先要讲板子的屏幕和摄像头都拆下来，并且把外壳打开。参考下图排布方式。 ![parts](./assets/others/parts.jpg) 摄像头有前后两种组装方式，分别是摄像头拍摄方向与屏幕相同和拍摄方向与屏幕相反。 ### 屏幕与摄像头方向相同 <table> <tr> <td><img alt \"insert_camera_front_1\" src \"./assets/others/insert_camera_front_1.jpg\" ></td> <td><img alt \"insert_camera_front_2\" src \"./assets/others/insert_camera_front_2.jpg\" ></td> <td>首先将摄像头嵌入在外壳里面，正常组装上之后摄像头会被轻微固定在外壳上，确保安装的时候无偏移，摄像头居中。</td> </tr> </table><br> <table> <tr> <td><img alt \"insert_screen_side_1.jpg\" src \"./assets/others/insert_screen_side_1.jpg\" ></td> <td><img alt \"insert_screen_side_2.jpg\" src \"./assets/others/insert_screen_side_2.jpg\" ></td> <td>板子与屏幕连接好后，将屏幕穿过外壳</td> </tr> </table><br> <table> <tr> <td>旋转外壳使板子上的 TF 卡槽<br>与外壳上的 SiPEED logo 同方向</td> <td>将两个 TypeC 口对准壳子上的孔，准备安装板子进外壳</td> <td>按压箭头指向的地方，首次按压的时候有一点紧，注意对准 TypeC 口。安装板子进入外壳</td> </tr> <tr> <td><img alt \"insert_screen_direction_1\" src \"./assets/others/insert_screen_direction_1.jpg\" ></td> <td><img alt \"insert_screen_direction_2\" src \"./assets/others/insert_screen_direction_2.jpg\" ></td> <td><img alt \"insert_screen_direction_3\" src \"./assets/others/insert_screen_direction_3.jpg\" ></td> </tr> </table><br> <table> <tr> <td><img alt \"insert_camera_interface\" src \"./assets/others/insert_camera_interface.jpg\" ></td> <td><img alt \"insert_camera_interface_1\" src \"./assets/others/insert_camera_interface_1.jpg\" ></td> <td>将摄像头排线弯曲，注意不是折叠，是弯曲。穿过板子的预留孔，连接上背面的座子。</td> </tr> </table><br> <table> <tr> <td>使用壳子上的双面胶固定好屏幕，背板固定在背部，注意背板的预留摄像头孔应对着模组。</td> <td><img alt \"fix_screen\" src \"./assets/others/fix_screen.jpg\" ></td> <td><img alt \"fix_panel\" src \"./assets/others/fix_panel.jpg\" ></td> </tr> </table><br> 到此就已经组装完毕了。 ### 屏幕与摄像头方向不同 <table> <tr> <td><img alt \"opposite_screen\" src \"./assets/others/opposite_screen.jpg\" ></td> <td><img alt \"opposite_cam\" src \"./assets/others/opposite_cam.jpg\" ></td> <td>首先将摄像头和屏幕安装到板子上，摄像头应与模组同方向</td> </tr> </table><br> <table> <tr> <td>将板子穿过壳子</td> <td>最终结果如下</td> <td>调整方向让板子的 TF 卡槽与壳子上的 SiPEED logo 方向相同</td> </tr> <tr> <td><img alt \"opposite_insert_screen_1\" src \"./assets/others/opposite_insert_screen_1.jpg\" ></td> <td><img alt \"opposite_insert_screen_2\" src \"./assets/others/opposite_insert_screen_2.jpg\" ></td> <td><img alt \"opposite_insert_screen_3\" src \"./assets/others/opposite_insert_screen_3.jpg\" ></td> </tr> </table><br> <table> <tr> <td>将两个 TypeC 口对准壳子上的孔，准备自装板子进外壳</td> <td>按压箭头指向的地方，首次按压的时候有一点紧，注意对准 TypeC 口。安装板子进入外壳</td> </tr> <tr> <td><img alt \"insert_screen_direction_2\" src \"./assets/others/insert_screen_direction_2.jpg\" ></td> <td><img alt \"insert_screen_direction_4\" src \"./assets/others/insert_screen_direction_4.jpg\" ></td> </tr> </table><br> <table> <tr> <td colspan \"3\">将摄像头穿过外壳，慢慢的滑动外壳来刚好将摄像头固定在板子模组上</td> </tr> <tr> <td><img alt \"opposite_fix_cam_1\" src \"./assets/others/opposite_fix_cam_1.jpg\" ></td> <td><img alt \"opposite_fix_cam_2\" src \"./assets/others/opposite_fix_cam_2.jpg\" ></td> <td><img alt \"opposite_fix_cam_3\" src \"./assets/others/opposite_fix_cam_3.jpg\" ></td> </tr> </table> 安装好屏幕，到这里就已经完成组装了。 ![opposite_fix_screen](./assets/others/opposite_fix_screen.jpg) ## 拆卸外壳 首先在屏幕背面，使用镊子或其他工具翘起来外壳，将其取下。 ![disassemble_shell](./assets/others/disassemble_shell.jpg) 使用镊子，在外壳 Logo 处的哪个孔哪里，把板子从外壳中翘出来。 <img src \"./assets/others/disassemble_hole.jpg\" alt \"disassemble_hole\" width \"45%\"> <img src \"./assets/others/disassemble_hole_1.jpg\" alt \"disassemble_hole_1\" width \"45%\"> 然后对屏幕的背板用力，将屏幕顶出外壳 ![disassemble_remove_screen](./assets/others/disassemble_remove_screen.jpg) 到此拆卸外壳结束。"},"/hardware/zh/maix/m1s/other/start.html":{"title":"M1s DOCK 上手","content":" title: M1s DOCK 上手 keywords: M1s DOCK ,BL808, M1s update: date: 2023 05 09 version: v0.5 author: wonder content: 默认固件更改 重新编写开箱 新出厂固件不提供 date: 2023 02 27 version: v0.4 author: wonder content: 增加 wifi 串流使用说明 date: 2022 12 20 version: v0.3 author: wonder content: 增加部分blai相关内容 <! date: 2022 12 12 version: v0.2 author: wonder content: 增加部分细节解释 date: 2022 11 23 version: v0.1 author: wonder content: 初次编辑 M1s Dock 设计精巧，可以用来所很多有意思的事，这里简单说明一下一些使用方法。要注意的是串口默认波特率 2000000。 通过板子上的 UART 口连接 PC，在 Windows 系统的设备管理器中显示有两个 Converter 设备。 ![start_bl808_uart_converter](./assets/start/start_bl808_uart_converter.png) > > ## 开箱 下面地开箱说明以 M1S Dock 带屏幕和摄像头的套餐为例。 打开 M1S Dock 的包装盒后，看到里面有如下内容： 一根 USB 数据线 一块 M1S Dock 两条排针 <img src \"./assets/start/unbox_m1s_dock.jpg\" alt \"unbox_m1s_dock\" width \"50%\"> ## 硬件准备 两根 TypeC 数据线 一个 M1s Dock 一台电脑 M1S Dock 搭载有两个 TypeC 接口。默认情况下 UART 口用做于电脑和 M1S Dock 的串口通信，OTG 口默认用于给板子上的 BL808 芯片里面的 C906 核心烧录固件。 <img alt \"m1s_doc_pin_map\" src \"./../assets/m1s_dock/m1s_doc_pin_map.png\"> 1. 上图中可以看到 `S1` 、 `S2` 两个按键，另外还有 `BOOT` 按键和 `RST` 按键 2. 上图中板子的左下角有 UART 口，默认有 USB 转双串口功能连接到 BL808 芯片的两个核心上 3. 上图中板子的右下角有 OTG 口，M1s Dock 默认固件将它作用于烧录 C906 核心的固件。 ## 上电说明 ![m1s_dock_power_supply](./assets/start/m1s_dock_power_supply.png) ## 初次通电 ### 板卡现象 首次对 M1s Dock 板子上电，按下板子上的 RST (复位) 按键。 ![m1s_dock_rst_key_position](./assets/start/m1s_dock_rst_key_position.png) 会有如下现象： ![default_firmware](./assets/start/default_firmware_20230509.png) 按下 ① 处所指向的按键，屏幕上 ④ 处 `btn` 会变成绿色，并且 ⑥ 处的数字会增加，最大为 100 ② 是摄像头，屏幕会默认显示摄像头所拍摄到的画面 按下 ③ 处所指向的按键，屏幕上另一个 `btn` 会变成绿色，并且 ⑥ 处的数字会减小，最小为 0 ⑤ 是出货时所测试的无线 wifi 功能及其强度检测，用户手中此处空白 ⑦ 是板载麦克风测试，麦克风在背面位于板载 LED 的对称位置 另一面的 LED 会闪烁。 ![led_brghtness](./assets/start/led_brghtness.jpg) ### OTG 口现象 > 通过 OTG 口连接 PC 的话会有一个大小为 3M 的 U 盘。 部分电脑可能会因为兼容性问题显示不出来这个 U 盘，但是可以通过[串口烧录](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#%E4%B8%B2%E5%8F%A3%E7%83%A7%E5%BD%95) 来重新烧录一次 M1s Dock 来解决该问题。 ![default_udisk](./assets/start/default_udisk.jpg) 并且在 Windows 的设备管理器中会看到大容量存储设备，在 linux 系统中也会出现一个可移动设备。 ![udisk_device_manager](./assets/start/udisk_device_manager.jpg) 如果没有看到大容量存储设备或者 U 盘在电脑中显示，可以先更换数据线或者链接电脑其他 USB 接口来尝试解决问题，仍然看不到的话可以跳转到 [串口烧录](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#%E4%B8%B2%E5%8F%A3%E7%83%A7%E5%BD%95) 来重新烧录一次 M1s Dock 来解决该问题；烧录的时候并且勾选烧录 `partition table`, `boot2`, `firmware` 三个选项，烧录结束后重新将板子连接电脑。 ### UART 口现象 > 通过 UART 口连接 PC 会显示有两个串口设备 ![dual_uart](./assets/start/dual_uart.jpg) 并且在 Windows 系统的设备管理器中可以看到两个 Converter 设备。 ![start_bl808_uart_converter](./assets/start/start_bl808_uart_converter.png) 没有串口设备的话更换 USB 数据线或者使用电脑别的 USB 口。 依旧没有的话可以查看 [给板载 bl702 进行烧录](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#%E7%BB%99%E6%9D%BF%E8%BD%BD bl702 %E8%BF%9B%E8%A1%8C%E7%83%A7%E5%BD%95) 相关的内容来给 bl702 重新烧录一次固件。在 M1s Dock 上，我们使用 bl702 芯片作为 USB 转双串口芯片，由于某些原因串口功能不能正常使用的时候，可以重新烧录固件来解决这个问题。 只有一个串口设备的话也可以查看 [给板载 bl702 进行烧录](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#%E7%BB%99%E6%9D%BF%E8%BD%BD bl702 %E8%BF%9B%E8%A1%8C%E7%83%A7%E5%BD%95) 章节并且重新烧录 bl702 来解决问题。 设置波特率为 2000000，分别打开两个串口，会看到不同的信息。 打开小号串口可以看到一直在打印信息： ![start_smaller_uart](./assets/start/start_smaller_uart.jpg) 打开大号串口可以进行简单的命令行交互： ![start_bigger_uart](./assets/start/start_bigger_uart.jpg) ## 烧录方法 想要让板子运行自己预期的程序，就要先知道怎么样烧录固件到板卡。 ### U 盘烧录 为了便捷烧录，我们准备了 U 盘烧录的方法来给快速地烧录 M1s Dock 上 bl808 的 C906 核心所运行的程序。 先使用 TypeC 数据线将电脑与板子的 OTG 口连接起来，再同时按住板子上面两侧的按键（已经在下面图片中指明），然后按一下板子上的 RST 键就可以进入 U 盘烧录模式。 <table> <tr> <td><img src \"./assets/start/udisk_burn.png\" alt \"udisk_burn\" style \"transform:rotate(0deg);\"></td> <td>同时按住两侧的按键然后按一下 RST 键来复位板子，并让它进入 U 盘烧录模式</td> </tr> </table> 另外，按住两侧按键的时候，从板子的 OTG 口板子给板子通电来启动板子也可以进入 U 盘下载模式。 <img src \"./assets/start/udisk_in_computer.png\" alt \"udisk_in_computer\" style \"transform:rotate(0deg);\"> 板子成功进入 U 盘烧录模式后在电脑上会显示出一个容量很小的磁盘，直接把固件 <a href \"https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/demo_bin\">点我跳转部分例程固件</a> 拖拽进去即可完成烧录。 <img src \"./assets/start/udisk_burn.gif\" alt \"udisk_burn\" style \"transform:rotate(0deg);\"> 文件存放进去后数秒后板子会重启，U 盘被弹出，表示烧录完成。 但是因为 bl702 固件的差异，可能需要按下 RST 按键才能成功加载固件。[点我查看 bl702 固件差异](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#bl702 %E5%9B%BA%E4%BB%B6%E5%B7%AE%E5%BC%82) 。 ### 串口烧录 上面的 U 盘烧录方法适用于给 C906 核心烧录固件。当板子出现固件异常或者需要将板子的固件全部升级时，我们需要通过串口烧录这种方法来重新烧录 M1s Dock, 这可以解决所有问题。 使用 TypeC 数据线将电脑与板子的 UART 口连接起来，此时电脑上会出现两个串口 (如果出现鼠标不能动的现象请拔掉 USB 并且查看 [更新板载 bl702 固件](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#%E7%BB%99%E6%9D%BF%E8%BD%BD bl702 %E8%BF%9B%E8%A1%8C%E7%83%A7%E5%BD%95) 相关内容来修复问题)。 #### 软件获取 给 M1s 烧录需要用到博流官方烧录工具，前往 https://dev.bouffalolab.com/download 下载名称为 `Bouffalo Lab Dev Cube` 的文件。解压后就得到了用来烧录板子的应用程序。 ![bouffalo_cube](./assets/start/bouffalo_cube.png) 备份链接：[Sipeed 下载站](https://dl.sipeed.com/shareURL/others/BouffaloLabDevCube) 解压后的文件夹中有 `BLDevCube`、 `BLDevCube macos` 和 `BLDevCube ubuntu` 三个文件，用于在不同系统启动这个图形化烧录工具。 ![application](./assets/start/application.png) 还有 `bflb_iot_tool`、`bflb_iot_tool macos`、`bflb_iot_tool ubuntu` 这三个程序，用于在不同系统通过命令行进行烧录。 #### 图形化界面烧录 根据自己的系统启动软件 `BLDevCube` 后选择 bl808 ，紧接着软件的 IOT 页面选择分区表文件[点我下载](https://dl.sipeed.com/fileList/MAIX/M1s/M1s_Dock/7_Firmware/partition/partition_cfg_16M_m1sdock.toml)（图里 ②）。 <table> <tr> <td><img src \"./assets/start/chip_selection.png\" alt \"chip_selection\" style \"transform:rotate(0deg);\"></td> <td><img src \"./assets/start/choose_partition.png\" alt \"choose_partition\" style \"transform:rotate(0deg);\" width \"70%\"></td> </tr> </table> 选择完上面的分区表文件后，烧录工具的可选项就变多了，主要关注 `boot2`, `firmware`, `d0fw` 三项。 <img src \"./assets/start/firmware_choose.png\" alt \"firmware_choose\" style \"transform:rotate(0deg);\"> 上图中，`boot2` 是固定的，位于 `BLDevCube\\chips\\bl808\\builtin_imgs\\boot2_isp_bl808_xxxx_xxx` 目录下，就是在解压的烧录程序文件夹的子目录里面，要选择名称带有 `debug` 的文件；`firmware` 是 E907 核心运行的固件 ；`d0fw`是 C906 核心运行的固件，前面的 U 盘烧录里面的固件就是给这个核心烧录的。E907 的固件文件和 C906 的固件文件均可以通过 [M1s_dock example](https://gitee.com/sipeed/M1s_BL808_example) 来编译得到。 首次烧录 `firmware` 和 `boot2` 都需要烧录进去，之后就可以按需烧录而不用全部勾选。 旧默认固件可以在 [这里下载到](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/factory)，新默认固件不再提供。对应的旧默认固件测试方法查看 [旧固件测试](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#%E6%97%A7%E5%9B%BA%E4%BB%B6%E5%BC%80%E7%AE%B1%E6%B5%8B%E8%AF%95) 正确的选择固件后，在窗口右侧点击一下 `Refresh` 来刷新串口，正常情况有两个串口号相邻的串口可供选择，如果没有两个串口请参考下面的 [烧录 BL702](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#%E7%BB%99%E6%9D%BF%E8%BD%BD bl702 %E8%BF%9B%E8%A1%8C%E7%83%A7%E5%BD%95)来查看解决方法。在本烧录应用中，对 M1s Dock 操作均需要通过串口号较大的串口，而不是小号串口。 ![burn_steps](./assets/start/burn_steps.png) 按住板子上的 BOOT 键和 RST 键， 然后先松开 RST 键再松开 BOOT 键来使板子进入串口烧录模式。 <img src \"./assets/start/boot_rst.jpg\" alt \"boot_rst\" style \"transform:rotate(0deg);\" width \"40%\"> 点击下载 (Create & Download) 后会看到下图箭头中多指向的信息，在这之前我们需要操作硬件使它进入串口烧录模式。 ![burn_press_boot](./assets/start/burn_press_boot.jpg) 成功进入烧录模式会握手成功并且接下来会进行烧录。 <img src \"./assets/start/burn_press_boot_success.jpg\" alt \"burn_press_boot_success\" style \"transform:rotate(0deg);\" width \"70%\"> <img src \"./assets/start/finish_burning.png\" alt \"finish_burning\" style \"transform:rotate(0deg);\" width \"70%\"> 握手失败的话就重新点击烧录并且再次尝试。这种错误可能是按键释放顺序错误（应该先松开 RST 键再松开 BOOT 键，即在松开 RST 键的时候 boot 键应该是按下的状态）而导致板子没有进入串口烧录模式，软件等待超时而导致的。 <img src \"./assets/start/burn_press_boot_failed.jpg\" alt \"burn_press_boot_failed\" style \"transform:rotate(0deg);\" width \"70%\"> #### 命令行烧录 我们可以使用命令行来通过板子上的串口来对 M1s Dock 进行烧录。 在 `BLDevCube` 的文件夹下面，还有 `bflb_iot_tool`、`bflb_iot_tool macos`、`bflb_iot_tool ubuntu` 这三个程序，用于在不同系统通过命令行进行烧录。 下面是在 `Windows` 系统中通过命令行烧录的命令。其中 `firmware` 是 E907 核心的固件，可以在[旧默认固件](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/factory)处下载得到；`pt` 文件是分区表文件，默认在 `M1s_BL808_example\\partition` 目录下，当然也可以 [点我](https://dl.sipeed.com/fileList/MAIX/M1s/M1s_Dock/7_Firmware/partition/partition_cfg_16M_m1sdock.toml) 直接下载到；`boot2` 文件默认位于 `BLDevCube\\chips\\bl808\\builtin_imgs\\boot2_isp_bl808` 目录下，是名称带有 `debug` 的文件；波特率为 2M，这样烧录的时候会快点；`port` 应指定为串口号较大的串口。 ```bash .\\bflb_iot_tool.exe chipname bl808 port COM38 baudrate 2000000 firmware \"firmware_20221212.bin\" pt \"M1s_BL808_example\\partition\\partition_cfg_16M_m1sdock.toml\" boot2 \"BLDevCube\\chips\\bl808\\builtin_imgs\\boot2_isp_bl808\\boot2_isp_debug.bin\" ``` 当然，在烧录前需要让 M1s Dock 进入下载模式：按住板子上的 BOOT 键和 RST 键， 然后先松开 RST 键再松开 BOOT 键。 ![command_burn_flash](./assets/start/command_burn_flash.jpg) 烧录完之后，可以参考前面的 [U 盘烧录](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#U %E7%9B%98%E7%83%A7%E5%BD%95) 来给 C906 核心烧录固件。也可以自己根据烧录地址来烧录固件，烧录地址可以在 `partition_cfg_16M_m1sdock.toml` 文件查看到，也可以自己更改，此处不述。 ### 烧录时候的常见问题 #### BFLB IMG LOAD SHAKEHAND FAIL 这种情况是板子的 bl808 没有进入下载模式，确定自己在板子在运行时（已经通电）自己同时按下 RST 按键和 BOOT 按键，然后先松开 RST 键后松开 BOOT 键来时 bl808 进入下载模式。 ![uart_burn_bl808_shakehand_fail](./assets/start/uart_burn_bl808_shakehand_fail.jpg) 并且确定自己在下载的时候选择的是串口号大的那一个串口，而不是小号串口。 ![uart_burn_bl808_shakehand_fail_com_port](./assets/start/uart_burn_bl808_shakehand_fail_com_port.jpg) #### 只看到一个串口 这种情况是进入了板载 bl702 下载模式。需要注意的是不应该按住 BOOT 键然后给板子通电，这样会进入 bl702 的下载模式，只有一个串口显示在电脑中。给 bl808 通过串口烧录是在板子通电后，同时按下 RST 按键和 BOOT 按键，然后先松开 RST 键后松开 BOOT 键来时 bl808 进入下载模式。 ![uart_burn_bl808_only_one_port](./assets/start/uart_burn_bl808_only_one_port.jpg) #### 没有串口设备 确定自己连接的是板子上的 UART 接口，换一根数据线或者连接电脑另一个 USB 口。 #### 烧录单个固件 在烧录工具软件中，首次烧录要求将 `partition table`, `boot2`, `firmware`, `d0fw` 文件都勾选上并烧录进板子，以后如果想要烧录由 SDK 编译出来的单个固件，在对应的烧录选项中选择编译出来的文件就行： `firmware` 选择由 e907_demo 编译出来的最终固件。 `d0fw` 选择由 c906_demo 编译出来的最终固件。 `partition table` 和 `boot2` 每次烧录都要勾选中。 <table> <tr> <td>烧录 c906_demo 固件</td> <td>烧录 e907_demo 固件</td> </tr> <tr> <td><img src \"./assets/start/uart_burn_c906.jpg\" alt \"uart_burn_c906\"></td> <td><img src \"./assets/start/uart_burn_e907.jpg\" alt \"uart_burn_e907\"></td> </tr> </table> ## 烧录例程 下面的几个 Demo 都是从 M1s_bl808_example 里面编译出来的，适用于 bl808 里面的 C906 核心。 建议使用 U 盘烧录的方法烧录进板卡，直接体验一下这款板卡。 ### lvgl_demo [LVGL](https://lvgl.io/) (轻巧而多功能的图形库)是一个免费的开放源代码图形库，适合用于 mcu 构建图形界面。 Demo 文件：[点我](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/demo_bin/lvgl_demo) 通过 U 盘烧录的方法烧录进 M1s Dock 后，屏幕显示着 lvgl 测试效果，设置波特率为 2000000，串口号较小的串口打印着最后一次触摸屏幕位置。 <img src \"./assets/start/example_lvgl.gif\" alt \"example_lvgl\" width \"45%\"> <img src \"./assets/start/example_lvgl.jpg\" alt \"example_lvgl\" width \"45%\"> ### image_processing_demo 一个简单的图像处理例子。 Demo 文件：[点我](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/demo_bin/image_processing_demo) 通过 U 盘烧录的方法烧录进 M1s Dock 后，屏幕上显示摄像头画面，按下两侧的按键可以切换不同的图像算子。设置波特率为 2000000，串口号较小的串口显示着上次按键和其他信息。 按下复位键后串口号较小的串口会显示摄像头相关的配置信息，摄像头异常的话可以从串口信息看到。 <img src \"./assets/start/example_image_processing_demo.jpg\" alt \"example_image_processing_demo\" width \"45%\"> <img src \"./assets/start/example_image_processing_demo_uart.jpg\" alt \"example_image_processing_demo_uart\" width \"45%\"> ### tinymaix_mnist_demo [TinyMaix](https://github.com/sipeed/TinyMaix) 是面向单片机的超轻量级的神经网络推理库，即 TinyML 推理库，可以在任意单片机上运行轻量级深度学习模型。 Demo 文件：[点我](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/demo_bin/tinymaix_mnist_demo) 通过 U 盘烧录的方法烧录进 M1s Dock 后，屏幕中间的红框识别数字。设置波特率为 2000000，串口号较小的串口打印着识别信息。 <img src \"./assets/start/example_tinymaix_mnist_demo.jpg\" alt \"example_tinymaix_mnist_demo\" width \"45%\"> <img src \"./assets/start/example_tinymaix_mnist_demo_uart.jpg\" alt \"example_tinymaix_mnist_demo_uart\" width \"45%\"> ### pikascript_demo [PikaScript](http://pikascript.com/) 是一个跨平台的超轻量级嵌入式 Python 引擎。 Demo 文件：[点我](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/demo_bin/pikascript_demo) 通过 U 盘烧录的方法烧录进 M1s Dock 后，屏幕白屏，无内容。设置波特率为 2000000，打开串口号较小的串口来进行命令行交互。 在命令行中输入这些指令： ```bash arc lv.arc(lv.scr_act()) arc.set_end_angle(200) arc.set_size(150, 150) arc.center() ``` ![example_pikascript_demo_uart](./assets/start/example_pikascript_demo_uart.jpg) 然后可以看到屏幕上显示出来一些画面（忽略这糟糕的拍照）： ![example_pikascript_demo_screen](./assets/start/example_pikascript_demo_screen.jpg) ## SDK 编译 M1s 需要在 Linux 环境下进行编译 ### 安装编译所需要的相关软件 获取 SDK 需要用到 `git` 这个软件，编译 SDK 需要用到 `make` 这个软件，对应着后面文档检查自己的目录结构配置的时候需要用到 `tree` 这个软件。 下面是在 debian 系 Linux 发行版（比如 Ubuntu）中安装上述三个软件的示例命令。 ```bash sudo apt get install git make tree ``` 其它 Linux 发行版本安装上述所需的三个软件所使用的命令自行网上查找解决。 ### 获取例程仓库 ```bash git clone https://gitee.com/Sipeed/M1s_BL808_example.git ``` 最终结构树如下 `tree L 1 M1s_BL808_example/` ![sdk_compile_tree_1](./assets/start/sdk_compile_tree_1.jpg) <! ```bash sipeed@DESKTOP:~$ tree L 1 M1s_BL808_example/ M1s_BL808_example/ ├── LICENSE # 许可证文件 ├── assets # 资源文件 ├── c906_app # C906 核心例程 ├── e907_app # E907 核心例程 ├── partition # 分区表文件 └── readme.md # 仓库说明 ``` > ### 获得 SDK 仓库 仓库很大，120M 以上。 ```bash git clone https://gitee.com/sipeed/M1s_BL808_SDK.git ``` 最终结构树如下 `tree L 1` ![sdk_compile_tree_2](./assets/start/sdk_compile_tree_2.jpg) <! ```bash sipeed@DESKTOP:~$ tree L 1 . ├── M1s_BL808_example # 例程文件夹 └── M1s_BL808_SDK # SDK 文件夹 ``` > ### 在 SDK 仓库文件夹下，获取编译工具链 根据例程仓库里面的 readme 的要求，工具链应存放在 M1s_BL808_SDK/toolchain 目录下 ```bash mkdir p M1s_BL808_SDK/toolchain cd M1s_BL808_SDK/toolchain git clone https://gitee.com/wonderfullook/m1s_toolchain.git ``` 修改工具链的名称为 `Linux_x86_64` ，然后返回到上两级目录 ```bash mv m1s_toolchain Linux_x86_64 cd ../../ ``` 这时得到的结构树应如下(截取部分)：`tree L 2` ![sdk_compile_tree_3](./assets/start/sdk_compile_tree_3.jpg) <! ```bash sipeed@DESKTOP:~$ tree L 2 . ├── M1s_BL808_example # 例程仓库文件夹 │ ├── LICENSE # 许可证文件 │ ├── assets # 资源文件 │ ├── c906_app # C906 核心例程 │ ├── e907_app # E907 核心例程 │ ├── partition # 分区表文件 │ └── readme.md # 仓库说明 └── M1s_BL808_SDK # SDK 仓库文件夹 ├── toolchain # 编译工具链 ... ``` > ### 配置编译工具链路径 首先确定 `M1s_BL808_SDK` 文件夹所在的路径： ```bash cd M1s_BL808_SDK pwd ``` ![sdk_compile_snapshot_1](./assets/start/sdk_compile_snapshot_1.jpg) <! ```bash sipeed@DESKTOP:~$ cd M1s_BL808_SDK sipeed@DESKTOP:~/M1s_BL808_SDK$ pwd /home/lee/bl808/M1s_BL808_SDK ``` > 我们复制上面执行 `pwd` 后的结果（每个人的会不一样），比如上面截图中的 pwd 命令的执行结果为 `/home/lee/bl808/M1s_BL808_SDK`，因此在配置 `BL_SDK_PATH` 路径时后面应该跟着 `/home/lee/bl808/M1s_BL808_SDK`。 > 以后每次开始编译都需要执行一次这个来配置下编译工具链路径（注意自行修改 BL_SDK_PATH 的值，并且 符号后面没有空格） ```bash export BL_SDK_PATH ``` ![sdk_compile_snapshot_2](./assets/start/sdk_compile_snapshot_2.jpg) 然后执行下面的命令就可以准备开始交叉编译了。 <! ```bash export BL_SDK_PATH /home/lee/bl808/M1s_BL808_SDK ``` > 注意是 `M1s_BL808_SDK` ，不是 `M1s_BL808_SDK/`，一般自动补全会导致这个错误。 ### 编译 demo 执行 M1s_BL808_example/c906_app 目录下的 build.sh ，后面追加上想要编译的 demo 就可以完成了。 Demo 如下（编辑于 2022 12 13）： ![sdk_compile_tree_4](./assets/start/sdk_compile_tree_4.jpg) <! ```txt c906_app ├── audio_recording ├── blai_mnist_demo ├── camera_bypass_lcd ├── camera_dump ├── camera_streaming_through_wifi ├── cli_demo ├── flash_demo ├── gpio_demo ├── hello_world ├── i2c_touch ├── image_processing_demo ├── lfs_demo ├── lvgl_demo ├── pikascript_demo ├── proj_config.mk ├── pwm_demo ├── spi_lcd ├── tinymaix_mnist_demo └── uvc_demo ``` > 下面是编译 lvgl_demo 的示例命令，其他 demo 的编译自己更改 ./build.sh 后面的名称。 ```bash cd M1s_BL808_example/c906_app ./build.sh lvgl_demo ``` 然后编译出来的固件就会在 M1s_BL808_example/c906_app/build_out 目录下，名称为 `d0fw.bin`，通过虚拟 U 盘拖拽烧录即可。 ![udisk_burn](./assets/start/udisk_burn.gif) 虚拟 U 盘找不到的话也可以通过博流官方烧录工具来使用串口下载，注意在 d0fw 框中应当勾选自己所编译出来的 `d0fw.bin` （下图仅做示例） ![uart_burn_c906](./assets/start/uart_burn_c906.jpg) ### 编译 firmware 执行 M1s_BL808_example/e907_app 目录下的 build.sh ，后面追加上 firmware 就可以编译了 ```bash cd M1s_BL808_example/e907_app ./build.sh firmware ``` 然后编译出来的固件就会在 M1s_BL808_example/e907_app/build_out 目录下，名称为 `firmware.bin`。 通过博流官方烧录工具来使用串口下载，注意在 firmware 框中应当勾选自己所编译出来的`firmware.bin` （下图仅做示例） ![uart_burn_e907](./assets/start/uart_burn_e907.jpg) ### 常见问题 1. 执行完 build.sh 后提示 `Makefile:14: *** BL_SDK_PATH not found, please enter: export BL_SDK_PATH {sdk_path}. Stop.`，查看 [配置编译工具链路径](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#%E9%85%8D%E7%BD%AE%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E8%B7%AF%E5%BE%84) 来配置自己的 BL_SDK_PATH。 2. 编译出错 注意编译的时候使用的命令为 `./build.sh demo_name`，比如 `./build.sh hello_world`，而不是 `./build.sh hello_world/` （注意最后面的路径符号`/`） ## WIFI 串流摄像头 DEMO 一个简单的无线串流 Demo ### 软件环境 网络环境： PC 与板卡需要在同一网络环境中；M1s Dock 支持 2.4G 无线网络 PC 软件环境：`python3`， `OpenCV` 板卡固件要求：要求 [Firmware](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/factory) 固件为 `firmware_20230227.bin`，通过烧录方法中的 [串口烧录](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#%E4%B8%B2%E5%8F%A3%E7%83%A7%E5%BD%95) 说明的内容烧录 [Firmware](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/factory) 固件 ![camera_stream_e907](./assets/start/camera_stream_e907.png) ### 代码修改 打开例程路径 `M1s_BL808_example/c906_app/camera_streaming_through_wifi` 中的 `main.c` 文件。 ![camera_stream_original_source_code](./assets/start/camera_stream_original_source_code.png) 注意到里面的 `m1s_xram_wifi_connect()` 和 `m1s_xram_wifi_upload_stream()` 函数。 手动将 `liuxo_desktop` 要连接到的 PC 已经连接上的网络，并且将 `12345678` 更改为目标网络的连接密码。 将 `10.42.0.1` 替换成 PC 所在目标网络中的 IP 地址。 比如在下面的示例中，PC 所在的名为 `Test` 网络中的 IP 为 `192.168.43.183`，并且名为 `Test` 的无线网络密码是 `testtest`。 ![camera_stream_source_code](./assets/start/camera_stream_source_code.png) 编辑完 `main.c` 文件后记得保存一下。 ### 固件编译和烧录 修改代码且保存后，根据上面的 [SDK 编译说明](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#SDK %E7%BC%96%E8%AF%91) 来编译 `camera_streaming_through_wifi` 这个例程。 将编译得到的 `d0fw.bin` 固件通过 U 盘烧录的方式来快速的烧入到 M1s Dock 里面，打开大号串口，按下板子上面的复位键。 在板子成功连接到网络后它会在大号串口打印出自己的 IP 信息，并且 `Socket connect` 表示正在等待 PC 端应答。 ![camera_stream_socket_wait](./assets/start/camera_stream_socket_wait.png) ### PC 显示流 在 `M1s_BL808_example/c906_app/camera_streaming_through_wifi` 路径下，直接执行命令 `python3 main.py` 来使用 python 接收 M1s dock 的流并且调用 opencv 来显示画面。 ![camera_stream_success](./assets/start/camera_stream_success.png) ### 注意事项 1. 确认自己对 M1s Dock 烧录了修复 bug 后的 [firmware_20230227.bin](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/factory) 固件 2. 确定板子连接到了目标网络；成功连接到网络后板子的大号串口会显示出板卡的 IP 地址 3. 确定板子与 PC 在同一网络，且正确地修改了 `main.c` 中 PC 的 IPV4 地址 ## Linux Demo 这是一个能在 M1s Dock 上能运行起来的简易 Linux Demo。 [点我](https://dl.sipeed.com/fileList/MAIX/M1s/M1s_Dock/7_Firmware/m1sdock_linux_20221116.zip) 下载 Linux 例子，按照压缩包里面 `steps.md` 操作步骤完成 Linux 系统烧录。 ![linux_opensbi](./assets/start/linux_opensbi.jpg) 使用 `root` 登录 ![linux_login](./assets/start/linux_login.jpg) 查看 CPU 信息 ![linux_cpuinfo](./assets/start/linux_cpuinfo.jpg) 相关的 Linux SDK 前往 [github](https://github.com/sipeed/M1s_BL808_Linux_SDK) 查看。 ## 使用 Jtag 可以在[淘宝店铺](https://sipeed.taobao.com/)购买到 Jtag 调试器来调试 M1s Dock. ![cklink_appearence](./assets/start/cklink_appearence.jpg) ### 连接设备 将 Jtag 插入到板子的 TF 卡槽中来连接设备。自弹式 TF 卡槽可以自动固定连接，尽量减少硬插拔避免 TF 卡槽损坏。 连接后的样式如下图所示。 ![cklink_connect_side](./assets/start/cklink_connect_side.jpg) ![cklink_connect_top](./assets/start/cklink_connect_top.jpg) 调试器和 M1s Dock 的 UART 口都需要与电脑连接上（如上图，板子上的 UART 口和调试器都连接了电脑）；仅调试器连接电脑会因为需要给 M1s Dock 供电而导致调试器很烫，并且我们需要通过串口在 M1s Dock 上开启 Jtag 功能才能调试。 ### 安装驱动 前往 [下载站](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/9_Driver/cklink) 下载适合自己电脑的驱动。 #### Windows 解压 `T Head DebugServer windows` 压缩包后，运行解压后的 `Setup` 程序来安装驱动。 ![cklink_windows_install_driver](./assets/start/cklink_windows_install_driver.jpg) 在确定安装目录界面，建议不要更改默认的安装位置。避免因错误安装到根目录后，卸载该程序导致全盘清空的悲剧。 ![cklink_windows_driver_path](./assets/start/cklink_windows_driver_path.jpg) 全部都安装，避免以后还需要别的组件。 ![cklink_windows_driver_components](./assets/start/cklink_windows_driver_components.jpg) 安装结束后，连接上了调试器的话可以在设备管理器中看到有 `CKlink Lite`。 ![cklink_windows_driver_device_manager](./assets/start/cklink_windows_driver_device_manager.jpg) 桌面上有一个调试软件的图标。 ![cklink_windows_driver_desktop_icon](./assets/start/cklink_windows_driver_desktop_icon.jpg) #### Linux 获得驱动：[点我](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/9_Driver/cklink) ![cklink_linux_list_file](./assets/start/cklink_linux_list_file.jpg) 解压所下载的压缩文件。 ```bash tar xvf T Head DebugServer* ``` 然后当前目录下会多出一个脚本文件。 ![cklink_linux_list_shell_file](./assets/start/cklink_linux_list_shell_file.jpg) 执行一下脚本，会显示说明，可以知道在脚本后面加上 ` i` 会安装软件，加上 ` u` 会卸载软件。 ``` ./T Head DebugServer linux x86_64 V5.16.5 20221021.sh ``` ![cklink_linux_script_help](./assets/start/cklink_linux_script_help.jpg) 开始安装驱动： ``` sudo ./T Head DebugServer linux x86_64 V5.16.5 20221021.sh i ``` ![cklink_linux_installation](./assets/start/cklink_linux_installation.jpg) 上图中有两处是我们手动输入的 `yes` ，在 `Set full installing path` 处直接回车确认的话它会被安装到默认路径下，有需要的话自己指定一下安装路径。 安装完后使用 `lsusb` 可以查看到 `CKlink Lite` 设备。 ![cklink_linux_lsusb](./assets/start/cklink_linux_lsusb.jpg) ### 调试设备 在调试设备前，我们需要先通过 M1s Dock 上面的大号串口来操作板子，开启板子的调试功能。 ![cklink_jtag_serial_choice](./assets/start/cklink_jtag_serial_choice.jpg) ![cklink_jtag_choice](./assets/start/cklink_jtag_choice.jpg) 从上面可以看到有两个 jtag 选项，执行 `jtag_cpu0` 就会对 C906 核心进行调试，执行 `jtag_m0` 就是对 E907 核心进行调试。 ![cklink_jtag_c906](./assets/start/cklink_jtag_c906.jpg) ![cklink_jtag_e907](./assets/start/cklink_jtag_e907.jpg) #### Windows 运行前面安装驱动后在桌面上的 T HeadDebugServer 程序，出现下面的提示的话说明没有连接上设备，可以自己检查： 确定已经在串口里面使能了核心的 jtag 调试 设备管理器里面的 `CKlink Lite` 设备，没有的话检查核心板与电脑的连接情况或者重新安装驱动 调试器已经被其他 T HeadDebugServer 程序打开 ![cklink_jtag_windows_no_target](./assets/start/cklink_jtag_windows_no_target.jpg) 点击下图箭头指向的 三角标志 可以连接设备： ![cklink_jtag_windows_run_debugger](./assets/start/cklink_jtag_windows_run_debugger.jpg) 出现下图所示的 Failed 的话说明连接失败，端口不可用，可以自己设置端口来连接设备。 ![cklink_jtag_windows_no_port](./assets/start/cklink_jtag_windows_no_port.jpg) 选择 Socket Setting，设置合适的端口。 ![cklink_jtag_windows_set_socket](./assets/start/cklink_jtag_windows_set_socket.jpg) ![cklink_jtag_windows_set_socket_1](./assets/start/cklink_jtag_windows_set_socket_1.jpg) 成功连接上的话箭头所指的地方会从 三角形 变成 圆形。 ![cklink_jtag_windows_success_connection](./assets/start/cklink_jtag_windows_success_connection.jpg) 到这里已经完成连接了，上面的图里是使用 `jtag_m0` 命令来调试 E907 核心，需要的话可以使用 `jtag_cpu0` 命令更改成调试 C906 核心。 接下来就可以用 gdb 等工具来调试了。 ![cklink_jtag_windows_gdb_debug](./assets/start/cklink_jtag_windows_gdb_debug.jpg) 此外，在调试工具的安装目录下，有命令行程序 `DebugServerConsole`。 ![cklink_jtag_windows_debugserverconsole](./assets/start/cklink_jtag_windows_debugserverconsole.jpg) 使用命令行执行可以看到用法并且操作它。 ```bash .\\DebugServerConsole.exe h ``` ![cklink_jtag_windows_debugserverconsole_help](./assets/start/cklink_jtag_windows_debugserverconsole_help.jpg) ```bash .\\DebugServerConsole.exe port 65535 ``` ![cklink_jtag_windows_debugserverconsole_port](./assets/start/cklink_jtag_windows_debugserverconsole_port.jpg) 就可以通过 65535 端口来调试了。 #### Linux 使用 `DebugServerConsole h` 可以查看使用帮助。 ![cklink_jtag_linux_debugserverconsole_help](./assets/start/cklink_jtag_linux_debugserverconsole_help.jpg) 在命令行运行命令后，可以通过 12345 端口来调试了。 ```bash DebugServerConsole port 12345 ``` ![cklink_jtag_linux_debugserverconsole](./assets/start/cklink_jtag_linux_debugserverconsole.jpg) ## blai npu ### 支持算子 <table> <thead> <tr> <th>Type</th> <th>Operators</th> <th>Applicable Subset Spec.</th> <th>Processor</th> </tr> </thead> <tbody> <tr> <td rowspan \"10\">Convolution</td> <td rowspan \"4\">Conv </td> <td>Kernel: 1x1,3x3,5x5,7x7</td> <td rowspan \"4\">:strong:<code>NPU</code></td> </tr> <tr> <td>Stride: 1x1, 2x2</td> </tr> <tr> <td>Dilation: 1x1, 2x2</td> </tr> <tr> <td>Pad: same</td> </tr> <tr> <td rowspan \"4\">Depthwise Conv</td> <td>Kernel: 1x1,3x3 (5x5, 7x7 TBD)</td> <td rowspan \"4\">:strong:<code>NPU</code></td> </tr> <tr> <td>Stride: 1x1, 2x2</td> </tr> <tr> <td>Dilation: 1x1 (2x2 TBD)</td> </tr> <tr> <td>Pad: same</td> </tr> <tr> <td rowspan \"2\">Transpose Conv</td> <td>Kernel: 3x3</td> <td rowspan \"2\">strong:<code>NPU</code></td> </tr> <tr> <td>Stride: 2x2</td> </tr> <tr> <td rowspan \"4\">Pooling</td> <td rowspan \"2\">MaxPool (NPU TBD)</td> <td>Kerenl: 2x2</td> <td rowspan \"2\">DSP</td> </tr> <tr> <td>Stride: 2x2</td> </tr> <tr> <td rowspan \"2\">MaxPool</td> <td>Kerenl: 3x3</td> <td rowspan \"2\">:strong:<code>NPU</code></td> </tr> <tr> <td>Stride: 1x1, 2x2</td> </tr> <tr> <td rowspan \"2\">Activation</td> <td>Relu</td> <td></td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Relu 6</td> <td></td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td rowspan \"5\">Other processing</td> <td>BatchNormalization</td> <td>fused with conv</td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Add (shortcut)</td> <td></td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Concat (route)</td> <td>Channel wise (AXIS 3 in BHWC)</td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Fully Connected</td> <td></td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Upsample</td> <td>Nearest</td> <td>:strong:<code>NPU</code></td> </tr> </tbody> </table> ### blai_mnist_demo 编译之后使用 U 盘拖拽烧录的方法将编译出来的[固件](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/demo_bin/blai_mnist_demo)烧录进板子。前面说过编译出来的固件名称都是 `d0fw.bin`，且位于 `M1s_BL808_example/c906_app/built_out` 文件夹下。 ``` #c906_app ./build.sh blai_mnist_demo ``` ![udisk_burn](./assets/start/udisk_burn.gif) 烧录进去后（U 盘自动弹出就表示烧录完成）按下 RST 按键复位芯片来重新加载固件，此时查看通过串口号较小的串口（记住波特率为 2000000）查看会发现提示加载模型失败。 ![blai_mnist_demo_no_model](./assets/start/blai_mnist_demo_no_model.jpg) 因此我们要将模型上传到模型，从源码中可以看到对于这个 demo 我们要将模型存放到 flash 中。 ![blai_mnist_demo_fopen](./assets/start/blai_mnist_demo_fopen.jpg) 然后将板子的 OTG 口与电脑连接的话会看到一个大小为 7M 的 U 盘。 ![blai_mnist_demo_flash_disk](./assets/start/blai_mnist_demo_flash_disk.jpg) 按照源码的要求把文件存进去：在 U 盘里新建一个 models 文件夹，然后将 [mnist.blai](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/demo_bin/blai_mnist_demo) 模型文件存放进去。 ```bash models └── mnist.blai ``` ![blai_mnist_demo_model_path](./assets/start/blai_mnist_demo_model_path.jpg) 按下板子上的复位键(RST)，复位板卡程序来使板卡重新加载模型。 小号串口显示模型加载成功，并且显示板子识别数字结果。板子屏幕显示摄像头捕获到的画面，且也显示识别结果。 ![blai_mnist_demo_uart](./assets/start/blai_mnist_demo_uart.jpg) ![blai_mnist_demo_recognition](./assets/start/blai_mnist_demo_recognition.jpg) ### tom_and_jerry_classification_demo 这是一个在 [MaixHub](https://maixhub.com/model/zoo/127) 上可下载的模型文件，我们可以在这个网站直接上传数据集、标注和生成模型文件再部署到板卡上，这里叙述一下怎么样将在 [MaixHub](https://maixhub.com/) 所下载的模型部署到 M1s Dock 上。 首先根据前面搭建 SDK 环境所描述的内容，编译出 [tom_and_jerry_classification_demo](https://dl.sipeed.com/fileList/MAIX/M1s/M1s_Dock/7_Firmware/demo_bin/tom_and_jerry_classification_demo.bin) 这个例程固件。 ```bash #c906_app ./build.sh tom_and_jerry_classification_demo ``` 然后通过 U 盘拖拽烧录的方法将编译出来的固件烧录进板子。 ![udisk_burn](./assets/start/udisk_burn.gif) 在 tom_and_jerry_classification_demo 里面的 `main.c` 源码中可以所加载的模型在 Flash 里面的 models 文件夹里面，且模型名称为 `tj.blai`。 ![tom_jerry_source_code](./assets/start/tom_jerry_source_code.jpg) 所以我们在 [MaixHub](https://maixhub.com/model/zoo/127) 下载到这个例程模型后，解压并将里面拓展名为 `.blai` 的文件重命名为 `tj.blai`。 ![tom_jerry_model_rename](./assets/start/tom_jerry_model_rename.gif) 然后将板子的 OTG 口与电脑连接的话会看到一个大小为 7M 的 U 盘。 ![blai_mnist_demo_flash_disk](./assets/start/blai_mnist_demo_flash_disk.jpg) 按照源码要求把上面重命名后所得到的 `tj.blai` 文件存放到 U 盘的 models 文件夹下：在 U 盘里新建一个 models 文件夹，然后将 `tj.blai` 这个模型文件存放进所创建的 models 文件夹中 。 ![tom_jerry_model_path](./assets/start/tom_jerry_model_path.jpg) 然后就可以使用 M1S Dock 来分辨 Tom 和 Jerry 了。 <img src \"./assets/start/tom_jerry_model_jerry.jpg\" alt \"tom_jerry_model_jerry\" width 42%> <img src \"./assets/start/tom_jerry_model_tom.jpg\" alt \"tom_jerry_model_tom\" width 42%> 因为模型文件比较大，所以识别略有压力。 ## 常见解答 ### 板子上为什么有一个额外的 BL702 芯片 BL702 芯片在这里担任着 USB 转双串口芯片功能。 因此有时候串口异常的话，可以上电前按住 BOOT 按键来给 BL702 重新烧录一下 USB 转双串口的固件。 ### 为什么要用双串口 根据 BL808 的手册可以知道里面有三颗核心，双串口分别连接到了其中的两颗核心，可以自己体验异构核心的执行顺序。 ### 为什么用虚拟 U 盘 虚拟 U 盘是基于固件出来的，目的是方便用户快速烧录体验 Demo。 把 BL808 里面的全部固件擦除后，就不会再有虚拟 U 盘了。 想要再次使用虚拟 U 盘的话，按照文档重新使用串口烧录的方法重新烧录一下默认的固件就行了。 ### 为什么要说明串口烧录 虚拟 U 盘是基于固件的，想要烧录这个固件就必须有一种烧录方式将它烧录进板子。 这里我们用串口烧录的方法来烧录最基础的固件到芯片里面的 FLASH 中。 ### 怎么样擦除 bl808 的固件 擦除固件需要使用到 [Bouffalo Lab Dev Cube](https://dev.bouffalolab.com/download) 这款软件，在打开软件后选择 BL808 芯片型号。 ![chip_selection](./assets/start/chip_selection.png) 首先在软件里面点开高级模式 ![erase_advanede_mode](./assets/start/erase_advanede_mode.jpg) 选择 FLASH 界面然后使板子进入下载模式（按住板子上的 BOOT 键和 RST 键， 然后先松开 RST 键再松开 BOOT 键），选择串口号较大的串口，勾选 Whole Chip，点击 `Erase Flash` 开始擦除。 ![erase_configurations](./assets/start/erase_configurations.jpg) 擦除的时候没有进度条，擦除完成的时候会直接显示 SUCCESS。 ![erase_success](./assets/start/erase_success.jpg) ### 烧录 BL808 时候提示 BFLB IMG LOAD SHAKEHAND FAIL 这种情况是板子的 bl808 没有进入下载模式，确定自己在板子在运行时（已经通电）自己同时按下 RST 按键和 BOOT 按键，然后先松开 RST 键后松开 BOOT 键来时 bl808 进入下载模式。 ![uart_burn_bl808_shakehand_fail](./assets/start/uart_burn_bl808_shakehand_fail.jpg) 并且确定自己在下载的时候选择的是串口号大的那一个串口，而不是小号串口。 ![uart_burn_bl808_shakehand_fail_com_port](./assets/start/uart_burn_bl808_shakehand_fail_com_port.jpg) ### 烧录 BL808 时候只看到一个串口 这种情况是进入了板载 bl702 下载模式。需要注意的是不应该按住 BOOT 键然后给板子通电，这样会进入 bl702 的下载模式，只有一个串口显示在电脑中。给 bl808 通过串口烧录是在板子通电后，同时按下 RST 按键和 BOOT 按键，然后先松开 RST 键后松开 BOOT 键来时 bl808 进入下载模式。 ![uart_burn_bl808_only_one_port](./assets/start/uart_burn_bl808_only_one_port.jpg) ### 烧录 BL808 时候没有串口设备 确定自己连接的是板子上的 UART 接口，换一根数据线或者连接电脑另一个 USB 口。 ![uart_burn_bl808_only_one_port](./assets/start/uart_burn_bl808_only_one_port.jpg) ### 烧录 BL808 时候只想要烧录单个固件 在烧录工具软件中，首次烧录要求将 `partition table`, `boot2`, `firmware`, `d0fw` 文件都勾选上并烧录进板子，以后如果想要烧录由 SDK 编译出来的单个固件，在对应的烧录选项中选择编译出来的文件就行： `firmware` 选择由 e907_demo 编译出来的最终固件。 `d0fw` 选择由 c906_demo 编译出来的最终固件。 `partition table` 和 `boot2` 每次烧录都要勾选中。 <table> <tr> <td>烧录 c906_demo 固件</td> <td>烧录 e907_demo 固件</td> </tr> <tr> <td><img src \"./assets/start/uart_burn_c906.jpg\" alt \"uart_burn_c906\"></td> <td><img src \"./assets/start/uart_burn_e907.jpg\" alt \"uart_burn_e907\"></td> </tr> </table> ### 编译 SDK 相关的常见问题 1. 执行完 build.sh 后提示 `Makefile:14: *** BL_SDK_PATH not found, please enter: export BL_SDK_PATH {sdk_path}. Stop.`，查看 [配置编译工具链路径](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#%E9%85%8D%E7%BD%AE%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E8%B7%AF%E5%BE%84) 来配置自己的 BL_SDK_PATH。 2. 编译出错 注意编译的时候使用的命令为 `./build.sh demo_name`，比如 `./build.sh hello_world`，而不是 `./build.sh hello_world/` （注意最后面的路径符号`/`） ### 旧固件开箱测试 对 M1s Dock 板子上电，屏幕会显示摄像头所拍摄到的内容。 按下 `S1` 或者 `S2` 按键后屏幕上的数字会发生变化，那个数字表示着板子上 LED 的亮度百分比。 ![default_firmware](./assets/start/default_firmware.jpg) 可以看到下图中的 LED 亮度为 50% 时候的亮起状态。 ![led_brghtness](./assets/start/led_brghtness.jpg) ### 给板载 bl702 进行烧录 一般来说板子串口出问题才进行这里的烧录。 按住 BOOT 键后冷启动板子，就可以通过 UART 口烧录板载 bl702 了。 在给板子通电前按住板子上的 BOOT 按键，然后通过板子上的 UART USB 接口连接电脑，此时板载 bl702 进入下载模式，打开 `BLDevCube` 烧录软件（根据自己系统选择），选择 `BL702` 芯片，在打开的软件界面选择 MCU 模式，接着可以在 [这里](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware) 下载到 bl702 的固件，名称为 `usb2dualuart_bl702` 开头的就是我们需要烧录的文件。 固件差异可以查看 [bl702 固件差异](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#bl702 %E5%9B%BA%E4%BB%B6%E5%B7%AE%E5%BC%82) <table> <tr> <td><img src \"./assets/start/select_bl702.png\" alt \"select_bl702\" style \"transform:rotate(0deg);\"></td> <td><img src \"./assets/start/mcu_mode.png\" alt \"mcu_mode\" style \"transform:rotate(0deg);\" width \"70%\"></td> </tr> </table> 点击 `Refresh`，选择唯一的串口（如果看到的不是唯一串口，记住是先按住 BOOT 键，再给板子通电），设置波特率 2000000， 点击下载烧录。 ![burn_bl702](./assets/start/burn_bl702.png) 烧录结束后，重新插拔一次 USB 来重新启动 bl702 以应用新的固件。 ![finish_burn_702](./assets/start/finish_burn_702.png) ### 给 bl702 烧录时没有串口 如果没有出现，就需要确认自己是在板子未通电的时候按住板子上的 BOOT 键后再通过板子上的 UART 接口来给板子通电。 Windows 用户可以在设备管理器中先查看一下有没有一个 `Bouffalo CDC` 设备。 Windows 10 以下的系统不会自动加载 USB CDC 驱动，需要自己手动搜索 `Windows7 CDC` 相关的问题解决。 ![burn_bl702_cdc_error](./assets/start/burn_bl702_cdc_error.png) ### 烧录固件后板卡没有启动 这种情况是 bl702 的固件差异导致的，有下面两个解决方法： 通电后，按下板子上的 RST 按键来启动 M1S Dock 重新烧录 bl702 的双串口固件 [烧录 bl702](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#%E7%BB%99%E6%9D%BF%E8%BD%BD bl702 %E8%BF%9B%E8%A1%8C%E7%83%A7%E5%BD%95) ### bl702 固件差异 在 [下载站](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware) 中，有两个 bl702 可用的双串口固件，他们的差异如下： 固件名称 usb2dualuart_bl702_221118 usb2dualuart_bl702_20230221 来源 SIPEED 博流智能 详细说明 具有软复位功能，<br>不用按下 RST 按键就能运行 BL808 没有复位功能，<br>需要按下 RST 键才能启动 BL808 驱动情况 部分电脑可能需要手动安装 [驱动](https://dl.sipeed.com/shareURL/MAIX/tools/driver) <br>才能系统识别 免驱 [点我查看如何烧录 BL702 固件](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#%E7%BB%99%E6%9D%BF%E8%BD%BD bl702 %E8%BF%9B%E8%A1%8C%E7%83%A7%E5%BD%95)"},"/hardware/zh/maix/m1s/other/get_key.html":{"title":"M1s 获取机器码","content":" title: M1s 获取机器码 keywords: M1s DOCK ,BL808, M1s update: date: 2022 11 10 version: v0.1 author: wonder content: 初次编辑 在 [MaixHub](https://maixhub.com/) 下载模型的时候会要求输入机器码，这里说明一下怎么获得机器码。 如果进行下面步骤后没有得到机器码的话，查看[常见问题](#常见问题) ## 简述 简述步骤如下： 将开发板通过 UART 串口与电脑连接（电脑设备管理器中会出现两个串口） 使用任意串口工具，设置波特波特率为 2000000 （1 个 2 和 6 个 0），打开开发板在电脑中所显示的较大的串口号 按下开发板上的 RST 按键，在打印的串口信息如下（仅作示例） ```bash # 省略若干 [MTD] >>>>>> Hanlde info Dump >>>>>> name D0FW id 0 offset 0x00100000(1048576) size 0x00200000(2048Kbytes) xip_addr 0x580f0000 [MTD] <<<<<< Hanlde info End <<<<<< D0FW addr:0x580f0000 size:0x200000 MM CPU select PLL >MM CPU select 400Mhz UART CLK select MM XCLK >XCLK select XTAL I2C CLK select MM XCLK >XCLK select XTAL SPI CLK select 160Mhz MM BUS CLK select 160Mhz XCLK select XTAL irq handle: 3 reset ev CHIP KEY key:57F80642C3F97E2655772C48AF17455EC9E79BBF76C16EED4E0EC1096D664435 ``` 可以从最后面的 `CHIP KEY` 得到下载模型所需要的机器码了 > 每块板子的 `CHIP KEY` 都不一样，上面仅作示范参考，实际 `CHIP KEY` 根据每个人操作来获得。 ## 详述 1. 将板子的 UART 口通过 Type C 数据线与电脑连接起来 ![uart_connect](./assets/get_key/uart_connect.png) 2. 打开电脑串口工具（根据自己的串口软件自行更改），设置波特率为 2000000 （1 个 2 和 6 个 0），打开开发板在电脑上显示的较大串口号 <img src \"./assets/get_key/baudrate_2000000.png\" width 45% alt \"baudrate_2000000\"> <img src \"./assets/get_key/bigger_com_port.png\" width 45% alt \"bigger_com_port\"> 3. 打开串口；按下板子上面的 RST 按键。在串口打印信息的最后看到 `CHIP KEY` 。 <table> <tr> <th>按一下 RST 按键再松开</th> <th>串口软件显示出来机器码</th> </tr> <tr> <td><img src \"./assets/get_key/rst_key.png\" alt \"rst_key\"></td> <td><img src \"./assets/get_key/chip_key.png\" alt \"chip_key\"></td> </tr> </table> ## 常见问题 ### 串口乱码 确认自己设置的波特率为 2000000 （2M） ### 复位后的信息中没有 CHIP KEY 这种情况可以通过更新为最新固件来解决，[点我跳转到最新固件下载地址](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/factory)，选择文件名为 `firmware` 开头的文件，烧录方法请参考[该网页](https://gitee.com/sipeed/M1s_BL808_example) (Gitee) 里面的 **Download e907 firmware** ### 没有显示出两个串口 可以参考[该网页](https://gitee.com/sipeed/M1s_BL808_example) (Gitee) 里面的 **Download bl702 firmware** 重新烧录一次串口固件，双串口固件下载地址为 [这里](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware)，其名称以 `usb2dualuart_bl702.bin` 开头 ### 没有显示出任何串口 首先应当确认自己所接通的是 UART 口，然后可以根据本篇所述的[没有显示出两个串口](#没有显示出两个串口)重新烧录一下串口固件"},"/hardware/zh/maix/m1s/other/questions.html":{"title":"M1s DOCK 常见问题","content":" title: M1s DOCK 常见问题 keywords: M1s DOCK ,BL808, M1s update: date: 2022 11 28 version: v0.1 author: wonder content: 初次编辑 ## c906_app/build_out/xxxxx/.map:No such file or directory 注意编译的时候使用的命令为 `./build.sh demo_name`，比如 `./build.sh hello_world`，而不是 `./build.sh hello_world/` （注意最后面的路径符号`/`）"},"/hardware/zh/maix/m1s/m1s_dock.html":{"title":"M1s DOCK 开发板","content":" title: M1s DOCK 开发板 keywords: M1s DOCK ,BL808, M1s, bl808 update: date: 2022 11 09 version: v0.2 author: wonder content: 修改部分描述错误 增加 SDK(github) 和 Example(github) 链接 增加注意事项 增加软件描述栏目 date: 2022 11 04 version: v0.1 author: wonder content: 初次编写 ## 产品概述 Sipeed M1s Dock 是基于 [Sipeed M1s](./m1s_module.html) 模组来设计的一款核心板，引出了 MIPI CSI、SPI LCD 等 FPC 接口，免去接线难的烦恼。使用最精简的设计，用于客户对模组进行模组评估，或者爱好者直接上手游玩等用途。 购买链接：[淘宝](https://item.taobao.com/item.htm?id 691108452443) <td><img alt \"m1s_dock.jpg\" src \"./assets/m1s_dock/m1s_dock.jpg\" width \"45%\"></td> ## 宣传视频 M1s Dock 和 M0Sense 总览：3:15 之前的都是 M1s Dock。 <iframe src \"//player.bilibili.com/player.html?aid 559937139&bvid BV1De4y117sP&cid 887814913&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> ## 板卡特点 主芯片 BL808 RISC V 480Mhz + NPU BLAI 100 板载 USB 转 UART 调试器（可实现一键点击烧录，无需按实体按键） 板载显示屏座子（可选配 1.69 寸 240x280 电容触摸屏） 板载 MIPI 摄像头座子（可选配 200W 像素摄像头） 支持 2.4G WIFI / BT / BLE 板载 1 个模拟麦克风、1 个 LED、1 个 TF 卡座 引出一路 USB OTG 到 USB Type C 接口 ### 硬件参数 <table> <thead> <tr> <th colspan \"2\" > M1s Dock </th> </tr> </thead> <tbody> <tr> <td rowspan \"8\" style \"white space:nowrap\">M1s 模组</td> </tr> <tr> <td>三核异构RISC V CPUs：<br>· RV64GCV 480MHz <br>· RV32GCP 320MHz <br>· RV32EMC 160MHz</td> </tr> <tr> <td>AI NN 通用硬件加速器 —— BLAI 100 用于视频/音频检测/识别</td> </tr> <tr> <td>内置 768KB SRAM + 64MB UHS PSRAM</td> </tr> <tr> <td>编解码：<br> MJPEG and H264(Baseline/Main)<br> 1920x1080@30fps + 640x480@30fps </td> </tr> <tr> <td>接口：<br> 摄像头接口 ：DVP 和 MIPI CSI<br> 显示接口：SPI、DBI、DPI(RGB)</td> </tr> <tr> <td>无线：<br> 支持 Wi Fi 802.11 b/g/n<br> 支持 Bluetooth 5.x Dual mode(BT+BLE)<br> 支持 Wi Fi / 蓝牙 共存</td> </tr> <tr> <td>USB 2.0 HS OTG （引出到 USB Type C 接口）</td> </tr> <tr> <td rowspan \"5\" style \"white space:nowrap\"> 板载部件 </td> </tr> <tr> <td>板载 USB 转 UART 调试器（使用官方下载工具可实现一键点击烧录，无需按实体按键）</td> </tr> <tr> <td>板载 1 个显示屏座子（可选配 1.69 寸 240 x 280 电容触摸屏）</td> </tr> <tr> <td>板载 MIPI 摄像头座子（可选配 200W 像素摄像头）</td> </tr> <tr> <td>板载 1 个模拟麦克风、1 个 LED、1 个 TF 卡座 </td> </tr> <tr> <td rowspan \"5\" style \"white space:nowrap\"> 其他说明 </td> </tr> <tr> <td> 3D 模型文件下载：<a href \"https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/5_3D_file\">点击跳转</a> </td> </tr> <tr> <td>外部供电需求 TYPE C 接口：5V±10% 0.5A</td> </tr> <tr> <td>温升: &lt;30K</td> </tr> <tr> <td>工作温度范围: 10℃ ~ 65℃</td> </tr> </tbody> </table> ### 主控核心 三核异构 M0，D0，LP。 M0 D0 LP 平头哥 [E907](https://occ.t head.cn/product?id 3900588052540035072)@320MHz 平头哥 [C906](https://occ.t head.cn/product?id 3817197695983423488)@480MHz 平头哥 [E902](https://occ.t head.cn/product?id 3806460569050419200)@160MHz ### 外设框图 <img alt \"m1s_dock_function_block_top\" src \"./assets/m1s_dock/m1s_dock_function_block_top.jpg\" width 20%> <img alt \"m1s_dock_function_block_top\" src \"./assets/m1s_dock/m1s_dock_function_block_top.jpg\" width 20%> ### 尺寸图 <img alt \"m1s_dock_size\" src \"./assets/m1s_dock/m1s_dock_size.png\" width 45%> ### 引脚图 <img alt \"m1s_doc_pin_map\" src \"./assets/m1s_dock/m1s_doc_pin_map.png\" width 45%> ## 产品对比 项目 Maix Bit ESP32 cam M1s Dock : : : : 处理器 K210 ESP32 M1s(BL808) 摄像头 0.3MP DVP GC0328 2MP DVP OV2640 with flash LED 2MP MIPI OV2685(two side) with flash LED 显示屏 2.4 inch 320x240 1.68 inch 280x240 带电容触摸 音频 I2S MEMS MIC Analog MEMS MIC + LineOut SD 卡槽 SPI 模式 SPI 模式 · SDHC 模式 <br>· JTAG 模式 按键 Reset <br> Boot Reset · Reset <br>· Boot <br>· User x 2 USB USB to Serial x 1 · USB to Dual Serial x 1 <br>· USB OTG HS 其他 4P x 1.25mm 连接器（串口） 引脚 2 x 18 pins,可用于面包板 2 x 8 pins 2 x 16 pins,可用于面包板 JTAG 可选 TF2JTAG 外壳 可选 尺寸 25 x 53 mm 27 x 41 mm 27 x 55 mm ## 软件描述 <table> <thead> <tr> <th colspan \"2\" > M1s Dock </th> </tr> </thead> <tbody> <tr> <td>OS</td> <td>· 完备支持 FreeRTOS<br>· 基础支持 Linux</td> </tr> <tr> <td>开发方式</td> <td>· 原生 C SDK<br>· MaixHAL C 模块<br>· PikaPython </td> </tr> <tr> <td>固件下载</td> <td>· 串口下载<br>· 虚拟磁盘拖拽式更新</td> </tr> <tr> <td>AI 推理框架</td> <td>· 支持原生 SDK 的 BLAI 加速推理引擎<br>· 支持通用 TinyMaix 推理引擎</td> </tr> <tr> <td>AI 模型下载</td> <td>· <a href \"https://maixhub.com/\">MaixHub</a> 下载。支持 人脸检测，识别，姿态检测，手势检测 等</td> </tr> <tr> <td>Sipeed 参考示例</td> <td>· https://gitee.com/sipeed/M1s_BL808_example</td> </tr> </tbody> </table> ## 支持算子列表 <table> <thead> <tr> <th>Type</th> <th>Operators</th> <th>Applicable Subset Spec.</th> <th>Processor</th> </tr> </thead> <tbody> <tr> <td rowspan \"10\">Convolution</td> <td rowspan \"4\">Conv </td> <td>Kernel: 1x1,3x3,5x5,7x7</td> <td rowspan \"4\">:strong:<code>NPU</code></td> </tr> <tr> <td>Stride: 1x1, 2x2</td> </tr> <tr> <td>Dilation: 1x1, 2x2</td> </tr> <tr> <td>Pad: same</td> </tr> <tr> <td rowspan \"4\">Depthwise Conv</td> <td>Kernel: 1x1,3x3 (5x5, 7x7 TBD)</td> <td rowspan \"4\">:strong:<code>NPU</code></td> </tr> <tr> <td>Stride: 1x1, 2x2</td> </tr> <tr> <td>Dilation: 1x1 (2x2 TBD)</td> </tr> <tr> <td>Pad: same</td> </tr> <tr> <td rowspan \"2\">Transpose Conv</td> <td>Kernel: 3x3</td> <td rowspan \"2\">strong:<code>NPU</code></td> </tr> <tr> <td>Stride: 2x2</td> </tr> <tr> <td rowspan \"4\">Pooling</td> <td rowspan \"2\">MaxPool (NPU TBD)</td> <td>Kerenl: 2x2</td> <td rowspan \"2\">DSP</td> </tr> <tr> <td>Stride: 2x2</td> </tr> <tr> <td rowspan \"2\">MaxPool</td> <td>Kerenl: 3x3</td> <td rowspan \"2\">:strong:<code>NPU</code></td> </tr> <tr> <td>Stride: 1x1, 2x2</td> </tr> <tr> <td rowspan \"2\">Activation</td> <td>Relu</td> <td></td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Relu 6</td> <td></td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td rowspan \"5\">Other processing</td> <td>BatchNormalization</td> <td>fused with conv</td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Add (shortcut)</td> <td></td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Concat (route)</td> <td>Channel wise (AXIS 3 in BHWC)</td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Fully Connected</td> <td></td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Upsample</td> <td>Nearest</td> <td>:strong:<code>NPU</code></td> </tr> </tbody> </table> ## 补充资料 [板卡规格书](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/1_Specification) [板卡原理图](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/2_Schematic) [板卡点位图](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/3_Bit_number_map) [板卡尺寸图](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/4_Dimensional_drawing) [3D 模型文件](https://dl.sipeed.com/shareURL/MAIX/M1s_Dock/M1s/5_3D_file) [板卡芯片数据手册](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/6_Chip_Manual) [触摸屏手册](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/6_Chip_Manual/touch_screen) [博流官方文档](https://dev.bouffalolab.com/home/) [BL808 数据手册](https://gitee.com/wonderfullook/bl_docs/tree/main/BL808_DS/zh_CN) (gitee) [BL808 参考手册](https://gitee.com/wonderfullook/bl_docs/tree/main/BL808_RM/zh_CN) (gitee) [Sipeed SDK](https://gitee.com/sipeed/M1s_BL808_SDK) (gitee) [Sipeed Examples](https://gitee.com/sipeed/M1s_BL808_example)（gitee） [Bouffalolab SDK](https://github.com/bouffalolab/bouffalo_sdk)（Github） [Linux SDK](https://github.com/sipeed/M1s_BL808_Linux_SDK)（Github） 交流 QQ 群：`592731168` 。[点我加群](https://jq.qq.com/?_wv 1027&k uyKNhTeu) 论坛：[bbs.sipeed.com](https://bbs.sipeed.com/) [在线模型平台](https://maixhub.com/) ## 注意事项 <table> <tr> <th>项目</th> <th>注意事项</th> </tr> <tr> <td>静电防护</td> <td>请避免静电打到 PCBA 上；接触 PCBA 之前请把手的静电释放掉</td> </tr> <tr> <td>容忍电压</td> <td> 每个 GPIO 的工作电压已经在原理图中标注出来，请不要让 GPIO 的实际工作的电压超过额定值，否则会引起 PCBA 的永久性损坏 </td> </tr> <tr> <td>FPC 座子</td> <td>在连接 FPC 软排线的时候，谲确保排线无偏侈地完整地插入到排线中</td> </tr> <tr> <td>插拔</td> <td>请完全断电后才进行插拔操作</td> </tr> <tr> <td>避免短路</td> <td>请在上电过程中，避免任何液体和金属触碰到 PCBA 上的元件的焊盘，否则会导致路，烧毁 PCBA</td> </tr> </table> ## 联系 Sipeed M1s Dock 开发板可以在多种场景实现客户不同方面的需要，技术支持和商业合作请联系使用邮箱 [support@sipeed.com](support@sipeed.com)"},"/hardware/zh/maix/M1n.html":{"title":"Sipeed M1n","content":" title: Sipeed M1n keywords: maixpy, k210, AIOT, 边缘计算, M1n desc: maixpy Sipeed M1/M1W ## M1n SiPEEDM1n是基于基于嘉楠堪智科技的边缘智能计算芯片K210(RISC v架构64位双核)设计的一款AIOT开发板。板载DVP双摄像头接口、Flash、并把大部分IO通过金手指方式引出，模块设计小巧精致、布局走线合理规范，用户可直接应用于商用产品，也可以通过转接板对此模块进行开发。 ![M1n](./assets/m1n/M1n_1.png) ## 应用 智能家居，机器人清洁器，智能扬声器，电子门锁，家庭监控等; 医学行业应用，如辅助诊断，医学图像识别; 智能工业应用，如工业机械，智能分拣，电气设备监控等; 教育机器人，智能互动平台，教育效率检查等教育应用; 农业应用，如农业监测，病虫害监测，自动控制等 ## M1n 参数 M1n模块以K210作为核心单元，功能非常很强大，芯片内置64位双核处理器，拥有8M的片上SRAM，在Al机器视觉、听觉性能方便表现突出，内置多种硬件加速单元(KPU、FPU，FFT等)，总算力最高可达1TOPs ,可以方便地实现各类应用场景的机器视觉/听觉算法,也可以进行语音方向扫描和语音数据输出的前置处理工作。 <p><img loading \"M1/M1W\" src \"./assets/m1n/M1n.png\" width 500 ></p> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">K210 芯片基本参数</th> </tr> </thead> <tbody> <tr> <td>内核</td> <td>RISC V Dual Core 64bit, with FPU</td> </tr> <tr> <td>主频</td> <td>400MHz （可超频至600MHz）</td> </tr> <tr> <td>SRAM</td> <td>内置8M Byte</td> </tr> <tr> <td>图像识别</td> <td>QVGA@60fps/VGA@30fps</td> </tr> <tr> <td>语音识别</td> <td>麦克风阵列(8mics)</td> </tr> <tr> <td>网络模型</td> <td><li>支持YOLOv3<li>Mobilenetv2<li>TinyYOLOv2<li>人脸识别等</td> </tr> <tr> <td>深度学习框架</td> <td>支持TensorFlow \\ Keras \\ Darknet \\ Caffe 等主流框架</td> </tr> <tr> <td>外设</td> <td>FPIOA、 UART、 GPIO、 SPI、 I2C、I2S、 TIMER</td> </tr> <tr> <td>视频处理</td> <td><li>神经网络处理器(KPU)<li>FPU满足IEEE754 2008标准<li>音频处理器(APU)<li>快速傅里叶变换加速器(FFT)</td> </tr> </tbody> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">模块软件</th> </tr> </thead> <tr> <td>操作系统</td><td>FreeRtos and Standrad development ki</td> </tr> <tr> <td>编程语言</td><td>MicroPython</td> </tr> <tr> <td>机器视觉</td><td>支持卷积神经网络</td> </tr> <tr> <td>机器听觉</td><td>高性能音频处理器(APU)</td> </tr> <tr> <td>开发环境</td><td>串口终端、MaixPy IDE</td> </tr> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">模块硬件</th> </tr> </thead> <tr> <td>尺寸</td><td>22.0*25.0mm</td> </tr> <tr> <td>引脚</td><td>部分引脚金手指引出</td> </tr> <tr> <td>供电电压</td><td>5.0V @ 300mA（供电电流需大于300mA)</td> </tr> <tr> <td>工作温度</td><td> 30°C ~85°C</td> </tr> </table> ## 资料下载 芯片 K210 Datasheet: [Kendryte 官网](https://canaan creative.com/) M1n 资料下载: [Click me](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed M1n) M1n 原理图下载：[Sipeed M1n Datasheet V1.0.pdf](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed M1n/Sipeed%20M1n%20Datasheet%20V1.0.pdf) ## 产品技术支持 Maix系列产品可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maix/maixpy_develop_kit_board/maix_go.html":{"title":"Maix Go","content":"# Maix Go ## 教程&快速上手 <a href \"/soft/maixpy/zh/\" target \"_blank\"> MaixPy </a> ## 描述 MAIX Go开发板是SiPEED公司MAIX产品线的一员，基于嘉楠堪智科技的边缘智能计算芯片K210(RISC V架构 64位双核)设计的一款AIOT开发板。设计成数码相机的样式，板载Type C接口和USB UART电路，用户可以直接通过USB Type C线连接电脑进行开发，配置128Mbit Flash、LCD、DVP、Micro SD卡等接口并把所有IO引出，方便用户扩展。 ## 外观 <img src \"./../assets/dk_board/maix_go/Go.jpg\" alt \"Maxi go\" > ## 特性 MAIX Go开发板以K210作为核心单元，功能非常很强大，芯片内置64位双核处理器，拥有8M的片上SRAM，在Al机器视觉、听觉性能方便表现突出，内置多种硬件加速单元(KPU、FPU，FFT等)，总算力最高可达1TOPS，可以方便地实现各类应用场景的机器视觉/听觉算法,也可以进行语音方向扫描和语音数据输出的前置处理工作。 ## 应用 智能家居，机器人清洁器，智能扬声器，电子门锁，家庭监控等; 医学行业应用，如辅助诊断，医学图像识别; 智能工业应用，如工业机械，智能分拣，电气设备监控等; 教育机器人，智能互动平台，教育效率检查等教育应用; 农业应用，如农业监测，病虫害监测，自动控制等 ## 参数 <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">K210 芯片基本参数</th> </tr> </thead> <tbody> <tr> <td>内核</td> <td>RISC V Dual Core 64bit, with FPU</td> </tr> <tr> <td>主频</td> <td>400MHz （可超频至600MHz）</td> </tr> <tr> <td>SRAM</td> <td>内置8M Byte</td> </tr> <tr> <td>图像识别</td> <td>QVGA@60fps/VGA@30fps</td> </tr> <tr> <td>语音识别</td> <td>麦克风阵列(8mics)</td> </tr> <tr> <td>网络模型</td> <td><li>支持YOLOv3<li>Mobilenetv2<li>TinyYOLOv2<li>人脸识别等</td> </tr> <tr> <td>深度学习框架</td> <td>支持TensorFlow \\ Keras \\ Darknet \\ Caffe 等主流框架</td> </tr> <tr> <td>外设</td> <td>FPIOA、 UART、 GPIO、 SPI、 I2C、I2S、 TIMER</td> </tr> <tr> <td>视频处理</td> <td><li>神经网络处理器(KPU)<li>FPU满足IEEE754 2008标准<li>音频处理器(APU)<li>快速傅里叶变换加速器(FFT)</td> </tr> </tbody> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\" >开发板参数</th> </tr> </thead> <td> 板载资源</td> <td><li>三向拨轮按键 <li>RGB灯*1<li>1W 小喇叭<li>USB to UART<li>16Mbit Flash*1</td> </tr> <tr> <td>板载接口</td> <td><li>USB Type C接口<li>24PIN DVP摄像头接口<li>24PIN LCD接口<li>MicroSD卡槽<li>麦克风阵列接口<li>部分IO排针引脚引出</td> </tr> <tr> <td>尺寸</td> <td>60*88mm</td> </tr> <tr> <td>供电电压</td> <td>5.0V @ 300mA（供电电流需大于300mA）</td> </tr> <tr> <td>工作温度</td> <td> 30℃ ~85C</td> </tr> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">软件开发</th> <tr> </thead> <tr> <td>芯片操作系统</td> <td>FreeRTOS、RT Thread等</td> </tr> <tr> <td>开发环境</td> <td>MaixPy IDE、PlatformlO IDE、Arduino IDE等</td> </tr> <tr> <td>编程语言</td> <td>C，C++，MicroPython</td> </tr> </table> ## 资料下载 Sipeed Maix Go 资料下载：[Sipeed Maix Go](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix GO) ## 产品技术支持 Maix系列产品可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maix/maixpy_develop_kit_board/maix_nano.html":{"title":"Maix nano","content":"# Maix nano ## 教程&快速上手 相关的使用教程入口<a href \"./../../../../soft/maixpy/zh/\" target \"_blank\"> MaixPy </a> ## 描述 MAIX Nano开发板是SiPEED公司MAIX产品线的一员，基于嘉楠堪智科技的边缘智能计算芯片K210(RISC V架构 64位双核)设计的一款AIOT开发板。开发板使用模块+底板方式设计，整洁小巧，板载Type C接口和USB UART电路，用户可以直接通过USB Type C线连接电脑进行开发，配置128Mbit Flash、LCD、DVP、Micro SD卡等接口并把所有IO引出，方便用户扩展。 ## 外观 <img src \"./../assets/dk_board/maix_nano/maix_nano.jpg\" alt \"Maxi nano\" > ## 特性 MAIX Nano开发板以K210作为核心单元，功能非常很强大，芯片内置64位双核处理器，拥有8M的片上SRAM，在Al机器视觉、听觉性能方便表现突出，内置多种硬件加速单元(KPU、FPU，FFT等)，总算力最高可达1TOPS，可以方便地实现各类应用场景的机器视觉/听觉算法,也可以进行语音方向扫描和语音数据输出的前置处理工作。 ## 应用 智能家居，机器人清洁器，智能扬声器，电子门锁，家庭监控等; 医学行业应用，如辅助诊断，医学图像识别; 智能工业应用，如工业机械，智能分拣，电气设备监控等; 教育机器人，智能互动平台，教育效率检查等教育应用; 农业应用，如农业监测，病虫害监测，自动控制等 ## 参数 ![maix_nano](./../assets/dk_board/maix_nano/maix_nano.png) <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">K210 芯片基本参数</th> </tr> </thead> <tbody> <tr> <td>内核</td> <td>RISC V Dual Core 64bit, with FPU</td> </tr> <tr> <td>主频</td> <td>400MHz （可超频至600MHz）</td> </tr> <tr> <td>SRAM</td> <td>内置8M Byte</td> </tr> <tr> <td>图像识别</td> <td>QVGA@60fps/VGA@30fps</td> </tr> <tr> <td>语音识别</td> <td>麦克风阵列(8mics)</td> </tr> <tr> <td>网络模型</td> <td><li>支持YOLOv3<li>Mobilenetv2<li>TinyYOLOv2<li>人脸识别等</td> </tr> <tr> <td>深度学习框架</td> <td>支持TensorFlow \\ Keras \\ Darknet \\ Caffe 等主流框架</td> </tr> <tr> <td>外设</td> <td>FPIOA、 UART、 GPIO、 SPI、 I2C、I2S、 TIMER</td> </tr> <tr> <td>视频处理</td> <td><li>神经网络处理器(KPU)<li>FPU满足IEEE754 2008标准<li>音频处理器(APU)<li>快速傅里叶变换加速器(FFT)</td> </tr> </tbody> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\" >开发板参数</th> </tr> </thead> <td> 板载资源和接口</td> <td><li>DVP摄像头接口*1 <li>大部分IO通过金手指方式引出，方便二次开发<li>USB to UART<li>128Mbit Flash*1</td> </tr> <tr> <td>尺寸</td> <td>25.0*22.0mm</td> </tr> <tr> <td>供电电压</td> <td>5.0V @ 300mA（供电电流需大于300mA)</td> </tr> <tr> <td>工作温度</td> <td> 30℃ ~85C</td> </tr> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">软件开发</th> <tr> </thead> <tr> <td>芯片操作系统</td> <td>FreeRTOS、Standrad development ki等</td> </tr> <tr> <td>开发环境</td> <td>MaixPy IDE、PlatformlO IDE、Arduino IDE等</td> </tr> <tr> <td>编程语言</td> <td>C，C++，MicroPython</td> </tr> </table> ## 资料下载 M1n 资料下载：[dl.sipeed.com](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed M1n) M1n 原理图下载：[Sipeed M1n Datasheet V1.0.pdf](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed M1n/Sipeed%20M1n%20Datasheet%20V1.0.pdf) ## 产品技术支持 Maix系列产品可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maix/maixpy_develop_kit_board/develop_kit_board.html":{"title":"Maix 系列开发板","content":"# Maix 系列开发板 ## Maix 系列开发板 目前 MaixPy 系列开发板有一下这几款型号: Maix Go Maix Dock Maix Duino Maix Bit Maix Cube Maix Amigo <style type \"text/css\"> th { background color: #fbfbfb; border: 2px solid #f1f1f1; } </style> ## 差异对比 <table> <tbody> <tr> <th width \"226\" scope \"col\" >&nbsp;</th> <th width \"226\" scope \"col\" ><a href \"maix_go.html\"><img src \"../assets/dk_board/maix_go/Go.jpg\" width \"200\" alt \"\"/></a></th> <th width \"226\" scope \"col\"><a href \"maix_bit.html\"><img src \"../assets/dk_board/maix_bit/Bit.png\" width \"200\" alt \"Bit\"/></a></th> <th width \"226\" scope \"col\"><a href \"maix_cube.html\"><img src \"../assets/dk_board/maix_cube/maix_cube_1.png\" width \"200\" alt \"maix_cube\"/></a></th> <th width \"226\" scope \"col\"><a href \"Maix_dock.html\"><img src \"../assets/dk_board/maix_dock/Dan_Dock.png\" width \"200\" alt \"\"/></a></th> <th width \"226\" scope \"col\"><a href \"maix_duino.html\"><img src \"../assets/dk_board/maix_duino/DSC_08141.png\" width \"200\" alt \"\"/></a></th> <th width \"226\" scope \"col\"><a href \"maix_Amigo.html\"><img src \"../assets/dk_board/maxi_amigo/amigo.png\" width \"200\" alt \"\"/></a> </th> </tr> <tr> <td>型号 </td> <td>Maix Go</td> <td>Maix Bit</td> <td>Maix Cube</td> <td><p>Maix Dock</p></td> <td>Maix Duino</td> <td>Maix Amigo</td> </tr> <tr> <td>USB IC</td> <td>STM32</td> <td>CH552/CH340</td> <td>GD32/CH552</td> <td>CH340</td> <td>CH552</td> <td>GD32</td> </tr> <tr> <td>核心模块</td> <td>M1</td> <td>M1</td> <td>M1n</td> <td>M1/M1W</td> <td>M1</td> <td>M1n</td> </tr> <tr> <td height \"48\">WIFI 功能</td> <td>M1W 模块集成 ESP8285</td> <td> </td> <td> </td> <td>Dock M1 (不支持 WIFI)<br/> Dock M1W(支持,M1W 模块集成 ESP8285)</td> <td>板载 ESP32 （支持 WIFI, 蓝牙功能暂时未支持）</td> <td> </td> </tr> </tbody> </table> ## 产品技术支持 Maix系列产品可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maix/maixpy_develop_kit_board/maix_bit.html":{"title":"Maix Bit","content":"# Maix Bit ## 教程&快速上手 相关的使用教程入口<a href \"/soft/maixpy/zh/\" target \"_blank\"> MaixPy </a> ## 描述 MAIX Bit开发板是SiPEED公司MAIX产品线的一员，基于嘉楠堪智科技的边缘智能计算芯片K210(RISC V架构 64位双核)设计的一款AIOT开发板。经典两侧排针设计，可以直接配合面包板使用，板载Type C接口和USB UART电路，用户可以直接通过USB Type C线连接电脑进行开发，配置128Mbit Flash、LCD、DVP、Micro SD卡等接口并把所有IO引出，方便用户扩展。 ## 外观 <img src \"./../assets/dk_board/maix_bit/Bit.png\" alt \"Maxi bit\" > ## 特性 MaixBit开发板以K210作为核心单元，功能非常很强大，芯片内置64位双核处理器，拥有8M的片上SRAM，在Al机器视觉、听觉性能方便表现突出，内置多种硬件加速单元(KPU、FPU，FFT等)，总算力最高可达1TOPS，可以方便地实现各类应用场景的机器视觉/听觉算法,也可以进行语音方向扫描和语音数据输出的前置处理工作。 ## 应用 智能家居，机器人清洁器，智能扬声器，电子门锁，家庭监控等; 医学行业应用，如辅助诊断，医学图像识别; 智能工业应用，如工业机械，智能分拣，电气设备监控等; 教育机器人，智能互动平台，教育效率检查等教育应用; 农业应用，如农业监测，病虫害监测，自动控制等 ## 参数 <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">K210 芯片基本参数</th> </tr> </thead> <tbody> <tr> <td>内核</td> <td>RISC V Dual Core 64bit, with FPU</td> </tr> <tr> <td>主频</td> <td>400MHz （可超频至600MHz）</td> </tr> <tr> <td>SRAM</td> <td>内置8M Byte</td> </tr> <tr> <td>图像识别</td> <td>QVGA@60fps/VGA@30fps</td> </tr> <tr> <td>语音识别</td> <td>麦克风阵列(8mics)</td> </tr> <tr> <td>网络模型</td> <td><li>支持YOLOv3<li>Mobilenetv2<li>TinyYOLOv2<li>人脸识别等</td> </tr> <tr> <td>深度学习框架</td> <td>支持TensorFlow \\ Keras \\ Darknet \\ Caffe 等主流框架</td> </tr> <tr> <td>外设</td> <td>FPIOA、 UART、 GPIO、 SPI、 I2C、I2S、 TIMER</td> </tr> <tr> <td>视频处理</td> <td><li>神经网络处理器(KPU)<li>FPU满足IEEE754 2008标准<li>音频处理器(APU)<li>快速傅里叶变换加速器(FFT)</td> </tr> </tbody> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\" >开发板参数</th> </tr> </thead> <td> 板载资源</td> <td><li>按键*2 <li>RGB灯*1<li>MEMS Microphone*1<li>USB to UART<li>128Mbit Flash*1</td> </tr> <tr> <td>板载接口</td> <td><li>USB Type C接口<li>24PIN DVP摄像头接口<li>24PIN LCD接口<li>MicroSD卡槽<li>所有IO排针引脚引出</td> </tr> <tr> <td>尺寸</td> <td>53.3*25.4mm</td> </tr> <tr> <td>供电电压</td> <td>5.0V @ 300mA（供电电流需大于300mA)</td> </tr> <tr> <td>工作温度</td> <td> 30℃ ~85C</td> </tr> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">软件开发</th> <tr> </thead> <tr> <td>芯片操作系统</td> <td>FreeRTOS、RT Thread等</td> </tr> <tr> <td>开发环境</td> <td>MaixPy IDE、PlatformlO IDE、Arduino IDE等</td> </tr> <tr> <td>编程语言</td> <td>C，C++，MicroPython</td> </tr> </table> ## 资料下载 Sipeed Maix Bit 资料下载：[Sipeed Maix Bit](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix Bit/Maix Bit_V2.0_with_MEMS_microphone) Sipeed Maix Bit 规格书下载：[Sipeed Maix Bit](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Maix Bit/Specifications/Sipeed%20Maix Bit%20%E8%A7%84%E6%A0%BC%E4%B9%A6%20V2.0.pdf) Sipeed Maix Bit 原理图下载：[Sipeed Maix Bit](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Maix Bit/Maix Bit_V2.0_with_MEMS_microphone/Maix Bit_V2.0_Schematic.pdf) ## 产品技术支持 Maix系列产品可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maix/maixpy_develop_kit_board/Maix_dock.html":{"title":"Maix Dock(M1/M1W)","content":"# Maix Dock(M1/M1W) ## 教程&快速上手 <a href \"/soft/maixpy/zh/\" target \"_blank\"> MaixPy </a> ## 描述 MAIX Dock开发板是SiPEED公司MAIX产品线的一员，基于嘉楠堪智科技的边缘智能计算芯片K210(RISC V架构 64位双核)设计的一款AIOT开发板。化繁为简的设计，整洁小巧，板载Type C接口和USB UART电路，用户可以直接通过USB Type C线连接电脑进行开发，配置128Mbit Flash、LCD、DVP、Micro SD卡等接口并把所有IO引出，方便用户扩展。 > 上电即可开机，不需要开机操作 <img src \"./../assets/dk_board/maix_dock/Maix_Dock.jpg\" alt \"11\" width \"300\"> ## 外观 <img src \"./../assets/dk_board/maix_dock/Maix_Dock_3.png\" alt \"11\" > <img src \"./../assets/dk_board/maix_dock/Maix_Dock_2.png\" alt \"11\" > ## 特性 MaixDock 开发是以M1W AI模块作为核心单元，功能非常强大。模块内置64位双核处理器芯片，拥有8M的片上SRAM，在AI机器视觉、听觉性能方面表现突出，内置多种硬件加速单元（KPU、FPU、FFT等），总算力最高可达1TOPS，可以方便地实现各类应用场景的机器视觉/听觉算法，也可以进行语言方向扫描和语言数据输出的前置处理工作。 ## 应用 智能家居，机器人清洁器，智能扬声器，电子门锁，家庭监控等; 医学行业应用，如辅助诊断，医学图像识别; 智能工业应用，如工业机械，智能分拣，电气设备监控等; 教育机器人，智能互动平台，教育效率检查等教育应用; 农业应用，如农业监测，病虫害监测，自动控制等 ## 参数 <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">K210 芯片基本参数</th> </tr> </thead> <tbody> <tr> <td>内核</td> <td>RISC V Dual Core 64bit, with FPU</td> </tr> <tr> <td>主频</td> <td>400MHz （可超频至600MHz）</td> </tr> <tr> <td>SRAM</td> <td>内置8M Byte</td> </tr> <tr> <td>图像识别</td> <td>QVGA@60fps/VGA@30fps</td> </tr> <tr> <td>语音识别</td> <td>麦克风阵列(8mics)</td> </tr> <tr> <td>网络模型</td> <td><li>支持YOLOv3<li>Mobilenetv2<li>TinyYOLOv2<li>人脸识别等</td> </tr> <tr> <td>深度学习框架</td> <td>支持TensorFlow \\ Keras \\ Darknet \\ Caffe 等主流框架</td> </tr> <tr> <td>外设</td> <td>FPIOA、 UART、 GPIO、 SPI、 I2C、I2S、 TIMER</td> </tr> <tr> <td>视频处理</td> <td><li>神经网络处理器(KPU)<li>FPU满足IEEE754 2008标准<li>音频处理器(APU)<li>快速傅里叶变换加速器(FFT)</td> </tr> </tbody> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\" >开发板参数</th> </tr> </thead> <td> 板载资源</td> <td><li>按键*2 <li>RGB灯*1<li>MEMS Microphone*1<li>USB to UART<li>128Mbit Flash*1</td> </tr> <tr> <td>板载接口</td> <td><li>USB Type C接口<li>24PIN DVP摄像头接口<li>24PIN LCD接口<li>MicroSD卡槽<li>音频接口(支持外接2x3W扬声器)<li>所有IO排针引脚引出</td> </tr> <tr> <td>尺寸</td> <td>52.3*37.3mm</td> </tr> <tr> <td>供电电压</td> <td>5.0V @ 300mA（供电电流需大于300mA)</td> </tr> <tr> <td>工作温度</td> <td> 30℃ ~85C</td> </tr> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">软件开发</th> <tr> </thead> <tr> <td>芯片操作系统</td> <td>FreeRTOS、RT Thread等</td> </tr> <tr> <td>开发环境</td> <td>MaixPy IDE、PlatformlO IDE、Arduino IDE等</td> </tr> <tr> <td>编程语言</td> <td>C，C++，MicroPython</td> </tr> </table> ## 资料 Sipeed Maix Dock 资料下载：[Sipeed Maix Dock](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix Dock) Sipeed Maix Dock 规格书下载：[Sipeed Maix Dock](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix Dock/Specifications) Sipeed Maix Dock 原理图下载：[Sipeed Maix Dock](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Maix Dock/Maix Dock_11.27/Maix Dock_11.27 schematic.pdf) ## 产品技术支持 Maix系列产品可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maix/maixpy_develop_kit_board/maix_cube.html":{"title":"MaixCube","content":"# MaixCube ## 使用教程 <a href \"/soft/maixpy/zh/\" target \"_blank\"> MaixPy </a> ## 概述 SIPEED MaixCube 是基于我们 M1n 模块(主控:Kendryte K210)开发的一款集学习开发和商用一体的人脸识别产品. <br/>MaixCube 集成摄像头、TF卡槽、用户按键、TFT显示屏、锂电池、扬声器麦克、扩展接口等, 用户可使用 Maix Cube 轻松搭建一款人脸识别门禁系统, 同时还预留开发调试接口, 也能将其作为一款功能强大的 AI 学习开发板. ## MaixCube 外观及功能介绍 ### 外观一览 ![maixcube_product_appearance](./../assets/dk_board/maix_cube/maixcube_product_appearance.png) ### 板载功能介绍 电源管理控制单元: AXP173 板载 200mAh 锂电池,支持用户充放电控制 音频驱动 IC: ES8374 支持音频录制,播放 三轴加速度传感器: MSA301 Camera OV7740: 1.3 IPS LCD: RGB: 板载两颗 RGB LED USB Type C:Type C 接口,正反盲插 ### 板载扩展接口 Maix Cube 对用户开放了两个高度扩展的接口: SP MOD 与 Grove 接口, 用户可以很方便的进行 DIY #### SP MOD 接口 SP MOD 即为 sipeed module, simplify PMOD, super module 接口 接口描述 SP MODE 接口描述![spmod_interface_1](./../../../assets/spmod/spmod_interface_1.png) 硬件接口![spmod_interface_2](./../../../assets/spmod/spmod_interface_2.png) #### Grove 接口 Grove 模块接口 Grove 接口的线缆有 4 种颜色, 用户可以根据颜色快速区别 ![grove_interface](./../assets/interface_grove/grove_interface.jpg) 颜色 描述 pin 1 黄色 (例如, I2C Grove Connectors上的SCL) pin 2 白色 (例如, I2C Grove Connectors上的SDA) pin 3 红色 VCC (所有的Grove接口红色都是VCC) pin 4 黑色 GND (所有的Grove接口红色都是GND) Grove模块主要有 4 种接口: Grove Digital 数字接口: Grove 数字接口由 Grove 插头的四条标准线组成. 两条信号线通常称为 D0 和 D1 . 大多数模块只使用 D0, 但有些(像LED Bar Grove显示屏)使用两者.通常核心板会将板卡上的第一个Grove连接头称为 D0, 第二个称为 D1.第一个接头会连接到主控芯片的 DO/D1 管脚, 第二个连接头会连接到主控芯片的D1/D2引脚, 后面的连接头以此类推. pin Function Note pin1 Dn 第一个数字输入 pin2 Dn+1 第二个数字输入 pin3 VCC 供电引脚 5V/3.3V pin4 GND 地 Grove Analog 模拟接口 Grove模拟接口由Grove插头的四条标准线组成. 两条信号线通常称为A0和A1. 大多数模块只使用A0，但有些（像LED Bar Grove显示屏）使用两者. 通常核心板会将板卡上的第一个Grove连接头称为A0，第二个称为A1。第一个接头会连接到主控芯片的AO/A1管脚，第二个连接头会连接到主控芯片的A1/A2引脚，后面的连接头以此类推. pin Function Note pin1 An 第一个模拟输入 pin2 An+1 第二个模拟输入 pin3 VCC 供电引脚 5V/3.3V pin4 GND 地 Grove UART : The Grove UART 是特殊的一种数字输入输出接口 它使用引脚 1 和引脚 2 进行串行输入和发送 引脚1是 RX 线(用于接收数据, 因此是输入) 其中引脚 2 是 TX 线(用于向 Grove 模块传输数据) pin Function Note pin1 RX 串行接收 pin2 TX 串行发送 pin3 VCC 供电引脚 5V/3.3V pin4 GND 地 Grove I2C: 有许多类型的 I2C Grove 传感器可用.MaixAmigo 上的 Grove 只支持 3.3V 传感器 Grove I2C 连接器具有标准布局.引脚 1 是SCL信号, 引脚 2 是SDA信号 pin Function Note pin1 SCL I2C 时钟 pin2 SDA I2C 数据 pin3 VCC 供电引脚, 5V/3.3V pin4 GND 地 ### 板载 I2C 设备 MaixCube 板载 I2C 传感器/IC IC 设备 id I2C 地址(7位地址) ES83740x080x10 MSA3010x130x26 AXP1730x680x34 ## MaixCube参数 ![maixcube_resources](./../assets/dk_board/maix_cube/maixcube_resources.png) <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">K210 芯片基本参数</th> </tr> </thead> <tbody> <tr> <td>内核</td> <td>RISC V Dual Core 64bit, with FPU</td> </tr> <tr> <td>主频</td> <td>400MHz （可超频至500MHz）</td> </tr> <tr> <td>SRAM</td> <td>内置8M Byte</td> </tr> <tr> <td>摄像头帧率</td> <td>OV7740/QVGA@60fps/VGA@30fps</td> </tr> <tr> <td>语音识别</td> <td>离线语音识别，声场</td> </tr> <tr> <td>网络模型</td> <td><li>支持MobileNetV1/V2<li>人脸识别<li>ASR</td> </tr> <tr> <td>深度学习框架</td> <td>支持TensorFlow \\ Keras \\ Darknet \\ Caffe 等主流框架</td> </tr> <tr> <td>外设</td> <td>FPIOA、 UART、 GPIO、 SPI、 I2C、I2S、 TIMER</td> </tr> <tr> <td>硬件加速单元</td> <td><li>KPU卷积运算加速器<li>FPU浮点运算加速器<li>APU音频处理器<li>FFT傅里叶变换加速器</td> </tr> </tbody> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\" >开发板参数</th> </tr> </thead> <td> 板载资源</td> <td><li>按键*3<li>摄像头*1<li>RGB LED*2 <li>1.3寸TFT屏幕<li>Electret Microphone*1<li>128Mbit Flash*1<li>加速度传感器*1<li>0.5W扬声器</td> </tr> <tr> <td>板载接口</td> <td><li>USB Type C接口<li>TF卡槽<li>Grove标准接口<li>SP MOD接口(支持SP MOD接口模块)</td> </tr> <tr> <td>尺寸</td> <td>40*40*18.6mm</td> </tr> <tr> <td>供电电压</td> <td>USB type或内部锂电池（200mAh）</td> </tr> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">软件开发</th> <tr> </thead> <tr> <td>软件环境</td> <td>MaixPy（microPython）</td> </tr> <tr> <td>开发环境</td> <td>MaixPy IDE、PlatformlO IDE、Arduino IDE等</td> </tr> <tr> <td>编程语言</td> <td>C，MicroPython</td> </tr> </table> ## 相关资料下载 Sipeed Maix Cube 资料下载：[Sipeed Maix Cube](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix Cube) Sipeed Maix Cube 规格书下载：[Sipeed Maix Cube](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix Cube/ProductSpecification/Sipeed%20Maix%20Cube%20Datasheet%20V1.0.pdf) Sipeed Maix Cube 原理图下载：[Sipeed Maix Cube.pdf](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix Cube/Maix Cube 2757) ## 产品技术支持 Maix系列产品可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maix/maixpy_develop_kit_board/maix_hat.html":{"title":"Grove AI HAT","content":" title: Grove AI HAT keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy Grove AI HAT ## 外观及功能介绍 ### 外观一览 ![Grove AI HAT](./../../../../soft/maixpy/assets/hardware/grove_ai_hat/grove_ai_hat1.png) ### 板载功能 项目 说明 CPU： 双核 64bit RISC V / 400MHz (双精度FPU集成) 内存： 8MiB 64bit 片上 SRAM 存储： 16MiB Flash 屏幕（套餐）： 2.4 寸 TFT, 电容触摸屏幕分辨率：320\\*240 摄像头（套餐）： 搭载 **OV7740** 或 **OV5642** **30W** 像素 **Sensor** 按键： 复位按键，电源按键（短按开机，长按 *8S* 关机） USB： Type C 接口，正反盲插 板载传感器： 三轴加速度传感器（ADXL345BCCZ RL），ADC（ADS1115IDGS） ### 硬件板载扩展接口 该开发版对用户开放了四个 [Grove](https://wiki.sipeed.com/soft/maixpy/zh/modules/grove/index.html) 接口,用户可以很方便的进行 DIY。 ### 板载 I2C 设备 传感器 功能 I2C 地址(7位地址) SCL SDA 示例代码 ADS1115 ADC 0x48 IO23 IO24 [script](https://github.com/sipeed/MaixPy_scripts/tree/master/modules/others/ads1115) ADXL345 三轴加速度计 0x53 IO23 IO24 [script](https://github.com/sipeed/MaixPy_scripts/tree/master/modules/others/adxl345) ## 资源下载 [原理图](http://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Grove_AI_HAT/Grove_AI_HAT_for_Edge_Computing_v1.0_SCH_190514.pdf)"},"/hardware/zh/maix/maixpy_develop_kit_board/maix_Amigo.html":{"title":"MaixAmigo","content":"# MaixAmigo ## 使用教程 <a href \"/soft/maixpy/zh/\" target \"_blank\"> MaixPy </a> ## 概述 SIPEED MaixAmigo 是基于我们 M1n 模块(主控:Kendryte K210)开发的一款集学习开发和商用一体的人脸识别产品. <br/>MaixAmigo 集成前后摄像头、TF卡槽、用户按键、TFT显示屏、锂电池、扬声器麦克风、扩展接口等, 用户可使用 MaixAmigo 轻松搭建一款人脸识别门禁系统, 同时还预留开发调试接口, 也能将其作为一款功能强大的 AI 学习开发板. ## MaixAmigo 外观及功能介绍 ### 外观一览 ![MaixAmigo](./../assets/dk_board/maxi_amigo/image 20200730120223557.png) ### 板载硬件功能介绍 3.5 寸 **TFT** 屏幕: 分辨率 **320x480*** 3.5 寸电阻触摸屏： FT6X36 芯片复位按键 电源按键: 短按开机, 长按 *8S* 关机 三个功能按键 Grove 接口: 板载 3 个**Grove** 数字接口, 传感器,控制器扩展无限可能~ SP MOD 接口: 板载 3 个更加强大,更高扩展性的 **SP MOD** 数字接口, I2C,SPI(标准,双线,四线模式)等接口均可以使用 后续支持乐高手柄功能 TF 卡槽: 多媒体资源扩展,支持大容量储存 摄像头: 搭载 **OV7740** **30W** 像素 与 **GC0328 30W 像素** **Sensor** Type C 接口: USB TypeC 电源、调试接口,正反盲插 电源管理控制单元: AXP173 板载 600mAh 锂电池,支持用户充放电控制 音频驱动 IC: ES8374 支持音频录制,播放 三轴加速度传感器: MSA301 ### 板载扩展接口 MaixAmigo 对用户开放了两个高度扩展的接口: SP MOD 与 Grove 接口, 用户可以很方便的进行 DIY #### SP MOD 接口 SP MOD 即为 sipeed module, simplify PMOD, super module 接口 接口描述 SP MODE 接口描述![spmod_interface_1](./../../../assets/spmod/spmod_interface_1.png) 硬件接口![spmod_interface_2](./../../../assets/spmod/spmod_interface_2.png) #### Grove 接口 Grove 接口的线缆有 4 种颜色, 用户可以根据颜色快速区别 ![grove_interface](./../assets/interface_grove/grove_interface.jpg) pin 颜色 描述 pin 1 黄色 (例如, I2C Grove Connectors上的SCL) pin 2 白色 (例如, I2C Grove Connectors上的SDA) pin 3 红色 VCC (所有的Grove接口红色都是VCC) pin 4 黑色 GND (所有的Grove接口红色都是GND) Grove模块主要有 4 种接口: Grove Digital 数字接口: Grove 数字接口由 Grove 插头的四条标准线组成. 两条信号线通常称为 D0 和 D1 . 大多数模块只使用 D0, 但有些(像LED Bar Grove显示屏)使用两者.通常核心板会将板卡上的第一个Grove连接头称为 D0, 第二个称为 D1.第一个接头会连接到主控芯片的 DO/D1 管脚, 第二个连接头会连接到主控芯片的D1/D2引脚, 后面的连接头以此类推. pin Function Note pin1 Dn 第一个数字输入 pin2 Dn+1 第二个数字输入 pin3 VCC 供电引脚 5V/3.3V pin4 GND 地 Grove Analog 模拟接口 Grove模拟接口由Grove插头的四条标准线组成. 两条信号线通常称为A0和A1. 大多数模块只使用A0，但有些（像LED Bar Grove显示屏）使用两者. 通常核心板会将板卡上的第一个Grove连接头称为A0，第二个称为A1。第一个接头会连接到主控芯片的AO/A1管脚，第二个连接头会连接到主控芯片的A1/A2引脚，后面的连接头以此类推. pin Function Note pin1 An 第一个模拟输入 pin2 An+1 第二个模拟输入 pin3 VCC 供电引脚 5V/3.3V pin4 GND 地 Grove UART : The Grove UART 是特殊的一种数字输入输出接口 它使用引脚 1 和引脚 2 进行串行输入和发送 引脚1是 RX 线(用于接收数据, 因此是输入) 其中引脚 2 是 TX 线(用于向 Grove 模块传输数据) pin Function Note pin1 RX 串行接收 pin2 TX 串行发送 pin3 VCC 供电引脚 5V/3.3V pin4 GND 地 Grove I2C: 有许多类型的 I2C Grove 传感器可用.MaixAmigo 上的 Grove 只支持 3.3V 传感器 Grove I2C 连接器具有标准布局.引脚 1 是SCL信号, 引脚 2 是SDA信号 pin Function Note pin1 SCL I2C 时钟 pin2 SDA I2C 数据 pin3 VCC 供电引脚, 5V/3.3V pin4 GND 地 ### 板载 I2C 设备 MaixAmigo 板载 I2C 传感器/IC IC 设备 id I2C 地址(7位地址) ES8374 0x08 0x10 MSA301 0x13 0x26 AXP173 0x68 0x34 ## 参数 Maix Amigo内置64位400Mhz双核高性能处理器,拥有8M的片上SRAM，16MiB FLASH大容量存储,轻松处理多媒体应用,在AI机器视觉、听觉性能方便表现突出，内置多种硬件加速单元（KPU、FPU，FFT等)，总算力最高可达1TOPS,可以方便地实现各类应用场景的机器视觉/听觉算法,也可以进行语音扫描和语音数据输出的前置处理工作 <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">K210 芯片基本参数</th> </tr> </thead> <tbody> <tr> <td>内核</td> <td>RISC V Dual Core 64bit, with FPU</td> </tr> <tr> <td>主频</td> <td>400MHz （可超频至600MHz）</td> </tr> <tr> <td>SRAM</td> <td>内置8M Byte</td> </tr> <tr> <td>摄像头帧率</td> <td>OV7740/QVGA@60fps/VGA@30fps</td> </tr> <tr> <td>语音识别</td> <td>离线语音识别，声场</td> </tr> <tr> <td>网络模型</td> <td><li>支持MobileNetV1/V2<li>人脸识别<li>ASR</td> </tr> <tr> <td>深度学习框架</td> <td>支持TensorFlow \\ Keras \\ Darknet \\ Caffe 等主流框架</td> </tr> <tr> <td>外设</td> <td>FPIOA、 UART、 GPIO、 SPI、 I2C、I2S、 TIMER</td> </tr> <tr> <td>硬件加速单元</td> <td><li>KPU卷积运算加速器<li>FPU浮点运算加速器<li>APU音频处理器<li>FFT傅里叶变换加速器</td> </tr> </tbody> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\" >开发板参数</th> </tr> </thead> <td> 板载资源</td> <td><li>3.5寸TFT屏幕<li>复位按键*1<li>功能按键*3<li>前后摄像头*2<li>LED*3<li>加速度传感器*1</td> </tr> <tr> <td>板载接口</td> <td><li>USB Type C接口<li>音频接口(支持外接扬声器)<li>TF卡槽<li>Grove标准接口<li>SP MOD接口(支持SP MOD接口模块)</td> </tr> <tr> <td>尺寸</td> <td>104.3*63.3*16.5mm</td> </tr> <tr> <td>供电电压</td> <td>USB type或内部锂电池（520mAh）</td> </tr> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">软件开发</th> <tr> </thead> <tr> <td>软件环境</td> <td>MaixPy（microPython）</td> </tr> <tr> <td>开发环境</td> <td>MaixPy IDE、PlatformlO IDE、Arduino IDE等</td> </tr> <tr> <td>编程语言</td> <td>C，MicroPython</td> </tr> </table> ## 相关资料下载 Maix Amigo 资料下载：[Sipeed Amigo](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Amigo) Maix Amigo 规格书下载：[Sipeed Amigo](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Amigo/ProductSpecification) Maix Amigo IPS 版本 原理图下载：<a href \"https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Amigo/2970/Maix_Amigo_2970(Schematic).pdf\">Maix_Amigo_2970(Schematic).pdf</a> Maix Amigo TFT 版本 原理图下载：<a href \"https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Amigo/2960/Maix_Amigo_2960(Schematic).pdf\">Maix_Amigo_2960(Schematic).pdf</a> ## 产品技术支持 Maix系列产品可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maix/maixpy_develop_kit_board/maix_duino.html":{"title":"MaixDuino 开发板","content":"# MaixDuino 开发板 ## 概述 SIPEED MaixDuino 是基于我们 M1 模块(主控:Kendryte K210)开发的一款外形兼容 Arduino 的开发板 <br/>MaixDuino 集成摄像头、TF卡槽、用户按键、TFT显示屏、MaixDuino 扩展接口等, 用户可使用 MaixDuino 轻松搭建一款人脸识别门禁系统, 同时还预留开发调试接口, 也能将其作为一款功能强大的 AI 学习开发板. ## MaixDuino 外观及功能介绍 ### 外观一览 ![MaixDuino](./../assets/dk_board/maix_duino/maixduino_0.png) ![MaixDuino](./../assets/dk_board/maix_duino/maixduino_1.png) ![MaixDuino](./../assets/dk_board/maix_duino/maixduino_2.png) ### 板载功能介绍 电源输入 DC05: 6~12V 直流 电源输入 + 程序下载调试接口: USB Type C 接口 DVP 24PIN: 标准 Camera DVP 24PIN 接口 TF 扩展槽: ESP32: ESP32 SPI 连接(ESP32 支持 WIFI 与 蓝牙) I2C DAC PA PAM8403A ![MaixDuino](./../assets/dk_board/maix_duino/maixduino_3.jpg) ## MaixDuino参数 Maixduino开发板以M1Al模块作为核心单元，功能非常很强大，模块内置64位双核处理器芯片，拥有8M的片上SRAM，在Al机器视觉、听觉性能方便表现突出，内置多种硬件加速单元(KPU、FPU，FFT等)，总算力最高可达1TOPS，可以方便地实现各类应用场景的机器视觉/听觉算法,也可以进行语音方向扫描和语音数据输出的前置处理工作。此外，开发板还配置了ESP32模块(WiFi+蓝牙一体)，简单的操作即可轻松联网。 <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">K210 芯片基本参数</th> </tr> </thead> <tbody> <tr> <td>内核</td> <td>RISC V Dual Core 64bit, with FPU</td> </tr> <tr> <td>主频</td> <td>400MHz （可超频至600MHz）</td> </tr> <tr> <td>SRAM</td> <td>内置8M Byte</td> </tr> <tr> <td>图像识别</td> <td>QVGA@60fps/VGA@30fps</td> </tr> <tr> <td>语音识别</td> <td>麦克风阵列(8mics)</td> </tr> <tr> <td>网络模型</td> <td><li>支持YOLOv3<li>Mobilenetv2<li>TinyYOLOv2<li>人脸识别等</td> </tr> <tr> <td>深度学习框架</td> <td>支持TensorFlow \\ Keras \\ Darknet \\ Caffe 等主流框架</td> </tr> <tr> <td>外设</td> <td>FPIOA、 UART、 GPIO、 SPI、 I2C、I2S、 TIMER</td> </tr> <tr> <td>视频处理</td> <td><li>神经网络处理器(KPU)<li>FPU满足IEEE754 2008标准<li>音频处理器(APU)<li>快速傅里叶变换加速器(FFT)</td> </tr> </tbody> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">ESP32模块</th> </tr> </thead> <tr> <td>主控</td> <td>ESP32 D0WDQ6(Xtensa 32 bit内核)</td> </tr> <tr> <td>无线标准</td> <td>802.11b/g/n</td> </tr> <tr> <td>无线频率</td> <td>2400MHz 2483.5MHz</td> </tr> <tr> <td>无线协议</td> <td>2.4G WiFi+双模蓝牙(BT&BLE4.2)</td> </tr> <tr> <td>天线</td> <td>PCB板载天线</td> </tr> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\" >开发板参数</th> </tr> </thead> <td> 板载资源</td> <td><li>RGB灯*1<li>MEMS Microphone*1<li>USB转串口*1</td> </tr> <tr> <td>板载接口</td> <td><li>USB Type C接口<li>24PIN DVP摄像头接口<li>24PIN LCD接口<li>MicroSD卡槽<li>音频接口（支持外接3扬声器）<li>部分IO排针引脚引出</td> </tr> <tr> <td>尺寸</td> <td>60*88mm</td> </tr> <tr> <td>供电电压</td> <td>5.0V @ 300mA（供电电流需大于300mA)</td> </tr> <tr> <td>工作温度</td> <td> 30℃ ~85C</td> </tr> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">软件开发</th> <tr> </thead> <tr> <td>芯片操作系统</td> <td>FreeRTOS、RT Thread等</td> </tr> <tr> <td>开发环境</td> <td>MaixPy IDE、PlatformlO IDE、Arduino IDE等</td> </tr> <tr> <td>编程语言</td> <td>C，C++，MicroPython</td> </tr> </table> ## 资料相关链接 [MaixDuino 原理图](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maixduino) <a href \"/soft/maixpy/zh/\" target \"_blank\"> MaixPy的使用教程入口 </a> （推荐） <a href \"/soft/maixduino/zh/\" target \"_blank\"> arduino的使用教程入口 </a> ## 产品技术支持 Maix系列产品可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maix/core_module.html":{"title":"Sipeed M1/M1W","content":" title: Sipeed M1/M1W keywords: maixpy, k210, AIOT, 边缘计算, M1/M1W desc: maixpy Sipeed M1/M1W ## M1/M1W M1/M1W模块是基于嘉楠堪智科技的边缘智能计算芯片 K210 (RISC V架构) 设计的一款AIOT模块。主控芯片内置64位双核高性能低功耗处理器，每个核都有浮点运算单元(FPU) ,具备卷积人工神经网络硬件加速器(KPU)和快速傅里叶变换加速器(FFT)、搭载现场可编程IO阵列(FPIOA)，支持多种主流Al编程框架。M1W模块内置标准802.11 b/g/n协议的ESP8285 WiFi芯片，可让模块轻松联网。 ![M1/M1W](./assets/m1_m1w/M1_Dan.png) ## 应用 智能家居，机器人清洁器，智能扬声器，电子门锁，家庭监控等; 医学行业应用，如辅助诊断，医学图像识别; 智能工业应用，如工业机械，智能分拣，电气设备监控等; 教育机器人，智能互动平台，教育效率检查等教育应用; 农业应用，如农业监测，病虫害监测，自动控制等 ## M1/M1W 参数 M1/M1W Al模块系统主要由电源(3 Channel DC DC)、Flash芯片(16M)电路、K210芯片和WiFi芯片四部分组成。K210作为核心单元，功能非常很强大，芯片内置64位双核处理器，拥有8M的片上SRAM。模块在Al机器视觉、听觉性能方便表现突出，芯片总算力可达1TOPS，芯片内置多种硬件加速单元(KPU、FPU，FFT等)，可以方便地实现各类应用场景的机器视觉/听觉算法,也可以进行语音方向扫描和语音数据输出的前置处理工作。M1W模块嵌入无线WiFi功能，可轻松实现联网控制。 <p><img loading \"M1/M1W\" src \"./assets/m1_m1w/M1_vs_M1W.png\" width 500 ></p> <p><img loading \"M1/M1W\" src \"./assets/m1_m1w/M1_pin.png\" width 500 ></p> <p><img loading \"M1/M1W\" src \"./assets/m1_m1w/M1W_2.png\" width 500 ></p> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">K210 芯片基本参数</th> </tr> </thead> <tbody> <tr> <td>内核</td> <td>RISC V Dual Core 64bit, with FPU</td> </tr> <tr> <td>主频</td> <td>400MHz （可超频至600MHz）</td> </tr> <tr> <td>SRAM</td> <td>内置8M Byte</td> </tr> <tr> <td>图像识别</td> <td>QVGA@60fps/VGA@30fps</td> </tr> <tr> <td>语音识别</td> <td>麦克风阵列(8mics)</td> </tr> <tr> <td>神经网络模型</td> <td><li>支持YOLOv3<li>Mobilenetv2<li>TinyYOLOv2</td> </tr> <tr> <td>深度学习框架</td> <td>支持TensorFlow \\ Keras \\ Darknet \\ Caffe 等主流框架</td> </tr> <tr> <td>外设</td> <td>FPIOA、 UART、 GPIO、 SPI、 I2C、I2S、 TIMER</td> </tr> <tr> <td>视频处理</td> <td><li>神经网络处理器(KPU)<li>FPU满足IEEE754 2008标准<li>音频处理器(APU)<li>快速傅里叶变换加速器(FFT)</td> </tr> </tbody> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">模块软件</th> </tr> </thead> <tr> <td>操作系统</td><td>FreeRtos and Standrad development ki</td> </tr> <tr> <td>编程语言</td><td>MicroPython</td> </tr> <tr> <td>机器视觉</td><td>支持卷积神经网络</td> </tr> <tr> <td>机器听觉</td><td>高性能音频处理器(APU)</td> </tr> <tr> <td>开发环境</td><td>串口终端、MaixPy IDE</td> </tr> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">模块硬件</th> </tr> </thead> <tr> <td>尺寸</td><td>25.4*25.4*3.3mm</td> </tr> <tr> <td>引脚</td><td>72 PIN全引脚引出</td> </tr> <tr> <td>供电电压</td><td>5.0V @ 300mA（供电电流需大于300mA)</td> </tr> <tr> <td>工作温度</td><td> 30°C ~85°C</td> </tr> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">Wi Fi功能参数</th> </tr> </thead> <tr> <td>主控</td> <td>ESP8285</td> </tr> <tr> <td>无线标准</td><td>802.11 b/g/n</td> </tr> <tr> <td>频率范围</td><td>2400Mhz 2483.5Mhz</td> </tr> <tr> <td>天线</td><td>标准IPEX接口天线</td> </tr> <tr> <td>Wi Fi模式</td><td>支持Station / SoftAP /SoftAP+Station</td> </tr> </table> > 为了让Al模块能应用于更多场合，Sipeed团队还推出了无WiFi功能版本的M1模块，如果用户无需使用无线联网的功能，可以选择我们的M1模块。M1模块和M1W模块的AI功能一致，使用方法基本相同，主要区别就是M1W模块比M1模块多了WiFi功能。 ## 资料下载 芯片 K210 Datasheet: [Kendryte 官网](https://canaan creative.com/) M1W 资料下载: [dl.sipeed.com](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed M1&M1W) ## 产品技术支持 Maix系列产品可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maixface/mf_ml_module/mf1_ml_module.html":{"title":"MF 人脸识别模块 MF1","content":"# MF 人脸识别模块 MF1 ## **修改记录** 版本时间修改内容 1.02019.07.30初始版本 1.22020.08.1 ## 目录 [MF 人脸识别模块 MF1](#mf 人脸识别模块 mf1) [**修改记录**](#修改记录) [目录](#目录) [**硬件资源简介**](#硬件资源简介) [**功能简介**](#功能简介) <! [微信小程序模块](#微信小程序模块) > <! [二次开发](#二次开发) > <! [**Q&A**](#qa) > ## **硬件资源简介** <center class \"half\"> <img src \"./../assests/front.png\" width 50% /><img src \"assests/bottom.jpg\" width 50% /> </center> * CPU : **RISC V** 双核 64bit、内置FPU、频率 400Mhz 500Mhz * 图像识别：活体识别 * 双摄像头：红外（IR）+可见光（VIS） * 红外填充光：3W 红外发光二极管 * 显示器：1.33 英寸 IPS、分辨率 240*320显示屏 * 其他外设：电容触摸按钮/支持 3W 扬声器/MEMS 麦克风/SD NAND/RGB LED * 无线功能(可选) : 支持 2.4G 802.11.b/g/n、SPI 连接 * [淘宝购买](https://item.taobao.com/item.htm?spm a1z10.1 c.w4004 21231188695.25.27ba52b1bsusf7&id 599138281058) <div STYLE \"page break after: always;\"></div> ## **功能简介** ![MF1 引脚图](./../assets/mf_module/mf1/mf1_pin_map.png)"},"/hardware/zh/maixface/mf_ml_module/mf_update_firmwave.html":{"title":"MF 固件相关升级说明","content":"# MF 固件相关升级说明 在使用 **MF 人脸识别模块**过程中，如果存在固件存在 bug、有新功能固件 release、误擦除固件、字体资源、图片资源，那么就需要通过烧录还原固件。 ## MF 人脸识别模块固件、资源说明 **MF 人脸识别模块** 固件、字体资源、图片资源、说明如下： 类型 烧录地址 长度 说明 固件 0x000000 人脸模型 字体资源 图片资源 板级配置 0x7FF000 4 KB 人脸信息 0x800000 64 KB > 一般开发者在拿到 MF 模块之后，不需要关心该资源分布 MF 固件说明 固件分类 方向 协议 识别方式 wechat 固件类型数量 MF0 体验版模块 横版, 竖版 bin vis 2 MF1 离线版模块 横版，竖版 bin/json vis+ir 8 MF1_to_MF2 横版，竖版 bin/json vis+ir 8 MF2 微信半成品 横版，竖版 bin vis 支持 2 MF4 微信 (成品) 竖版 bin vis 支持 1 MF5 微信 (成品) 竖版 bin/json vis 支持 2 字体资源 图片资源 清除配信息 ## MF1 固件烧录(升级，还原出厂配置)步骤 在使用 **MF 人脸识别模块**过程中，如果存在固件存在 bug、有新功能固件 release、误擦除固件、字体资源、图片资源，那么就需要通过烧录还原固件。 烧录步骤： 1. 烧录 key_gen.bin 获取 key 2. 通过 support@sipeed.com 获取模型文件 3. 烧录模型文件 4. 烧录图片，字体资源， ### 准备： 在升级，还原出厂配置**MF 人脸识别模块** 之前我们需要准备软硬件。 **硬件准备：** **MF 人脸识别模块** USB Type C 数据线 **软件准备：** 烧录软件： kflash_gui(这里使用 kflash_gui v1.6.5 版本) 下载链接: Github: [kflash_gui](https://github.com/Sipeed/kflash_gui) Sipeed: [Sipeed 官方下载站 kflash_gui](https://dl.sipeed.com/MAIX/tools/kflash_gui/kflash_gui_v1.6.5) 烧录资源文件(根据情况烧录)：**MF 人脸识别模块固件**、算法模型文件、字体资源文件、图片资源文件 资源文件获取统一发送邮件到: Email: Support@sipeed.com 推荐发送邮件格式如下: > 问题类型: [MF 固件资源获取/（简短描述你的问题）] > > 使用硬件/固件版本: [MF0/MF1/MF2/MF4/MF5(这里标注使用的究竟是哪个模块、产品)] > > 内容: [最新固件获取/固件丢失/模型丢失(描述相关情况)] > > 机器码: [xxxxxxxxxxxxxxxxxxxxx(只有模型丢失时需要)] ### 烧录固件,资源文件 使用USB Type C 数据线 将**MF 人脸识别模块** 连接 电脑 ![MF1 connect USB](./../assets/mf_module/mf1/mf1_view.png) 打开 Kflash_gui 选择需要烧录的文件，选择版型(默认选择`自动选择`， 如果烧录失败则选择 `MaixDuino`)，选择串口号(CH522 有两个串口，失败则尝试另外一个)，配置波特率(默认选择 `150000`, 如果烧录失败则适当减低波特率,如 `115200`) ![image 20200806103433410](./../../maix/assets/kflash_gui/image 20200806103433410.png) ![image 20200806105056527](./../../maix/assets/kflash_gui/image 20200806105056527.png) ## 怎么获取 Key(机器码) 在使用过程中,如果模块的模型丢失或需要更换,需要发送 `Key` 到 <Support@sipeed.com> 推荐发送邮件格式如下: 首先下载 [key_gen.bin](https://fdvad021asfd8q.oss cn hangzhou.aliyuncs.com/Sipeed_M1/firmware/key_gen_v1.2.bin) 使用 `kflash_gui` 将固件 `key_gen.bin` 烧录到模块中之后,打开串口,波特率为`115200,8,N,1` > **[kflash_gui](https://github.com/Sipeed/kflash_gui/releases)** 为 K210 固件烧录工具, 源码: [**Sipeed/kflash_gui**](https://github.com/Sipeed/kflash_gui) 建议使用 [`XCOM`](tools/XCOM_V2.6.exe) 来看串口信息 轻点 `DTR` ,再松开,即可使模块复位,看到启动信息 <center class \"half\"> <img src \"../../../zh/maix/assets/other/how_to_get_key.png\" height 50% width 80% /> </center> ## MF 固件横竖版说明 由于采用的摄像头成像方向不同，相差 90度，摄像头寄存器无法配置旋转（软件旋转降低效率），故有横竖版两种固件； 如何确认摄像头对应的固件：（通过摄像头丝印区分） 横板 竖版 ![](./../assets/mf_module/mf1/mf_dual_camera_1.jpg) ![](./../assets/mf_module/mf1/mf_dual_camera_2.png) "},"/hardware/zh/maixface/mf_ml_module/mf0_ml_module.html":{"title":"MF0 机器学习核心模组","content":"# MF0 机器学习核心模组 ## 软硬件概述 MF0 人脸识别模块外观一览 <table border \"3\"> <tr> <th colspan 3>MF0</th> </tr> <tr> <td width \"100\">描述</td> <td>正面视图</td> <td>背面视图</td> </tr> <tr> <td width \"100\">MF0</td> <td> <img src \"./../assets/mf_module/mf0_mf0dock/mf0_pin_map.png\" width \"600\" alt \"MF0 正面\"> Pin Map</br> </td> <td> <img src \"./../assets/mf_module/mf0_mf0dock/mf0_buttom.png\" width \"600\" alt \"MF0 背面视图\"> </td> </tr> <tr> <td>MF0 Dock</td> <td> <! <img src \"../assets/mf_module/mf1_bottom_v2(nand).png\" width \"600\" alt \"MF1(NAND Flash) 背面视图\"> > </td> <td> </td> </tr> </table> ### 模块特性： CPU ：RISC V 64bit 双核处理器, 400Mhz 标准频率（可超频） 图像识别：QVGA@60FPS/VGA@30FPS 深度学习框架：TensorFlow/Keras/Darknet 外设：FPIOA、UART、GPIO、SPI、I²C、I²S、WDT、TIMER、etc 2.54mm 间距 DIP/SMT 焊盘 能连接到面包板 板载摄像头连接器 ROM：4MByte RAM：6MByte （通用） + 2MByte （ KPU 专用） ### 硬件 pin No. 描述 24 用户 IO24 25 用户 IO25 26 用户 IO26，MF0_Dock(LCD_RST) 27 用户 IO27，MF0_Dock(LCD_CLK) 28 用户 IO28，MF0_Dock(LCD_DC) 29 用户 IO29，MF0_Dock(LCD_SDA) BOOT 上电 boot 模式选择（用户 IO16，不建议用户使用） IO5 用户 IO5（ISP_TX） IO4 用户 IO4（ISP_RX） EN MF0 电源使能引脚, 默认高电平使能 RST K210 复位引脚 VIN 外部供电电源 3.4 5.9V（推荐 5.0V） GND 外部供电电源地 3V3 模块电源 3.3V 输出 ## 协议 串口协议： MFO 默认烧录 HEX 协议固件 MF0 有两种协议固件，方便用户根据具体需求使用 HEX 格式串口协议固件 JSON 格式串口协议固件 HEX 例程 ### 串口协议助手 ## 更新 MF0 固件 MF0 硬件连接： No. USB 转串口模块 MF0 IO 备注 1 5V VIN 2 GND GND 3 TX IO4 4 RX IO5 5 DTR BOOT 6 RTS RST ![](./../assets/mf_module/mf0_mf0dock/mf0_flash.png) MF0 Dock 硬件连接： 根据下表连接之后，使用 kflash_gui 下载时，需要按下 boot 和 rst 按键，并先松开 rst 再松开 boot 按键，确保 K210 进入下载模式（ISP 模式） No. USB 转串口模块 MF0 Dock IO 备注 1 5V VIN 2 GND GND 3 TX IO4 4 RX IO5 ![](./../zh/maixface/assets/mf_module/mf0_mf0dock/mf0_dock_flash.png) 然后使用 kflash_gui 下载 MF0 固件 ![](./../zh/maixface/assets/mf_module/mf0_mf0dock/mf0_upgrade_firmwave.png)"},"/hardware/zh/maixface/mf_ml_module/mf_precautions.html":{"title":"MF PCB 设计注意事项","content":"# MF PCB 设计注意事项 ## 补光灯： 1、850nm 红外补光灯可以考虑选用 1W 或者 3W 功率的灯珠，因为更大功率的灯珠可以延长使用寿命、减少故障率和提高识别效果 2、红外灯珠和白光灯珠的驱动电路和元件参数，一定要根据实际灯珠选型和数量决定。因为不同的电路成本不一样，亮度感觉不一样，不同客户的需求不一样，因此客户需要根据实际情况选择和调整参数。强烈建议使用光度计去控制整个设计调试和批量生产的红外灯珠亮度的一致性 3、850nm 光线具有一定的穿透性。 目前已证实红外补光灯的 850nm 光线会从摄像头模组的四周和后背穿透进去，影响成像，进而影响屏幕画面或者影响识别效果。 因此必须在摄像头和补光灯之间，用 850nm 无法穿透的材料/喷漆/胶布等阻隔从灯珠散射到摄像头内部的红外光线。 另外，也可以通过拉开红外灯珠与摄像头的距离，距离保持 15mm 以上就能减少 80% 的负面影响，距离保持 20mm 以上，红外线就基本不会透射进摄像头了 4、红外补光灯与外壳前盖板（亚克力/塑料等材质）之间的距离应尽量少，即补光灯与盖板尽量紧贴。如果补光灯与盖板距离较大，会严重影响识别效果 5、在白光补光灯方面，尽量放置多个LED，使用均光板做柔光处理。均光板的面积尽量大。目前市面上的方案有圆圈跑道式的均光板，有小范围片状式的均光板，这个请客户的结构工程师在使用体验和外观设计上对此进行设计。如果不做柔光处理，白光补光灯会刺眼，并且使用户眼睛有十几秒的残影，使用体验不好 6、白光灯珠和红外灯珠的焊盘，需要连接到尽可能大的铜皮，以此提高散热性能 7、白光补光灯对地的电容应该去掉，否则会导致开灯的时候复位 ## 基本信息： 1、M1/M1w 模块底部的散热焊盘，需要连接到尽可能大的铜皮，以此提高散热性能 2、模块的 5V 是输入，外部给模块供电的；模块的 1.8V 和 3.3V 是模块内部 DC DC 生成的，主要是给模块内部核心元件使用的，其次是给模块外部的小电流元件使用（比如作为屏幕和摄像头的 1.8V 参考电压等小电流需求。不建议提供给模块外部的大电流元件使用） 3、如果需要做电容触摸，尽量把触摸芯片放到靠近手指触摸的位置之下。因为触摸芯片到触摸面板之间的走线长度，长度越长越难把握灵敏度、越容易受干扰 4、如果使用 M1w 模块，则需要遵守天线的摆放原则来摆放 IPEX 2.4G 天线，否则信号会有较大程度的损失 5、M1/M1w 模块的 RST、BANK6/7、摄像头 8 位数据和屏幕 8 位数据的工作电压和容忍电压都是 1.8V，BANK0/1/2/3/4/5 的工作电压和容忍电压都是 3.3V 耐压，一定不能超出耐压范围使用。如果要把 RST 引脚引出使用，强烈建议增加保护电路，以下两种电路都可以起到保护/兼容更高电平的作用： ![](./../assets/other/mf_precautions.png) 6、IO16（BOOT）要在底板加 10K 上拉电阻到 3.3V 7、FPIOA 允许用户将 255 个内部功能映射到芯片外围的 48 个自由 IO 上 8、M1 和 M1w 的区别是：M1 没有 WIFI，M1w 有 WIFI，M1w 模块的 IO0 IO3 这 4 个引脚是 K210 与 WIFI(ESP8285) 芯片之间的 SPI 连接，因此不能用作其他用途 9、请一定要在 PCB 上预留 M1/M1w 模块的 K210 和 WIFI 的下载接口，具体可以参考我们提供的标案原理图 ### 认证方面： 1、所有信号都要在靠近源端的地方预留串联磁珠或者RC 低通滤波电路，用来消除过冲和振铃。 RC 参数是 100R+100PF（这是屏幕信号的参数，其他信号必须根据实际测试决定，不能影响正常功能）。 低通 RC 形式是指：信号从源端输出先经过电阻/磁珠后经过电容，RC 元件靠近源端放置。 2、尽量在各路电源VCC预留串联焊盘，可能需要焊接磁珠或者电感，注意磁珠需要选择额定电流大于实际工作电流的 3、尽量在每个可能泄漏的位置、使用到的IO和电源线路等地方加上 ESD 二极管。ESD 二极管放置的位置根据ESD设计原则摆放 4、为了提高ESD防护性能，应该在屏幕到主板之间预留足够的位置放置导电泡棉。主板在该位置阻焊开窗。该位置应尽量接近供电电源的GND 5、PCB四周尽量打过孔，让过孔包围着PCB，元件需要远离可能的静电泄露点"},"/hardware/zh/maixface/mf_ml_module/mf5_product.html":{"title":"MF5","content":"# MF5 ## MF5 外观一览 ## MF5 板载接口 <table border \"2\"> <tr> <th colspan 6>MaixFace 5 引脚信息</th> </tr> <tr> <td colspan 3><img src \"./../assets/mf_module/mf5/mf5_if_1.png\" height 400></td> <td colspan 3><img src \"./../assets/mf_module/mf5/mf5_if_2.png\" height 400></td> </tr> <tr> <td>Maix Face Slik</td> <td>K210 IO</td> <td>ESP8285 IO</td> <td>Function</td> <td>Remark</td> <td>IO Voltage</td> </tr> <tr> <td>VIN</td> <td> </td> <td> </td> <td>电源输入正极</td> <td>12V</td> <td rowspan 22>3.3V</td> </tr> <tr> <td>GND</td> <td> </td> <td> </td> <td>电源输入负极</td> <td>电源GND</td> </tr> <tr> <td>NC</td> <td> </td> <td> </td> <td>继电器常闭触点</td> <td rowspan 3>继电器</td> </tr> <tr> <td>COM</td> <td> </td> <td> </td> <td>继电器公共触点</td> </tr> <tr> <td>NO</td> <td> </td> <td> </td> <td>继电器常开触点</td> </tr> <tr> <td>GND</td> <td> </td> <td> </td> <td>韦根接口RETURN</td> <td rowspan 3>韦根接口</td> </tr> <tr> <td>WGD0</td> <td>IO14</td> <td> </td> <td>韦根接口 D0</td> </tr> <tr> <td>WGD1</td> <td>IO15</td> <td> </td> <td>韦根接口 D1</td> </tr> <tr> <td>GND</td> <td> </td> <td> </td> <td>开门信号地</td> <td rowspan 2>开门信号 低电平: Open</td> </tr> <tr> <td>OPEN</td> <td>IO16</td> <td> </td> <td>开门信号输入</td> </tr> <tr> <td>3V3</td> <td> </td> <td> </td> <td>3.3V</td> <td rowspan 6>以太网/刷卡接口</td> </tr> <tr> <td>CS</td> <td>IO24</td> <td> </td> <td>SPI CS</td> </tr> <tr> <td>MISO</td> <td>IO2</td> <td> </td> <td>SPI MISO</td> </tr> <tr> <td>SCLK</td> <td>IO1</td> <td> </td> <td>SPI SCLK</td> </tr> <tr> <td>MOSI</td> <td>IO3</td> <td> </td> <td>SPI MOSI</td> </tr> <tr> <td>GND</td> <td> </td> <td> </td> <td>GND</td> </tr> <tr> <td>5V</td> <td> </td> <td> </td> <td>5V</td> <td rowspan 6>串口/K210下载</td> </tr> <tr> <td>RST</td> <td>IO54</td> <td> </td> <td>K210复位</td> </tr> <tr> <td>BOOT</td> <td>IO16</td> <td> </td> <td>K210进入ISP模式</td> </tr> <tr> <td>ISPTX</td> <td>IO5</td> <td> </td> <td>ISPTX</td> </tr> <tr> <td>ISPRX</td> <td>IO4</td> <td> </td> <td>ISPRX</td> </tr> <tr> <td>GND</td> <td> </td> <td> </td> <td>GND</td> </tr> </table> ## MF5 固件说明 MF5 为人脸识别门禁成品，默认烧录的固件不支持串口协议； 在烧录串口协议固件之后，协议串口为 WGD0 IO14(RX)，WGD1 1O15(TX)。"},"/hardware/zh/maixface/mfst40/mfst40.html":{"title":"MF-ST40 人脸识别模块","content":" title: MF ST40 人脸识别模块 keywords: M1s DOCK ,BL808, M1s update: date: 2022 11 07 version: v0.1 author: wonder content: 初次编写 > 本产品不对个人技术支持，个人需求请购买 [M1s 模组](./../../maix/m1s/m1s_module.html) ## 产品概述 MF ST40 人脸识别模组基于博流 BL808 芯片设计，模组内部预留了 WIFI 功能、 SPI 屏幕接口、多路 UART 接口和 RTC 电路，较大地提高了用户整机产品的集成度。 购买链接：[淘宝](https://item.taobao.com/item.htm?id 690754113762) 产品图片： <table> <tr> <th align \"center\">模组图片</th> <th align \"center\">演示机图片</th> </tr> <tr> <td> <table> <tr> <td align \"center\">正面图</td> <td align \"center\">背部图</td> </tr> <tr> <td><img alt \"product_top\" src \"./assets/product_top.jpg\"></td> <td><img alt \"product_bottom\" src \"./assets/product_bottom.jpg\"></td> </tr> </table> </td> <td> <table> <tr> <td align \"center\">正面图</td> <td align \"center\">背部图</td> </tr> <tr> <td><img alt \"product_top_screen\" src \"./assets/product_top_screen.jpg\"></td> <td><img alt \"product_bottom_screen\" src \"./assets/product_bottom_screen.jpg\"></td> </tr> </table> </td> </tr> <table> ## 关键特性 主处理器：博流 808 双核 AI 芯片 核心算法：活体人脸识别 识别距离：0.35 0.9m 识别速度：上电到解锁 1.0 秒内 识别角度：H50° V70° 识别环境：无环境光也可以识别 功耗：单次解锁 0.36mWh 兼容主流锁孔、可选电子猫眼、可选音视频对讲 应用：门锁、考勤机、其他人脸识别终端产品 ## 相关资料 详细说明请查阅下方的 [规格书](https://dl.sipeed.com/shareURL/MaixFace/MF SF40/1_Specification) [规格书](https://dl.sipeed.com/shareURL/MaixFace/MF SF40/1_Specification) [原理图](https://dl.sipeed.com/shareURL/MaixFace/MF SF40/2_Schematic) [点位图](https://dl.sipeed.com/shareURL/MaixFace/MF SF40/3_Bit_number_map) [尺寸图](https://dl.sipeed.com/shareURL/MaixFace/MF SF40/4_Dimensional_drawing) [3D 模型文件](https://dl.sipeed.com/shareURL/MaixFace/MF SF40/5_3D_file) [芯片手册](https://dl.sipeed.com/shareURL/MaixFace/MF SF40/6_Chip_Manual) ## 注意事项 <table> <tr> <th>项目</th> <th>注意事项</th> </tr> <tr> <td>静电防护</td> <td>请避免静电打到 PCBA 上；接触 PCBA 之前请把手的静电释放掉</td> </tr> <tr> <td>容忍电压</td> <td> 每个 GPIO 的工作电压已经在原理图中标注出来，请不要让 GPIO 的实际工作的电压超过额定值，否则会引起 PCBA 的永久性损坏 </td> </tr> <tr> <td>FPC 座子</td> <td>在连接 FPC 软排线的时候，谲确保排线无偏侈地完整地插入到排线中</td> </tr> <tr> <td>插拔</td> <td>请完全断电后才进行插拔操作</td> </tr> <tr> <td>避免短路</td> <td>请在上电过程中，避免任何液体和金属触碰到 PCBA 上的元件的焊盘，否则会导致路，烧毁 PCBA</td> </tr> </table> ## 技术支持 MF ST40 为商业合作产品，不对个人用户进行技术支持，个人用户建议使用 [M1s 模组](./../../maix/m1s/m1s_module.html)。 联系邮箱: `support@sipeed.com`"},"/hardware/zh/maixface/core_modules/k210_core_modules.html":{"title":"K210 核心模块","content":"# K210 核心模块 现有四款基于 K210 开发的 AIOT 模块：M1, M1w, M1n, MF0 特性说明： 这四款模块都是基于嘉楠堪智科技的边缘智能计算芯片K210（RISC V架构）设计的。主控芯片内置64位双核高性能低功耗处理器，每个核都有浮点运算单元（FPU），具备卷积人工神经网络智能硬件加速器（KPU）和快速傅里叶变换加速器（FFT）、搭载现场可编程IO阵列（FPIOA），支持多种主流AI编程框架。 ### Maix AIOT 模块差异对比 M1 M1w M1n MF0 外观 ![M1 模组](./../assets/mf_module/m1_m1w/sipeed_m1_module.png) ![M1W 模组](./../assets/mf_module/m1_m1w/sipeed_m1w_module.png) ![M1n 模组](./../assets/mf_module/m1n/sipeed_m1n_module.png) ![MF0 模组](./../assets/mf_module/mf0_mf0dock/sipeed_mf0_module.png) 尺寸 25.4x25.4x3.3（mm） 25.4x25.4x3.3（mm） 25.0x22.0x2.7（mm） 20.0x20.0x4.5（mm） 电压输出（提供给底板使用） 1.8V和3.3V 1.8V和3.3V 1.8V和3.3V 3.3V 最大功耗（非瞬态） 1.5W 3W 1.5W 1.5W WIFI功能 无 有（K210与ESP8285通过SPI接口和串口连接） 无 无 板载摄像头连接器 无 无 有（仅兼容单摄像头） 有（仅兼容单摄像头） 引脚形式 邮票孔 邮票孔 NGFF金手指 B KEY 2.54mm间距直插焊盘+SMD焊盘 是否引出摄像头信号 全引出 全引出 全引出 无 是否引出屏幕信号 全引出 全引出 全引出 无 引出普通IO口数量 48个（全引出） 48个（全引出） 44个（IO0 3没引出） 9个 ## 模块引脚定义 具体可下载规格书 M1/M1w: https://dl.sipeed.com/MAIX/HDK/Sipeed M1&M1W/Specifications M1n: https://dl.sipeed.com/MAIX/HDK/Sipeed M1n MF0: https://dl.sipeed.com/MAIX/HDK/Sipeed MF0/MF0 2802 ## M1/M1W(k210) ISP 模式(烧录模式) 更新 K210 时，需要让 K210 进入 ISP 模式，相关信息如下： ISP 引脚 ISP 引脚 描述 备注 BOOT (IO_16) 启动模式选择 低电平进入，ISP 模式 ISP_RX (IO_4) ISP 串口数据接收 ISP_TX (IO_5) ISP 串口数据发送 Boot 选择 **IO_16** 用于 **boot** 模式选择，上电时，拉高进入 **Flash** 启动，拉低进入 **ISP** 模式 Boot 选择引脚 拉高 拉低 IO_16 Flash 启动 ISP 模式 > K210 ISP 模式下，串口波特率建议配置为: 115200，1 停止位，8 数据位，不校验。 参考自动进入下载模式电路： ![](../../assets/mf_module/m1_m1w/K210_boot_reference.png) 参考来源： > 《K210技术规格书 v0.1.5》 > 2.5 特殊引脚: IO_16 用于 boot 模式选择，上电复位时，拉高进入 FLASH 启动，拉低进入 ISP 模式。复位后，IO_0、 IO_1、IO_2、IO_3 为 JTAG 引脚。IO_4、IO_5 为 ISP 引脚。 ## MF PCB 注意事项 使用 K210(M1/M1W) 自行设计人脸识别产品，请参考 [《MF 人脸识别模块 PCB 设计注意事项》](../mf_ml_module/mf_precautions.html)"},"/hardware/zh/maixIII/index.html":{"title":"","content":" "},"/hardware/zh/maixIII/ax-pi/faq_axpi.html":{"title":"Maix-III 系列 AXera-Pi 常见问题（FAQ）","content":" title: Maix III 系列 AXera Pi 常见问题（FAQ） ## Q：供电不足怎么办？ A：可以把两根 usb 口接上来供电，板子至少要 USB3.0 1A 的电流才能启动喔！（拉黑 USB2.0 500ma） ## Q：被产品电了怎么办？ A：最近冬天静电来了，产品要注意接地喔。 ## Q：如何更换 os04a10 摄像头？ A：**一改参数，二改代码，以下述改动为例**： 类似 sample_vin_vo 这类命令改 ` c 0` 就可以启用 os04a10 摄像头，对应 ` c 2` 就是默认提供的 gc4653 摄像头。 如果是类似 [IPCDemo](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#IPCDemo) 的话更改相对应后缀 gc4653 为 `gc4653_config.json`、os04a10 为 `os04a10_config.json`。 ![ipc_demo_json](./../../../en/maixIII/ax pi/assets/flash_system/ipc_demo_json.jpg) 像[RSTP](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#rtsp) 这种脚本运行的示例，可以通过编辑里面的摄像头注释来改变摄像头配置。 ![rtsp_stream_shell](./../../../en/maixIII/ax pi/assets/flash_system/rtsp_stream_shell.jpg) 可以编辑 C 代码里设置默认摄像头的代码 `COMMON_SYS_CASE_E eSysCase SYS_CASE_SINGLE_GC4653;` 来切换摄像头，详细可看[components/libmaix/lib/arch/axpi/libmaix_cam/libmaix_cam.cpp#L93](https://github.com/sipeed/libmaix/blob/release/components/libmaix/lib/arch/axpi/libmaix_cam/libmaix_cam.cpp#L93) <div> <img src \"./../../../en/maixIII/ax pi/assets/qa/qa_switcg_os04a10_1.jpg\" alt \"qa_switcg_os04a10_1\" width \"45%\"> <img src \"./../../../en/maixIII/ax pi/assets/qa/qa_switcg_os04a10_2.jpg\" alt \"qa_switcg_os04a10_2\" width \"45%\"> </div> ## Q：运行摄像头有关程序时报错 i2c_read: Failed to read reg: Remote I/O error.!？ A：摄像头接线是否正确、检查摄像头配置是否与型号相匹配、参数是否修改、启动命令行输入是否出错、以及摄像头是否启动；如果以上都是正确的话，摄像头依旧报错就是硬件问题了。 ## Q：如何更换其他屏幕？ A：目前默认只提供 5 寸屏幕，支持其他屏幕需要自行修改驱动代码和设备树，以及对应的应用层显示代码。 ## Q：运行 xxxx menuconfig 时遇到报错 locale.Error: unsupported locale setting !? A：可以使用 `sudo localedef i en_US f UTF 8 en_US.UTF 8` 恢复一下配置即可。 ## Q：运行 IPC ODM 命令时报错 VCEncInit:ERROR codecFormat NOT support by HW !? A：试着按复位键或者是插拔重启设备即可。 ## Q：运行程序后屏幕显示花屏？ ![faq_display](./../assets/faq_display.jpg) A：查看摄像头型号参数是否配置正确。 ## Q：运行命令后报错：Bus Error！？ ![faq_bus](./../assets/faq_bus.jpg) A：这种情况是 SD 卡质量问题导致掉卡，也就是镜像卡里面的程序崩掉了无法读取到。 更换质量好一点的 SD 卡或官方购买镜像卡，可参照 `SD` 卡测试选购合适的卡[点击前往查看](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/flash_system.html#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9 SD %E5%8D%A1%EF%BC%9F)。 ## Q：使用 `ifconfig a` 查看后没有 eth0 ip 地址？ A：没有联网的话会直接看不到 ip 地址，查看下网线是否有接入、是否接稳了。 或使用 `dhclient eth0` 手动启动或参考文档[传送门](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E6%9C%89%E7%BA%BF%E4%BB%A5%E5%A4%AA%E7%BD%91%EF%BC%88eth0%EF%BC%89%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95)重新配置 ip 获取地址。 ## Q：运行 uvc 命令后一直报错读取不到设备？ A：这种情况一般会少数出现在 Windows 环境上，查看设备管理器是不是有什么显示异常驱动，卸载后即可使用。 ## Q：运行 uvc 命令后出现卡住现象？ A：重启即可 ## Q：使用 ssh 登陆后断开报错：packet_write_wait: Connection to 10.xxx.xxx.xxx port 22: Broken pipe！ A: 运行一下`python3 c \"import os, binascii; os.system('sed i \\'/iface eth0 inet dhcp/ahwaddress ether {}\\' /etc/network/interfaces'.format(binascii.hexlify(bytes.fromhex(open('/proc/ax_proc/uid').read().split('0x')[1][: 5]),':').decode('iso8859 1'))) if os.system('grep \\'hwaddress ether\\' /etc/network/interfaces q') ! 0 else exit();\"` 后重启即可。 ## Q：硬件物料更改说明、没有 wlan0 、屏幕烧屏、摄像头倒过来怎么解决？ > **新旧版底板区别** > 1. 在新底板上我们标注了设备号：`v3768`，用户也可以根据版本号来确认版本的不同。 2. 底板摄像头 FPC 连接座更换，主要就是固定方向改变，但是接线方向未变。 3. WiFi 模块更换：`旧 RTL8723BS` > `新 RTL8189FTV`。 **如果遇到 wlan0 不显示的话请参考以下解决方法：** 1. 根据下图确定 WiFi 模块的版本来替换 `/boot` 目录下的相对应的驱动，更新内核驱动可以用 `cp /boot/kernel.img.rtl8723bs /boot/kernel.img` 更新后请重启板卡。 2. 可能是运输导致核心板与底板衔接松了，重新插拔装紧核心板即可。 3. 尝试以上方法后仍不显示 wlan0 的话，重新烧录镜像（未知系统问题、极少见）。 ![faq_borad](./../assets/faq_board.jpg) > **新旧版摄像头区别** 新版摄像头线序方向发生了变化，可点击[接线示例](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/flash_system.html#%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E5%A4%96%E8%AE%BE%E5%92%8C%E9%85%8D%E4%BB%B6%EF%BC%9F)参考并进行接线防止接反导致烧坏排线或板卡。 ![faq_sensor](./../assets/faq_sensor.jpg) **如出现摄像头、屏幕画面反了倒过来了可参考以下解决方法：** `V3751` 版本的摄像头批次导致的问题，物理旋转即可解决。 ![faq_video_a](./../assets/faq_video_a.jpg) 有装配亚克力外壳的 AXera Pi 可参考以下图例旋转安装： <html> <img src \"./../assets/faq_video_b.jpg\" width 48%> <img src \"./../assets/faq_video_c.jpg\" width 48%> </html> > **新旧版屏幕区别** 新旧板的屏幕所使用的设备树（驱动）不同。 ![faq_newdisplay](./../assets/fqa_newdisplay.jpg) **屏幕上电后出现残影、锯齿、烧屏或下图画面请参考以下解决方法：** <html> <img src \"./../assets/faq_sawtooth.jpg\" width 48%> <img src \"./../assets/faq_dth.jpg\" width 48%> </html> 新旧版的屏幕设备树不同，根据上图日期区分并替换 `/boot` 目录下对应的 `dtb` 设备树驱动即可，请及时更换否则会导致烧屏，使用 `cp /boot/dtb.img.lcd20220830 /boot/dtb.img` 进行设备树替换后重启。 ## Q：运行 opencv 相关后报错：can't open camera by index. A：查询一下摄像头设备号是否与代码内调用设备号的一致。 ## Q：烧录后启动失败显示 XERA UBOOT > A：进入 uboot 模式了输入 boot 后即可启动。 ![faq_boot](./../assets/faq_boot.jpg) ## Q：芯片为什么显示 1G 内存以及用户为什么只能用 1.3g 内存 ![faq_mem](./../assets/faq_mem.png) 第一个是 uboot 显示 bug 我们贴的都是 2GB 内存. 第二个是 系统上显示的内存为什么不是刚好 2GB，这里根据原厂芯片方案可知官方设计的 1G 内存分配方案为 256M + 768M CMM. ![faq_ddr](./../assets/faq_ddr.png) ![faq_uboot](./../assets/faq_dram.png) 而我们贴的是 2GB 内存采用的是 512M CMM 的内存方案，其余的内存 2048M 512M 1536M 为用户空间内存，再除去 256M kernel 内存后剩下 1536M 256M 约等于 1.3G 供用户使用 什么是 CMM 内存，简单理解就是一段独立于 linux 系统之外的大段线性物理内存，一般是分给 NPU ISP GPU 用的线性物理空间，这意味着加载模型不需要消耗 1.22G 用户空间内存，消耗的是 CMM 内存，如推理、编码、ISP处理都不会吃用户空间内存。 现在带 NPU ISP GPU 的芯片都会有类似的设计或概念，可以从芯片手册或驱动代码中得知。 如爱芯的 `/soc/scripts/auto_load_all_drv.sh` 存放有 `insmod /soc/ko/ax_cmm.ko cmmpool anonymous,0,0x60000000,512M` 这个字段。 ![cmm_memory_size_script](./../../../en/maixIII/ax pi/assets/qa/cmm_memory_size_script.png) 以及系统启动配置： `/* bootargs for SD */#define BOOTAGRS_SD \"mem 1536M initcall_debug 0 loglevel 0 ax_boot_delay 0 vmalloc 768M console ttyS0,115200n8 earlyprintk dw_uart, init /sbin/init noinitrd root /dev/mmcblk2p2 rw rootdelay 3 rootfstype ext4\"` ![bootargs_command](./../../../en/maixIII/ax pi/assets/qa/bootargs_command.png)"},"/hardware/zh/maixIII/ax-pi/basic_usage.html":{"title":"Maix-III AXera-Pi 系统基础使用","content":" title: Maix III AXera Pi 系统基础使用 基于上文的上手指引后，本文介绍使用 Maix III AXera Pi 开发板的 Linux debian11 系统基础使用方法。 ## 系统登录 ### 登录工具 这里介绍相关使用的终端登录工具，分别是：`MobaXterm`、`electerm`、`vscode remote`。 **MobaXterm 介绍** MobaXterm 是在 Windows 下使用的全能终端管理软件，而 Linux 系统可以使用 ssh 远程被操作，使用 MobaXterm 进行 ssh 登陆板子直接编辑板内的代码或执行命令，也能方便的拖拽文件上传或下载到电脑里，类似的工具还有 vscode remote 远程登录 linux 服务器。 ![mobaxterm_ssh](./../assets/ssh.jpg) 下载链接：[点击跳转](https://mobaxterm.mobatek.net/download.html) 分别付费与免费双版本，下载免费版本即可。 使用教程：[如何使用 MobaXterm](https://wiki.sipeed.com/hardware/zh/maixII/M2/tools/mobaxterm.html?highlight ssh) **electerm 介绍** electerm 是一个基于 `electron/ssh2/node pty/xterm/antd/useProxy` 等开源组件开发，支持跨平台的 `Terminal/SSH/SFTP` 客户端工具，同时支持 `Linux、MacOS、Windows` 等多种操作系统，它既可以作为终端工具来使用，还能传输文件并自带中文界面，更加满足用户日常对终端的需求。 ![electerm](./../assets/electerm.jpg) 下载链接：[点击跳转](https://electerm.html5beta.com/) 根据操作系统来下载相对应的版本即可。 **vscode remote 介绍** vscode remote 是 vscode 的一个插件，可以直接连接到远程的 linux 服务器，然后在本地编辑代码，同步到远程服务器上编译运行，这里以一台 Windows 10 的桌面计算机系统为例，只要能安装 vscode 编辑器软件计算机都行。 ![vscode](./../assets/vscode.jpg) 下载连接：[点击跳转](https://code.visualstudio.com/) 连接教程：[如何使用 vscode remote 连接板子](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/dev_prepare.html?highlight ssh#vscode remote) ### 登录方式 Maix III AXera Pi 开发板的 Linux debian11 系统默认使用 root 用户登录。 用户名为 `root`，密码为 `root`，目前板子接入电脑端上电启动后支持以下登录 Linux 系统方式。 #### 有线 串口 serial 登陆 > 使用串口 serial 登陆前需安装 tty 转 USB 串口驱动 **Linux**：系统本身自带无需再装驱动，使用 `ls /dev/ttyUSB*` 即可看到设备号。 **Windows**：直接[点击下载 CH340 驱动](https://api.dl.sipeed.com/fileList/MAIX/tools/ch340_ch341_driver/CH341SER.EXE)安装，安装后可在`设备管理器`查看串口设备。 .. details::点此展开查看 CH340 驱动安装 先打开设备管理器查看是否有 **CH340** 驱动，如无驱动的话请点击上方链接进行下载。 ![usb serial](./../assets/usb serial.jpg) 下载完成后，右键点击文件，选择**以管理员身份运行(A)**即会自动安装。 ![install serial](../assets/install serial.jpg) 安装完成，可在设备管理器端口处查看设备。 >[有些同学会遇到 Ubuntu22.04 CH340系列串口驱动（没有ttyUSB）问题，点此查看解决方案。](https://blog.csdn.net/qq_27865227/article/details/125538516) .. details::点此展开查看 USB UART 接口示意图 ![uart](./../assets/uart.jpg) 使用 usb 3.0 线连接板子上的 USB UART 接入电脑端，使用前请安装上文的驱动，再使用 MobaXterm 即可连接，默认串口配置为 115200、8N1（波特率115200，8位数据，无奇偶校验，1位停止位）。 **serial 登陆教程**：[点击查看](https://wiki.sipeed.com/hardware/zh/maixII/M2/tools/mobaxterm.html?highlight ssh#%E8%BF%9E%E6%8E%A5 %E4%B8%B2%E5%8F%A3%28Serial%29) 成功连接后会打印大量调试信息，会弹出登陆账号信息，输入用户名及密码即可登陆。 ![serial](./../assets/serial.jpg) > 串口通常只提供给专业的驱动开发工程师调试用，会打印大量的调试信息，如感到不适请使用 **ssh** 登陆。 #### 基于 ip + ssh 登录 > 登录前需安装 **rndis usb** 网卡驱动 一般情况下 rndis usb 网卡驱动在 Linux 下可不用安装，在 Windows 下需要按下图手动安装系统自带驱动，而 macos 需要编译安装驱动（horndis），Windows 还需要配置一下网络优先级，勾选微软 rndis 驱动后设置网络跃点数调整优先级。 **Windows 配置网络优先级**：[设置网络跃点数调整优先级](https://jingyan.baidu.com/article/358570f6bc5cfdce4724fca2.html) 这里举例如何在 Win10 安装系统自带的 rndis 驱动，在 Linux 上免驱动自动识别 rndis 驱动，MacOS 安装可以参考这篇 [【AXPI】如何在 M1/M2 Mac上使用 Rndis](https://zhuanlan.zhihu.com/p/593627641) 。 .. details::点此展开查看 Win10 驱动安装过程 打开设备管理器找到其他设备，选中 rndis 选择更新驱动程序，在如何搜索设备软件窗口中，选择**浏览计算机查找驱动程序软件（R）**。 ![rndis_1](./../assets/rndis_1.jpg) 再选择**从计算机的设备驱动程序列表中选择（L）**在硬件设备列表中往下拉，找到**网络适配器**，选中**下一步**。 ![rndis_2](./../assets/rndis_2.jpg) 在厂商列表中选择 **Microsoft**，右侧列表中选择 **USB RNDIS Adapter**。 ![rndis_3](./../assets/rndis_3.jpg) 点击下一步等待安装即可。 .. details::点此展开查看 USB OTG 接口示意图 ![otg](./../assets/otg.jpg) 系统默认开启了 usb rndis 虚拟以太网，用户可通过板载 USB OTG 口连接 usb0 网卡的 IP `192.168.233.1` 进行 ssh 登录操作。使用 ssh 登录前需要先登陆板子通过 `ifconfig a` 命令得到板子 IP 后再使用 IP 进行 ssh 登录上 Linux 系统，下图的 IP 地址（除 `127.0.0.1` 外）都能登陆板子。 ![ifconfig](./../assets/ifconfig.jpg) **ssh 连接教程**：[点击跳转](https://wiki.sipeed.com/hardware/zh/maixII/M2/tools/mobaxterm.html?highlight ssh#%E8%BF%9E%E6%8E%A5 SSH) 按教程示例新建 ssh 会话，双击会话后会有提醒输入账号及密码，输入后按回车即可连接。 ![ssh](./../assets/ssh.jpg) ### 登录后 登录后，可以使用 `ls` 命令查看当前目录下的文件，使用 `cd` 命令切换目录，使用 `pwd` 命令查看当前目录。 ## 网络配置 ### 网络操作基础 **使用 ping baidu.com 测试网络** ![baidu](./../assets/baidu.jpg) **使用 ifconfig a 查看所有网卡情况** Maix III AXera Pi 开发板的 Linux 系统默认使用 DHCP 协议获取 IP 地址，可以使用命令行 `ifconfig a` 查看当前网络配置，板子根据下述会配置四种网卡类型。 ```bash root@AXERA:~# cat /etc/network/interfaces # interfaces(5) file used by ifup(8) and ifdown(8) # Include files from /etc/network/interfaces.d: source /etc/network/interfaces.d/* auto lo iface lo inet loopback # auto eth0 allow hotplug eth0 iface eth0 inet dhcp # auto usb0 allow hotplug usb0 iface usb0 inet static address 192.168.233.1 netmask 255.255.255.0 # allow hotplug wlan0 # wpa ssid \"dalaoshu\" # wpa psk \"junhuanchen\" auto wlan0 iface wlan0 inet manual wpa conf /boot/wpa_supplicant.conf iface wlan0 inet dhcp ``` 可以使用命令行 `ifconfig a` 查看所有网卡信息。 ```bash root@AXERA:~# ifconfig a eth0: flags 4163<UP,BROADCAST,RUNNING,MULTICAST> mtu 1500 inet 192.168.0.77 netmask 255.255.255.0 broadcast 192.168.0.255 ether 1e:09:dc:e9:1c:29 txqueuelen 1000 (Ethernet) RX packets 301 bytes 41433 (40.4 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 31 bytes 2970 (2.9 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 device interrupt 56 lo: flags 73<UP,LOOPBACK,RUNNING> mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 loop txqueuelen 1000 (Local Loopback) RX packets 16 bytes 1064 (1.0 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 16 bytes 1064 (1.0 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 usb0: flags 4163<UP,BROADCAST,RUNNING,MULTICAST> mtu 1500 inet 192.168.233.1 netmask 255.255.255.0 broadcast 192.168.233.255 ether 02:da:9b:e4:a8:7f txqueuelen 1000 (Ethernet) RX packets 121 bytes 15220 (14.8 KiB) RX errors 0 dropped 15 overruns 0 frame 0 TX packets 35 bytes 7258 (7.0 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 wlan0: flags 4163<UP,BROADCAST,RUNNING,MULTICAST> mtu 1500 inet 192.168.0.112 netmask 255.255.255.0 broadcast 192.168.0.255 ether 0c:cf:89:32:c5:c0 txqueuelen 1000 (Ethernet) RX packets 950 bytes 154305 (150.6 KiB) RX errors 0 dropped 950 overruns 0 frame 0 TX packets 5 bytes 1398 (1.3 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ``` **使用 dhclient 触发 DHCP 获取 ip** >这里以有线网卡（eth0）为例，decliient 还支持无线 WIFI（wlan0）. 使用上方 `ifconfig a` 命令后，如果 eth0 的地址获取失败可使用 `dhclient eth0` 触发 DHCP 获取 IP。 ```bash root@AXERA:~# dhclient eth0 & [1]+ Done dhclient eth0 root@AXERA:~# ifconfig eth0 wlan0: flags 4163<UP,BROADCAST,RUNNING,MULTICAST> mtu 1500 inet 192.168.0.136 netmask 255.255.255.0 broadcast 192.168.0.255 ether 0c:cf:89:32:c5:dc txqueuelen 1000 (Ethernet) RX packets 1284 bytes 157505 (153.8 KiB) RX errors 0 dropped 1274 overruns 0 frame 0 TX packets 205 bytes 20798 (20.3 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ``` ### USB RNDIS（usb0）配置方法 可使用静态 IP 地址 `192.168.233.1` 这里已配置好 dhcp 服务了，从而避免用户需手动设置 IP 地址的操作。 > 使用 usb0 前需要安装 rndis 驱动，可点击[驱动安装过程](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E5%9F%BA%E4%BA%8E ip %2B ssh %E7%99%BB%E5%BD%95)前往安装。 在 Windows 系统下如果遇到多个网卡时，发现 USB 网卡优于局域网导致内网网站访问很慢甚至失败，此时就需要通过 Win10 设置跃点数来调整网络优先级的连接顺序，去修改优先级改善访问慢的状态，数值越大优先级越低（比如设置 1000），从而把 USB 网卡优先级调至最低，可点击前往[配置网络优先级](https://jingyan.baidu.com/article/358570f6bc5cfdce4724fca2.html). **查看 usb0 网卡是否存在** 可通过 `ifconfig usb0` 命令查看 usb0 网卡或尝试 `ping 192.168.233.1` 是否能通。 ```bash root@AXERA:~# ifconfig usb0 usb0: flags 4099<UP,BROADCAST,MULTICAST> mtu 1500 inet 192.168.233.1 netmask 255.255.255.0 broadcast 192.168.233.255 ether 16:37:cd:c6:f2:ae txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ``` **在 ping 通后 192.168.233.1 即可通过 usb 线登陆到板子** USB 网卡会自动 DHCP 配置，直接连接 192.168.233.1 即可，连接方式可参考示意图。 ![ssh usb](./../assets/ssh usb.jpg) ### 有线以太网（eth0）配置方法 **查看 eth0 网卡是否存在** 可使用 `dhclient eth0 &` 手动启动 DHCP 客户端获取 IP 地址，得到 ip 后使用 `ifconfig eth0` 命令查看当前网络配置。默认支持千兆网络，只需要开机前将网线插上去，在启动过程中就会自动配置并联网，可以通过 `apt update` 测试软件源更新。 ```bash root@AXERA:~# ifconfig eth0: flags 4163<UP,BROADCAST,RUNNING,MULTICAST> mtu 1500 inet 192.168.0.77 netmask 255.255.255.0 broadcast 192.168.0.255 ether 1e:09:dc:e9:1c:29 txqueuelen 1000 (Ethernet) RX packets 301 bytes 41433 (40.4 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 31 bytes 2970 (2.9 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 device interrupt 56 ``` **关于 eth0 地址相同的问题** 执行下述代码就会从 `/proc/ax_proc/uid` 读取 chip_id 写到 `/etc/network/interfaces` 的 eth0 配置里，该命令多次执行不受影响。 ``` python3 c \"import os, binascii; os.system('sed i \\'/iface eth0 inet dhcp/ahwaddress ether {}\\' /etc/network/interfaces'.format(binascii.hexlify(bytes.fromhex(open('/proc/ax_proc/uid').read().split('0x')[1][: 5]),':').decode('iso8859 1'))) if os.system('grep \\'hwaddress ether\\' /etc/network/interfaces q') ! 0 else exit();\" ``` **一些问题排除方法，如没有 ip 如何配置** 登录后无法获取以太网地址的话，可用上文命令启动 DHCP 客户端获取 IP 地址。 或者是使用 `ifdown eth0` 关闭网卡后再使用 `ifup eth0 force` 启动手动配置 IP。 .. details::点此展开查看配置示例 ![eth0 config](./../assets/eth0 config.jpg) ### 无线 WIFI （wlan0）配置方法 >**20230103** 后镜像更新以及不同硬件（rtl8189fs）WiFi 模组，相关的 `WiFi` 配置全部采用 `nmtui` 图形化或命令行进行联网。相关的硬件版本区分或出现 `wlan0` 不显示的情况都请移步[ Maix III 系列 AXera Pi 常见问题（FAQ）](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html)查看。 **查看 WIFI 网卡是否存在** **wlan0**：无线网卡，使用 DHCP 协议获取 IP 地址，可使用命令 `ifconfig wlan0` 查看当前网络配置。 #### 使用命令行联网 >注意：新镜像（**20230103**）已提前配置好 `nmtui connect` 直接可以根据下文进行联网。 >旧镜像使用前需先配置 `nmtui connect` 才可使用，可点击前往[ 启动 nmtui connect 图形化联网 ](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#配置 nmtui connect 使用图形化联网)查看。 以下联网命令行已提前放置在开机脚本 `/boot/rc.local` 里，用户可参考示例修改命令行的 `账户 & 密码` 并在终端运行联网即可，系统会自动保存连接过的 WiFi 账户以及密码。 ```bash nmcli device wifi connect Sipeed_Guest password qwert123 # 示例 nmcli device wifi connect AXera Pi password 11111111 # 改动 WiFi 账户以及 pssword 密码 ``` .. details::点击查看修改示例图 ![nmtui_adb](./../assets/nmtui_adb.png) #### 使用 nmtui connect 图形化联网 终端输入 `nmtui connect` 打开可视化联网页面。页面会显示扫描到的 WiFi 信息，使用键盘的 **上下左右** 键选择要连接的 WiFi 按下 **回车** 键，页面提示输入 WiFi 密码，输完后选择 `OK` 并按 **回车** 键则会弹出页面，选择 `Quit` 按 **回车** 键退出，页面会显示 * 标变动代表联网完成。 <html> <img src \"./../assets/nmtui_one.png\" width 45%> <img src \"./../assets/nmtui_two.png\" width 45%> </html> #### nmtui connect 图形化联网详解 系统已预置 NetworkManager 在 `nano /etc/NetworkManager/NetworkManager.conf` 里的 `managed false` 修改成 `managed true` 和注释掉 `/etc/network/interfaces` 里的有关于 `wlan0` 的配置（可以打开 `allow hotplug wlan0` ）后「拔线断电重启」即可使用 `nmtui connect` 进行联网，但原来的 `wpa_supplicant.conf` 里的配置会失效。 ``` root@AXERA:~# cat /etc/network/interfaces # interfaces(5) file used by ifup(8) and ifdown(8) # Include files from /etc/network/interfaces.d: source /etc/network/interfaces.d/* auto lo iface lo inet loopback # auto eth0 allow hotplug eth0 iface eth0 inet dhcp # auto usb0 allow hotplug usb0 iface usb0 inet static address 192.168.233.1 netmask 255.255.255.0 allow hotplug wlan0 # wpa ssid \"2.4G\" # wpa psk \"1qaz2wsx\" # auto wlan0 # iface wlan0 inet manual # wpa conf /boot/wpa_supplicant.conf # iface wlan0 inet dhcp ``` > [配置 NetworkManager 参考](https://support.huaweicloud.com/bestpractice ims/ims_bp_0026.html#section1) & [linux系统中使用nmtui命令配置网络参数（图形用户界面）](https://www.cnblogs.com/liujiaxin2018/p/13910144.html) 这样你就可以使用 `nmcli pretty device wifi list` 进行 Wi Fi 的扫描了。 ``` root@AXERA:~# nmcli pretty device wifi list Wi Fi scan list (wlan0) IN USE BSSID SSID MODE CHAN RATE SIGNAL> > CC:81:DA:5B:10:98 2.4G Infra 7 270 Mbit/s 92 > 22:59:57:DD:90:63 田震天啊天震田 Infra 1 270 Mbit/s 65 > C4:70:AB:3B:5A:EF 201 Infra 1 130 Mbit/s 65 > 6A:70:AB:3B:5A:EC Infra 1 130 Mbit/s 65 > 48:A0:F8:22:BB:2D ChinaNet KQXN Infra 3 130 Mbit/s 65 > 10:C1:72:2F:AD:FC ChinaNet kWCT Infra 11 130 Mbit/s 64 > B0:DF:C1:76:C5:21 Infra 2 195 Mbit/s 62 > 66:9A:08:0C:57:D4 aWiFi 204 Infra 3 270 Mbit/s 62 > 1C:60:DE:96:19:16 26JK Infra 6 270 Mbit/s 60 > 1C:60:DE:78:D8:D2 EDwinLam. Infra 1 270 Mbit/s 59 > 64:64:4A:28:14:3F Xiaomi_143E Infra 2 130 Mbit/s 59 > 08:40:F3:27:63:70 大王 Infra 5 270 Mbit/s 59 > 14:A3:2F:62:80:F4 HUAWEI 211 Infra 6 270 Mbit/s 59 > E4:0E:EE:DA:96:A4 w168 Infra 6 270 Mbit/s 59 > 66:9A:08:0C:2D:34 aWiFi 305 Infra 6 270 Mbit/s 59 > 00:E0:4C:2B:2F:F3 UU加速盒 2FF2 Infra 11 270 Mbit/s 59 > 74:50:4E:8D:51:69 Infra 5 270 Mbit/s 57 > 76:50:4E:1D:51:69 207 Infra 5 130 Mbit/s 57 > lines 1 23 ``` #### 如何打开 WIFI AP 热点模式（需替换 rtl8189fs wifi 模组） 基于 nmtui 联网成功后改用 nmcli 命令。 `nmcli device wifi hotspot ifname wlan0 con name MyHostspot ssid MyHostspotSSID password 12345678` 即可创建 MyHostspotSSID 的 ap 热点。 ![nmcli_ssid](./../assets/nmcli_ssid.png) > 目前 rtl8723bs WIFI 能打开，但连上会重启板子，网卡驱动问题暂时不修，更换成 rtl8189fs 即可正常使用。 #### 如何修改连接的 WIFI 账号密码（已过时） 默认 WIFI 账号密码配置存放在 `/boot/wpa_supplicant.conf` 里，测试过并支持 Android 手机开放的 WPA PSK2 热点，配置修改后会在重启后生效（**建议用 nmtui connect 进行配置连接**)。 ```bash root@AXERA:~# cat /boot/wpa_supplicant.conf ctrl_interface DIR /var/run/wpa_supplicant GROUP netdev update_config 1 network { ssid \"Sipeed_Guest\" key_mgmt WPA PSK psk \"qwert123\" } ``` #### 如何扫描 WIFI 热点（已过时） 这需要了解 iwconfig 和 iwlist 命令去管理 WIFI 网卡，例如 WIFI 扫描方法 `iwlist wlan0 scanning`，由于 iwconfig 只支持无密码和 WEP 认证的热点，所以现已不使用这个命令，仅供简单的查询热点或测试 WIFI 的好与坏。 ``` root@AXERA:~# iwlist wlan0 scanning wlan0 Scan completed : Cell 01 Address: 58:41:20:05:07:96 ESSID:\"Sipeed_Guest\" Protocol:IEEE 802.11bgn Mode:Master Frequency:2.412 GHz (Channel 1) Encryption key:on Bit Rates:300 Mb/s Extra:wpa_ie dd160050f20101000050f20401000050f20401000050f202 IE: WPA Version 1 Group Cipher : CCMP Pairwise Ciphers (1) : CCMP Authentication Suites (1) : PSK Extra:rsn_ie 30140100000fac040100000fac040100000fac020000 IE: IEEE 802.11i/WPA2 Version 1 Group Cipher : CCMP Pairwise Ciphers (1) : CCMP Authentication Suites (1) : PSK Quality 100/100 Signal level 100/100 Extra:fm 0003 Cell 02 Address: 0C:3A:FA:0E:81:7F ESSID:\"\" Protocol:IEEE 802.11bgn Mode:Master Frequency:2.412 GHz (Channel 1) Encryption key:off Bit Rates:144 Mb/s Quality 100/100 Signal level 88/100 Extra:fm 0001 Cell 03 Address: 64:64:4A:88:7F:06 ESSID:\"Reachintelligent\" Protocol:IEEE 802.11bgn Mode:Master Frequency:2.412 GHz (Channel 1) Encryption key:on Bit Rates:144 Mb/s Extra:rsn_ie 30140100000fac040100000fac040100000fac020c00 IE: IEEE 802.11i/WPA2 Version 1 Group Cipher : CCMP Pairwise Ciphers (1) : CCMP Authentication Suites (1) : PSK IE: Unknown: DD7B0050F204104A0001101044000102103B00010310470010876543219ABCDEF0123464644A887F04102100067869616F6D69102300045241373210240004303030321042000531323334351054000800060050F20400011011000C5869616F4D69526F75746572100800020000103C0001031049000600372A000120 Quality 100/100 Signal level 100/100 Extra:fm 0003 ``` > 目前所有的网络配置都会在重启后自动生效，如果想要自己手工控制网卡的开关，请了解一下 ifup 或 ifdown 命令的用法，类似 ifup eth0 启动 eth0 网卡，ifdown eth0 force 强制关闭 eth0 网卡等。 ## 系统配置 ### 系统时间 Maix III AXera Pi 开发板的 Linux 系统默认使用 NTP 协议获取系统时间，可以使用 `date` 命令查看当前系统时间。 > 如果联网了会自动使用 `ntp debian` 同步时间，没有同步则说明没有网络，没有同步 `apt update` 更新软件也会失败。 ### 安装软件 Maix III AXera Pi 开发板的 Linux 系统可以通过 `apt` 更新软件。 比如安装 gcc gdb ffmpeg 等常用 Linux 软件，只需要使用下述命令即可，其他软件安装也同理。 ```bash sudo apt update sudo apt install gcc gdb ffmpeg ``` .. details::点此展开查看示例图 ![apt](./../assets/apt.jpg) > 由于 Linux 系统直接断电可能会导致文件系统损坏，如果可以的话建议按下述命令去进行开关机，可以避免一些由于直接断电系统损坏导致的奇怪问题出现。 ### 重启系统 Maix III AXera Pi 开发板的 Linux 系统可以通过 `reboot` 命令重启，重启命令如下： ```bash reboot ``` ### 关闭系统 Maix III AXera Pi 开发板的 Linux 系统可以通过 `poweroff` 命令关闭，关闭命令如下： ```bash poweroff ``` ### 磁盘扩容 基于一些用户可能有扩容分区的需求，因此在这里添加在 AXera Pi 上给板子扩容或者是建立新分区的内容。 操作方法 首先需要烧录完上方的 debian11 的镜像系统后，再使用 AXera Pi 登陆上 Linux 系统来进行磁盘扩容分区。 >[点击查看 AXera Pi 登陆方式](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95) 成功登陆到 AXera Pi 上后，用户可以先使用 `lsblk` 命令来查看设备当前的存储情况。接着使用 `cfdisk /dev/mmcblk2` 来进行磁盘分区扩容的操作。（`mmcblk2` 是我们进行操作的区域名称也称设备名） .. details::点击查看配置示意图 ![cfdisk](./../assets/cfdisk mmcblk2.jpg) 运行命令后终端会弹出下图操作界面，由 `Free space` 可见存储空间还余 `4.3G`，用户可使用键盘上的方向键移动选择我们要扩容的分区 `/dev/mmcblk2p2` 。 .. details::点击查看配置示意图 ![rizese mmcblk2](./../assets/rizese mmcblk2.png) 选择上图的 `Resize` 按下**回车键**对当前分区进行缩容或扩容，界面会跳出提示用户修改新的分区大小。 .. details::点击查看配置示意图 ![new resize](./../assets/new resize.png) 修改后敲**回车键**确定，终端界面会回到原页面。这时我们已经完成对分区扩容的修改了，还需要把改动的部分写入磁盘。在页面选择 `Write` 并敲**回车键**后输入 `yes` 确定将改动分区表写入磁盘中，再敲**回车键**即可。 .. details::点击查看配置示意图 ![write disk](./../assets/write disk.png) 操作后会返回原界面，选择 `Quit` 退出即可。 .. details::点击查看配置示意图 ![quit](./../assets/quit.jpg) 接下来使用命令行 `df h` 查询磁盘使用空间的情况，终端会显示用户没改动之前的使用情况，需要我们使用命令 `resize2fs /dev/mmcblk2p2` 来调整文件系统的大小实现对 `mmcblk2` 分区的扩容，再使用 `df h` 查询就可以看到磁盘改动后的情况。 .. details::点击查看配置示意图 ![df mmcblk2](./../assets/df mmcblk2.jpg) > **注意**：如果调整完文件系统的大小后使用 `df h` 查询磁盘信息依旧是改动前的信息，可使用 `reboot` 重启设备后在查询。 ### 开机启动脚本 系统已经内置好 `/boot/rc.local` 的开机启动脚本，用户可参照以下示例进行修改。 开机启动脚本是在 / 根目录下运行的，举例来说，如果想要开机启动 `/home/run.sh` 脚本。 1. 用绝对路径挂后台运行程序 `/home/run.sh & ` 才可以确保开机后进入 shell 命令终端。 2. 【推荐】用相对路径挂后台运行程序 `cd /home && ./run.sh &` 注意此时 pwd 和绝对路径是不一样。 请先验证好可以在 / 根目录下启动后再放入以下的开机脚本中，不会就抄以下脚本的例子。 ```bash root@AXERA:~# cat /boot/rc.local #!/bin/sh # this file is called by /etc/rc.local at boot. # systemctl stop usb gadget@g0 # mkdir p /mnt/udisk && mount /dev/sda1 /mnt/udisk # python3 /mnt/udisk/alltest.py # this control lcd backlight(50 ~ 1000) echo 0 > /sys/class/pwm/pwmchip0/export echo 1000 > /sys/class/pwm/pwmchip0/pwm0/period echo 500 > /sys/class/pwm/pwmchip0/pwm0/duty_cycle echo 1 > /sys/class/pwm/pwmchip0/pwm0/enable # wifi connect ssid Sipeed_Guest pasw qwert123 nmcli device wifi connect Sipeed_Guest password qwert123 if [ f \"/root/boot\" ]; then cd /root/ && chmod 777 * && ./boot & elif [ d \"/root/app\" ]; then cd /root/app && chmod 777 * if [ f \"./main\" ]; then ./main & elif [ f \"./main.bin\" ]; then ./main.bin & elif [ f \"./main.py\" ]; then python3 ./main.py & fi else aplay /home/res/boot.wav >/dev/null 2>&1 & /opt/bin/sample_vo_fb v dsi0@480x854@60 m 0 >/dev/null 2>&1 & sleep 0.8 && /home/fbv 1.0b/fbv /home/res/2_480x854.jpeg && killall sample_vo_fb & python3 c \"import os, binascii; os.system('sed i \\'/iface eth0 inet dhcp/ahwaddress ether {}\\' /etc/network/interfaces'.format(binascii.hexlify(bytes.fromhex(open('/proc/ax_proc/uid').read().split('0x')[1][: 5]),':').decode('iso8859 1'))) if os.system('grep \\'hwaddress ether\\' /etc/network/interfaces q') ! 0 else exit();\" & fi exit 0 ``` .. details::点此展开查看示例图 ![start](./../assets/start.jpg) .. details::点击查看连接后串口输出的 debian11 系统启动日志。 ```bash Vddr init success! The system boot form EMMC enter boot normal mode U Boot 2020.04 (Jun 16 2022 00:16:34 +0800) Model: AXERA AX620_demo Board DRAM: 1 GiB NAND: unknown raw ID 77ee0178 uclass_get_device: Invalid bus 0 (err 524) 0 MiB initr_pinmux: delay pinmux_init for env board id MMC: enter sdhci_cdns_get_cd call mmc_getcd enter sdhci_cdns_get_cd call mmc_getcd mmc@10000000: 0, mmc@4950000: 1 Loading Environment from MMC... OK In: serial Out: serial Err: serial MMC: no card present sd card is not present enter normal boot mode Net: reset EMAC0: ethernet@0x4970000 ... Warning: ethernet@0x4970000 (eth0) using random MAC address 6a:e4:fd:58:97:ea eth0: ethernet@0x4970000 Hit any key to stop autoboot: 0 reading DTB and BOOT image ... reading bootimg header... MAGIC: AXERA! img size: 4841536 kernel_size: 4841472 kernel_addr: 64 id:bc 19 bb a7 2d 27 74 de 7c 91 4b 70 ea c9 ab 96 50 61 bd e0 2b 02 8b e5 c8 ee 22 ce df b1 cf ea load kernel image addr 0x40008000,load dtb image addr 0x48008000 boot cmd is :bootm 0x40008000 0x48008000 ## Booting kernel from Legacy Image at 40008000 ... Image Name: Linux 4.19.125 Image Type: ARM Linux Kernel Image (uncompressed) Data Size: 4839952 Bytes 4.6 MiB Load Address: 40008000 Entry Point: 40008000 Verifying Checksum ... OK ## Flattened Device Tree blob at 48008000 Booting using the fdt blob at 0x48008000 Loading Kernel Image Using Device Tree in place at 48008000, end 480103d6 Starting kernel ... Welcome to Debian GNU/Linux 11 (bullseye)! [ OK ] Created slice system getty.slice. [ OK ] Created slice system modprobe.slice. [ OK ] Created slice system serial\\x2dgetty.slice. [ OK ] Created slice User and Session Slice. [ OK ] Started Dispatch Password …ts to Console Directory Watch. [ OK ] Started Forward Password R…uests to Wall Directory Watch. [ OK ] Reached target Local Encrypted Volumes. [ OK ] Reached target Network is Online. ...... >因物料更换屏幕现有不同的版本，需区别版本以及使用屏幕时出现锯齿等画面请移步到[ Maix III 系列 AXera Pi 常见问题(FAQ) ](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html#Q：硬件物料更改说明、没有 wlan0 、屏幕烧屏、摄像头倒过来怎么解决？)查询。 ### 更新内核与驱动 在 SD 卡的第一分区会挂载到系统根目录下的 /boot 系统启动相关的文件，替换它后重启（reboot）即可完成更新。 boot.bin 芯片 spl 初始化程序 uboot.bin uboot 启动引导程序 kernel.img linux 内核 dtb.img linux 设备树 例如： 更新设备树可以用 `cp /boot/dtb.img.lcd20221025 /boot/dtb.img` 更新内核驱动可以用 `cp /boot/kernel.img.rtl8723bs /boot/kernel.img` 最后 reboot 即可生效。 ## 如何传输文件 > 如果在使用 AXera Pi 途中出现从设备到电脑端文件互传的需求，可根据以下的方式进行传输： ### 使用读卡器物理拷贝文件 **物理传输**：由于 Linux 系统采用 `ext4` 分区在 Windows / Mac 默认系统下无法进行查看，用户需额外安装增强工具才能读取到具体的分区。而 Linux 系统可直接看到卡里的分区和内容，也可以选择把读卡器接到安卓设备通过 **OTG** 转接头实现文件拷贝。 [如何在 Windows 下访问 ext4 格式的硬盘？](https://zhuanlan.zhihu.com/p/448535639) [[macOS] 在 macOS 上挂载 Linux 的 ext/ext3/ext4 文件系统](https://blog.twofei.com/773/) ### 板子与电脑的文件互传 >基于让用户的使用更加快速便捷，还可以选择直接在板子上与电脑端通过工具实现文件互传。 **使用 SSH 远程管理工具进行文件传输：** 使用前需要使用 `ifconfig` 查询板子的 IP 地址做登录备用，可点击前往[系统登录](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E5%9F%BA%E4%BA%8E ip %2B ssh %E7%99%BB%E5%BD%95)查看。在 Windows 上有众多远程管理 Linux 服务器的工具都提供了文件传输的功能，这里推荐免费绿色的 **Mobaxterm** 工具。 [如何使用 MobaXterm](https://wiki.sipeed.com/hardware/zh/maixII/M2/tools/mobaxterm.html) [利用 MobaXterm 实现 Linux 和 Windows 之间传输文件](https://jingyan.baidu.com/article/9f63fb91e2bc6688400f0e93.html) [用 MobaXterm 在 Linux 和 Windows 之间上传/下载文件](https://blog.csdn.net/unforgettable2010/article/details/123930796) > 如果想了解更多的工具可点击[【推荐7款超级好用的终端工具 —— SSH+FTP】](https://zhuanlan.zhihu.com/p/301653835)查看，而其他系统都提供了好用的命令行终端，支持 SSH 、scp 等命令直接执行。 **使用 scp 命令复制文件：** 和 cp 复制文件等命令一样，它就是 `ssh + cp scp` 这个意思。 [Linux 操作系统 scp 命令使用方法](https://cloud.tencent.com/developer/article/1876623) **使用有线串口互传文件：** 使用前根据串口 serial 登录接线配置参数连上板子，安装 `apt get install lrzsz` 工具后可参考以下文章。 [有线串口 serial 登录](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E6%9C%89%E7%BA%BF %E4%B8%B2%E5%8F%A3 serial %E7%99%BB%E9%99%86) 使用命令行工具 `minicom D /dev/ttyUSB0 b 115200` 可以查看[ Ubuntu 中使用 minicom 玩转文件的上传与下载](https://blog.csdn.net/wanyeye/article/details/42002377)。 使用 MobaXterm 可以点击 [MobaXterm 使用 rz/sz 传送文件](https://blog.csdn.net/qq_28837389/article/details/120073720)查看。 ## 验证系统外设 ### 系统预置的资源 Maix III AXera Pi 开发板的 Linux 系统预置了一些资源，可以通过 `ls /opt` 命令来查看。 ```bash root@AXERA:~# ls /opt bin include lib scripts share ``` 还有一些在 `home` 目录下： ```bash root@AXERA:~# tree L 1 /home ├── ax samples # npu ai sdk ├── examples # 一些开箱示例 ├── fbv 1.0b # fbv 图片查看器 ├── images # 一些测试图片 ├── libmaix # simple pipeline sdk ├── models # 内置的 AI 模型 ├── res # 一些图像字体资源 ├── systemd usb gadget # 配置 usb 服务 ├── usb uvc gadget # 配置 uvc 服务 └── ustreamer # mjpeg 图传 ``` 板子已经预置了 `gcc g++ gdb libopencv ffmpeg` 等工具，可直接在板上编译运行程序。 可参考下方使用方法： ```bash cd /home/libmaix/examples/axpi/ python3 project.py build fbon ./dist/start_app.sh ``` .. details::点击查看示例效果 使用命令行后会打印大量数据信息并启动摄像头及屏幕。 ![libmaix](./../assets/libmaix.jpg) 而 axsample 已经预编译好了，相关 joint 模型已内置在 `/home/models/` 下便于用户查询。 ```bash /home/ax samples/build/install/bin/ax_yolov5s m /home/models/yolov5s.joint i /home/images/cat.jpg r 10 fbon fbv yolov5s_out.jpg ``` .. details::点击查看效果 输入上方命令后屏幕会显示 yolovs_out.jpg 图像 ![cat](./../assets/cat.jpg) 可以在联网后直接 `git pull` 更新仓库的提交记录，如果不能访问 github 的话就设置一下 `git remote` 从 gitee 拉取代码吧。 > **注意**：使用 xxxx menuconfig 报错请移步[Maix III 系列 AXera Pi 常见问题（FAQ）](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html) ### 排针引脚图 ![layout_axpi](./../assets/layout_axpi_1.png) ### RTC 使用 `ls /sys/class/rtc` 查询会出现 /dev/rtc0 和 /dev/rtc1，分别是外部电池以及芯片内部的 rtc 时钟。 **查看时间** ```bash cat /sys/class/rtc/rtc0/time && cat /sys/class/rtc/rtc0/date cat /sys/class/rtc/rtc1/time && cat /sys/class/rtc/rtc1/date ``` ```bash root@AXERA:~# cat /sys/class/rtc/rtc0/time && cat /sys/class/rtc/rtc0/date 08:13:30 2022 08 19 ``` **设置时间** 使用 `hwclock w f /dev/rtc0` 或 `hwclock w f /dev/rtc1` 写入。 只有这个方法可以写进去，确认 RTC 是否写入成功，只需要断电后重启的时间不为 1970 就行。 ### CPU & RAM 默认 800MHz 可以调到 1ghz. ```bash root@AXERA:~# ax_lookat 0x01900000 s 33 0x1900000:00000033 root@AXERA:~# ax_clk AX620A: DDR: 3733 MHz CPU: 800 MHz BUS of VPU: 624 MHz BUS of NPU: 624 MHz BUS of ISP: 624 MHz BUS of CPU: 624 MHz NPU OTHER: 800 MHz NPU GLB: 24 MHz NPU FAB: 800 MHz NPU CORE1: 800 MHz NPU CORE0: 800 MHz ISP: 533 MHz MM: 594 MHz VPU: 624 MHz root@AXERA:~# ax_lookat 0x01900000 s 35 0x1900000:00000035 root@AXERA:~# ax_clk AX620A: DDR: 3733 MHz CPU: 1000 MHz BUS of VPU: 624 MHz BUS of NPU: 624 MHz BUS of ISP: 624 MHz BUS of CPU: 624 MHz NPU OTHER: 800 MHz NPU GLB: 24 MHz NPU FAB: 800 MHz NPU CORE1: 800 MHz NPU CORE0: 800 MHz ISP: 533 MHz MM: 594 MHz VPU: 624 MHz root@AXERA:~# ``` 目前硬件内存虽然是 2g 但在系统上只能看到 745M ，不用担心，这是目前的分配内存过于保守导致的，后续更新内核调整一下 NPU 和 CMM 的内存分配的。**(注：内核已更新，用户空间恢复 1.22G)** ### VIDEO （这是出厂测试硬件用的测试程序，请不要使用它！！因为它画面显示是不正常的！！！） >**注意**：VIDEO 的以下命令只用于测试摄像头硬件是否有成像能用的作用，正常效果角度请点击应用传送门查看！！ >内置开箱应用传送门：[点击前往](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E5%86%85%E7%BD%AE%E5%BC%80%E7%AE%B1%E5%BA%94%E7%94%A8) 目前系统的摄像头驱动不经过 v4l2 驱动框架，所以必须通过代码配置的方式进行启用，相关摄像头驱动都是在应用层上完成的， gc4653 （基础版）（使用 c 2) os04a10（夜视版）（使用 c 0) ```bash sample_vin_vo c 2 e 1 s 0 v dsi0@480x854@60 ``` .. details::运行上方命令后可看到画面（示例效果） ![video](./../assets/video.jpg) >默认使用的是 gc4653 ，使用 os04a10 请移步[Maix III 系列 AXera Pi 常见问题(FAQ)](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html)查询。 ### DISPLAY > 因物料更换屏幕现有不同的版本，需区别版本以及使用屏幕时出现锯齿等画面请移步到[ Maix III 系列 AXera Pi 常见问题(FAQ) ](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html#Q：硬件物料更改说明、没有 wlan0 、屏幕烧屏、摄像头倒过来怎么解决？)查询。 目前想要使用 libdrm 需要搭配代码使用，请参考 sdk 的源码实现，因为目前系统还未移植好 gpu 驱动所以无法使用 modetest 进行测试，但可以参考下面进行测试。 测试屏幕是否能用, 可以直接运行命令 `sample_vo v dsi0@480x854@60 m 0` 命令屏幕会显示出彩色条纹。但使用前务必调用 `fboff` 关闭 fb 设备。 目前系统默认使用的是最简单的 framebuffer 显示驱动（/dev/fb0），在系统里内置了 `fbon / fboff / fbv xxx.jpg` 三个命令负责管理 fb 设备的启用和显示。 #### 显示一张图片 ```bash fbon fbv /home/res/logo.png fboff ``` ![fbv_logo](./../assets/fbv_logo.jpg) #### 播放视频 播放视频可以使用 ffmpeg 的命令，但请注意 ffmpeg 播放视频前需要将视频顺时针旋转 90°，将 RGB 视频变成 BGR 格式以及分辨率 resize 改成 480*854。如果出现视频播放速度太快的现象就需要使用 `ffmpeg i /home/kun_1_output.mp4 vf \"setpts 2*PTS\" test3.mp4` 重新生成一个慢速的视频文件，再次播放即可。 ```bash fbon ffmpeg i /home/test3.mp4 pix_fmt rgba f fbdev /dev/fb0 fboff ``` 在 python 中可以使用 `os.system()` 将上面的命令包裹起来，直接在代码里面运行。 ```python import os os.system(\"fbon\") os.system(\"fbv /home/res/logo.png\") os.system(\"fboff\") os.system(\"fbon\") os.system(\"ffmpeg i /home/test3.mp4 pix_fmt rgba f fbdev /dev/fb0\") os.system(\"fboff\") ``` ### NPU 测试 NPU 的示例程序在 `/home/ax samples/build/install` 目录下，已经预编译好了，直接就可以调用并显示运行结果。 ```bash fbon /home/ax samples/build/install/bin/ax_yolov5s m /home/models/yolov5s.joint i /home/images/cat.jpg r 10 fbv yolov5s_out.jpg ``` .. details::点击查看效果 ![cat](./../assets/cat.jpg) ### AUDIO 和桌面系统保持一致，直接可用 alsa utils 进行测试。 **测试脚本**：`speaker test t sine f 440 c1` **录制音频**：`arecord test.wav c 2 f cd d 2` **播放音频**：`aplay test.wav` 录音回放的 `python3` 代码如下： ```python import pyaudio try: chunk 1024 # Each chunk will consist of 1024 samples sample_format pyaudio.paInt16 # 16 bits per sample channels 2 # Number of audio channels fs 44100 # Record at 44100 samples per second time_in_seconds 30 p pyaudio.PyAudio() stream p.open(format sample_format, channels channels, rate fs, frames_per_buffer chunk, input True, output True) # Store data in chunks for 3 seconds for i in range(0, int(fs / chunk * time_in_seconds)): data stream.read(chunk) stream.write(data) finally: # Stop and close the Stream and PyAudio stream.stop_stream() stream.close() p.terminate() ``` 可以在 alsamixer 配置你的设备，如果不了解的话建议不要修改。 ![alsamixer](./../assets/alsamixer.jpg) ### USB >**注意**：由于芯片只有一个完整功能的 usb2.0，同一时刻下只有一个使用方向如 OTG 从机或 HOST 主机。 #### 如何配置 USB OTG 虚拟网卡 RNDIS usb0 有线 ssh 登录 默认就会启动配置 `systemctl enable usb gadget@g0`，启动用 `systemctl start usb gadget@g0`，停止开机启动用 `systemctl disable usb gadget@g0`，停止服务用`systemctl stop usb gadget@g0`。 此时使用命令 `sshpass p root ssh root@192.168.233.1` 即可连接，账号及密码都是 root 。 ![ssh usb](./../assets/ssh usb.jpg) #### 如何配置 USB OTG 虚拟串口 /dev/ttyGS0 并转发登录接口 停止 usb gadget@g0 后使用 `systemctl start usb gadget@g1` 即可看到，然后使用 `systemctl start getty@ttyGS0` 即可转发串口终端到 usb 的虚拟串口上。 ![usb_tty](./../assets/usb_tty.jpg) #### 如何使用 USB HOST 读取一个 256M 的 SD 卡 先关了 otg 的 rndis 后再 lsusb 就可以看到了。 >我们在 debian 系统上配置了 usb gadget@g1 和 usb gadget@g0 两个服务。 ```bash root@AXERA:~# systemctl stop usb gadget@g0 root@AXERA:~# lsusb Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub Bus 001 Device 002: ID 067b:2731 Prolific Technology, Inc. USB SD Card Reader Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub root@AXERA:~# fdisk l Disk /dev/mmcblk2: 58.94 GiB, 63281561600 bytes, 123596800 sectors Units: sectors of 1 * 512 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x32eb5429 Device Boot Start End Sectors Size Id Type /dev/mmcblk2p1 * 2048 264191 262144 128M c W95 FAT32 (LBA) /dev/mmcblk2p2 264192 123596799 123332608 58.8G 83 Linux Disk /dev/sda: 240 MiB, 251658240 bytes, 491520 sectors Disk model: SD Card Reader Units: sectors of 1 * 512 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x0607cfd2 Device Boot Start End Sectors Size Id Type /dev/sda1 * 240 490239 490000 239.3M e W95 FAT16 (LBA) root@AXERA:~# mkdir /mnt/sdcard && mount /dev/sda1 /mnt/sdcard ``` 一步到位挂载 U 盘第一分区的命令 `systemctl stop usb gadget@g0 && lsusb && mkdir p /mnt/udisk && mount /dev/sda1 /mnt/udisk` #### 如何配置 USB OTG 虚拟一个 USB 摄像头 **usb uvc gadget**：[usb uvc gadget](https://github.com/junhuanchen/usb uvc gadget) **更多详情请移步内置应用查看**：[应用传送门](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#UVC %E8%99%9A%E6%8B%9F USB %E6%91%84%E5%83%8F%E5%A4%B4) #### 如何配置 USB HOST 读取一个 USB 摄像头 >适配 usb 摄像头前我们需要给板子接上以太网 `eth0`，使用 `ifconfig` 查询以太网的 `IP` 方便我们使用。 >如果获取不到以太网的 `IP` 地址，请移步右侧进行重新启动/配置[点击前往相关](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E6%9C%89%E7%BA%BF%E4%BB%A5%E5%A4%AA%E7%BD%91%EF%BC%88eth0%EF%BC%89%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95)。 **Ustreamer**：[点击查看相关仓库](https://github.com/pikvm/ustreamer) 运行下方的命令行，终端会弹出调试信息无明显报错后，打开任意浏览器输入我们刚获取的以太网 `IP` 地址，进入 `ustreamer` 使用体验拍照及录像功能。 ```bash /home/ustreamer/ustreamer device /dev/video0 host 0.0.0.0 port 80 ``` ![ustreamer_adb](./../assets/ustreamer_adb.png) `snapshot` 为拍照功能，`stream` 为视频功能。 ![ustreamer](./../assets/ustreamer.png) .. details::点击查看效果图 ![ustreamer_snapshot](./../assets/ustreamer_snapshot.jpg) **使用 Opencv 读取 USB 摄像头** 可在终端进入 `python3` 模式运行以下代码即可使用 USB 摄像头进行拍照。 ```python import os import cv2 video cv2.VideoCapture(0) for i in range(30): ret, frame video.read() if ret: cv2.imwrite(\"/tmp/capture.jpg\", frame) os.system(\"fbon && fbv /tmp/capture.jpg\") ``` .. details::点击查看终端运行图以及效果图 ![opencv](./../assets/opencv.jpg) ![opencv_cream](./../assets/opencv_cream.jpg) >运行出现报错请移步[Maix III 系列 AXera Pi 常见问题(FAQ)](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html)进行查询。 ### GPIO #### 读取 KEY 按键输入：GPIO2 21 ```bash echo 85 > /sys/class/gpio/export echo in > /sys/class/gpio/gpio85/direction cat /sys/class/gpio/gpio85/value ``` #### 点亮 LED 灯 GPIO2 A4 A5 68 69 ```bash echo 68 > /sys/class/gpio/export echo out > /sys/class/gpio/gpio68/direction echo 1 > /sys/class/gpio/gpio68/value sleep 1 echo 0 > /sys/class/gpio/gpio68/value sleep 1 echo 1 > /sys/class/gpio/gpio68/value ``` > 计算规则 GPIO2 A4 32 * 2 + 4 68 对于爱芯的芯片，GPIO0 和 GPIO2 对应 A 和 C ，此处 A4 并不代表 GPIO2 只是序号。 也就是 GPIO2 A4 在标准设备中的定义为 GPIO C(2) 4(A4) 同理 GPIOA0 对应 GPIO0A4。 以后主流会统一到 PA0 或 PC4 这类定义，方便不同芯片共同定义。 使用 Python 控制排针上的 GPIO 方法举例，可见排针上的 BOT_GPIO_0 7 对应 GPIO2_A16_m GPIO2_A23_m 喔。 ![io_pin_map](./../assets/io_pin_map.png) 可见排针的 PA0 3 与上图的关系。 ![gpio_axpi](./../assets/gpio_axpi.png) 先在 python3 中加载简易封装 gpio 类，使用的是 linux 的 libgpiod 的 python 版本。 ```python try: from gpiod import chip, line, line_request config None # rpi is default value A 0 def gpio(gpio_line 0, gpio_bank \"a\", gpio_chip 0, line_mode line_request.DIRECTION_OUTPUT): global config if config ! None and gpio_line in config: gpio_bank, gpio_chip config[gpio_line] l, c [32 * (ord(gpio_bank.lower()[0]) ord('a')) + gpio_line, chip(\"gpiochip%d\" % gpio_chip)] tmp c.get_line(l) cfg line_request() # led.active_state line.ACTIVE_LOW cfg.request_type line_mode # line.DIRECTION_INPUT tmp.request(cfg) tmp.source \"GPIO chip %s bank %s line %d\" % (gpio_chip, gpio_bank, gpio_line) return tmp def load(cfg None): global config config cfg except ModuleNotFoundError as e: pass ``` GPIO 输入测试： ```python led0 gpio(16, gpio_chip 2, line_mode line_request.DIRECTION_INPUT) led1 gpio(17, gpio_chip 2, line_mode line_request.DIRECTION_INPUT) led2 gpio(18, gpio_chip 2, line_mode line_request.DIRECTION_INPUT) led3 gpio(19, gpio_chip 2, line_mode line_request.DIRECTION_INPUT) def test(): import time print(led0.get_value()) print(led1.get_value()) print(led2.get_value()) print(led3.get_value()) time.sleep(1) print(time.asctime()) while True: test() ``` GPIO 输出测试： ```python led0 gpio(16, gpio_chip 2, line_mode line_request.DIRECTION_OUTPUT) led1 gpio(17, gpio_chip 2, line_mode line_request.DIRECTION_OUTPUT) led2 gpio(18, gpio_chip 2, line_mode line_request.DIRECTION_OUTPUT) led3 gpio(19, gpio_chip 2, line_mode line_request.DIRECTION_OUTPUT) def test(): import time time.sleep(1) led0.set_value(1) led1.set_value(1) led2.set_value(1) led3.set_value(1) time.sleep(1) led0.set_value(0) led1.set_value(0) led2.set_value(0) led3.set_value(0) print(time.asctime()) while True: test() ``` [可参考的 gpio.h/gpio.c 代码](https://www.cnblogs.com/juwan/p/16917802.html#linux spiv) ### UART > 关闭 ttyS0 交互在开机后用 `systemctl stop serial getty@ttyS0.service` 串口就不会再出现交互了，但彻底禁用遇到点问题，重启后会恢复，待研究。 系统输出默认是 **ttyS0** ，排针上的是 **ttyS1** ，而虚拟串口是 **ttyGS0**。 ![uart_tty](./../assets/uart_tty.jpg) 可用 `python3 pyserial` 库来测试功能的好与坏，但是需要注意排针丝印可能不准确。 如果出现串口的 tx 和 rx 没有数据的话可以反接一下，以及确保是共地的。 ```python import serial ser serial.Serial('/dev/ttyS1', 115200, timeout 1) ser.write(b'hello world\\n') ser.close() ``` [可参考的 uart.h/uart.c 代码](https://www.cnblogs.com/juwan/p/16917802.html#linux uart ttysx) ### PWM 以配置一个 pwm0 修改屏幕背光为例，需更新到 **20221201** 后的镜像。 **例**：`echo 204 > /sys/class/pwm/pwmchip0/pwm0/duty_cycle` 运行后屏幕亮度只有十分之一. ```bash echo 0 > /sys/class/pwm/pwmchip0/export echo 4167 > /sys/class/pwm/pwmchip0/pwm0/period echo 204 > /sys/class/pwm/pwmchip0/pwm0/duty_cycle echo 2084 > /sys/class/pwm/pwmchip0/pwm0/duty_cycle echo 1 > /sys/class/pwm/pwmchip0/pwm0/enable ``` PWM 使用参考：[点击查看](https://wiki.sipeed.com/soft/maixpy3/zh/usage/hardware/PWM.html#%E5%BC%80%E5%A7%8B) ### I2C > m3axpi 的排针上的 I2C 是 /dev/i2c 7 对应 `i2cdetect y r 7` 喔， 0 1 2 是摄像头的， 8 是系统的 usb rtc 的， 9 做预留。 使用 i2c tools 工具包，可使用 i2cdetect y 0 来查看 i2c 总线上的设备。 如果出现 i2c 设备扫不到的情况需要接一下上拉电阻。 ```bash root@AXERA:~# i2cdetect y r 0 0 1 2 3 4 5 6 7 8 9 a b c d e f 00: 10: 20: 21 30: 36 40: 50: 60: 70: root@AXERA:~# ``` 这里 **0x21** 和 **0x36** 就代表的板子在 cam0 这个排线上的 /dev/i2c 0 设备存在某个摄像头的 i2c 设备，而读写可用 i2cget 和 i2cset 命令，与其他芯片皆为同理。 ### SPI 可参考右边同理事例：[为 AW V831 配置 spidev 模块，使用 py spidev 进行用户层的 SPI 通信。](https://www.cnblogs.com/juwan/p/14341406.html) ``` root@AXERA:~# ./spidev_test D /dev/spidev1.0 v spi mode: 0x0 bits per word: 8 max speed: 500000 Hz (500 KHz) TX FF FF FF FF FF FF 40 00 00 00 00 95 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF F0 0D ......@....�..................�. RX FF FF FF FF FF FF 40 00 00 00 00 95 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF F0 0D ......@....�..................�. root@AXERA:~# ./spidev_test D /dev/spidev1.0 v spi mode: 0x0 bits per word: 8 max speed: 500000 Hz (500 KHz) TX FF FF FF FF FF FF 40 00 00 00 00 95 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF F0 0D ......@....�..................�. RX FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF ................................ root@AXERA:~# ./spidev_test D /dev/spidev1.0 v spi mode: 0x0 bits per word: 8 max speed: 500000 Hz (500 KHz) TX FF FF FF FF FF FF 40 00 00 00 00 95 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF F0 0D ......@....�..................�. RX FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF ................................ ``` ### CHIP ID 获取芯片唯一的 id 码。 ``` cat /proc/ax_proc/uid ``` ### ADC（暂未支持） .. details::点击查看 硬件上支持，但软件上目前还没写调试工具配合。 可参考外围开发手册，这需要专用的代码控制，目前还没有全部补充完。 1. 设置 THM 寄存器 2. 中间需要 delay 一段时间，否则读取出来的值，可能不对. 3. 0x2000028 寄存器读取出来的值 DATA 4. DAT 和 voltage 的对应关系，voltage DATA / 1024 * VREF(1.8V) 5. 如果读取 chan1/2/3/4，需要读取 0x200002c，0x2000030，0x2000034，0x2000038 使能 ADC 通道 devmem 0x2000020 32 0x1000 //chan0 devmem 0x2000020 32 0x800 //chan1 devmem 0x2000020 32 0x400 //chan2 devmem 0x2000020 32 0x200 //chan3 devmem 0x2000020 32 0x100 //chan4 devmem 0x200002c devmem 0x2000030 devmem 0x2000034 devmem 0x2000038 ### 出厂测试脚本 .. details::点击可查看产品出厂测试时用的 Python 测试脚本 ```python test_flag False try: from gpiod import chip, line, line_request config None # rpi is default value A 0 def gpio(gpio_line 0, gpio_bank \"a\", gpio_chip 0, line_mode line_request.DIRECTION_OUTPUT): global config if config ! None and gpio_line in config: gpio_bank, gpio_chip config[gpio_line] l, c [32 * (ord(gpio_bank.lower()[0]) ord('a')) + gpio_line, chip(\"gpiochip%d\" % gpio_chip)] tmp c.get_line(l) cfg line_request() # led.active_state line.ACTIVE_LOW cfg.request_type line_mode # line.DIRECTION_INPUT tmp.request(cfg) tmp.source \"GPIO chip %s bank %s line %d\" % (gpio_chip, gpio_bank, gpio_line) return tmp def load(cfg None): global config config cfg except ModuleNotFoundError as e: pass key gpio(21, gpio_chip 2, line_mode line_request.DIRECTION_INPUT) led0 gpio(4, gpio_chip 2, line_mode line_request.DIRECTION_OUTPUT) led1 gpio(5, gpio_chip 2, line_mode line_request.DIRECTION_OUTPUT) import time import ifcfg import os def check_ifconfig(): result [] for name, interface in ifcfg.interfaces().items(): if name in ['eth0', 'wlan0'] and interface['inet']: result.append(name) return result try: if (0 key.get_value()): os.system(\"export LD_LIBRARY_PATH /opt/lib:LD_LIBRARY_PATH && /opt/bin/sample_vin_vo c 2 e 1 s 0 v dsi0@480x854@60 &\") led1.set_value(1) while True: led0.set_value(1) time.sleep(0.2) led0.set_value(0) time.sleep(0.2) tmp check_ifconfig() if len(tmp) > 1: led0.set_value(0) led1.set_value(0) test_flag True break while (0 key.get_value()): time.sleep(0.2) os.system(\"aplay /home/res/boot.wav\") led0.set_value(1) led1.set_value(1) import pyaudio chunk 1024 # Each chunk will consist of 1024 samples sample_format pyaudio.paInt16 # 16 bits per sample channels 2 # Number of audio channels fs 44100 # Record at 44100 samples per second p pyaudio.PyAudio() stream p.open(format sample_format, channels channels, rate fs, frames_per_buffer chunk, input True, output True) while (1 key.get_value()): data stream.read(chunk, exception_on_overflow False) stream.write(data) while (0 key.get_value()): time.sleep(0.2) os.system('killall sample_vin_vo') os.system('killall sample_vin_vo') # Stop and close the Stream and PyAudio stream.stop_stream() stream.close() p.terminate() except Exception as e: print(e) finally: if test_flag: led0.set_value(0) led1.set_value(0) ''' import pyaudio try: chunk 1024 # Each chunk will consist of 1024 samples sample_format pyaudio.paInt16 # 16 bits per sample channels 2 # Number of audio channels fs 44100 # Record at 44100 samples per second time_in_seconds 300 p pyaudio.PyAudio() stream p.open(format sample_format, channels channels, rate fs, frames_per_buffer chunk, input True, output True) for i in range(0, int(fs / chunk * time_in_seconds)): data stream.read(chunk) stream.write(data) finally: # Stop and close the Stream and PyAudio stream.stop_stream() stream.close() p.terminate() ''' ``` ## 内置开箱应用 ### IPCDemo 这是一个典型的 IPC 演示程序，对应的功能模块有： ISP：负责从 Sensor 获取图像 RAW 数据并转为 YUV，最终分 3 路通道输出以上信息。 IVPS：图像视频处理模块。实现对视频图形进行一分多、Resize、Crop、旋转等功能。 VENC / JENC：视频/JPEG 编码输出。 Detect：支持人脸或结构化检测。 Web 显示：实现 H264 流的 Web 传输和提供 Web 方式查看实时视频。 RTSP 推流：实现 H264 流的 RTSP 封装以及传输。 录像 TF 卡存储：封装 H264 流为 MP4 格式文件并保存至 TF 卡或者 FLASH 空间。 <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 260625114&bvid BV1me411T7g8&cid 837160730&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\" style \"max width:640px; max height:480px;\"> </iframe> </p> <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 688159412&bvid BV1p24y1d7Te&cid 837167669&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\" style \"max width:640px; max height:480px;\"> </iframe> </p> #### 使用方法 >**注意**：启动命令默认的镜头型号为 **gc4653** ，因不同的摄像头配置文件不一致，使用别的型号时需点击右侧[更换摄像头](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html#Q%EF%BC%9A%E5%A6%82%E4%BD%95%E6%9B%B4%E6%8D%A2 os04a10 %E6%91%84%E5%83%8F%E5%A4%B4%EF%BC%9F)进行修改。 在终端运行下面的命令即可启动网页，服务默认绑定到 0.0.0.0 地址，直接在浏览器输入 usb0 的 IP 即可访问，使用板子上其他 IP 也可以访问页面（例如：`192.168.233.1:8080`）. ```bash /opt/bin/IPCDemo/run.sh /opt/bin/IPCDemo/config/gc4653_config.json ``` .. details::点击查看 输入启动命令后，终端会打印大量调试信息。 ![ipc](./../assets/ipc.jpg) 访问页面后会弹出登录页面，点击登录后页面会弹出下图画面。 ![ipc admin](./../assets/ipc admin.jpg) #### 如何抓拍？如何录制？ 浏览器抓拍录制（web） **抓拍图像** 网页经过上文的启动后显示画面，右下角有抓拍和录制的功能图标。 用户可点击摄像头图标进行抓拍喜欢的场景，抓拍的照片会在页面自动弹出进行下载方便用户查看存储。 ![ipc web](./../assets/ipc web.jpg) **录制视频** 点击右下角的录制图标，即可进入本地录制视频（mp4）模式，再次点击图标即录制完成结束。 ![ipc mp4](./../assets/ipc mp4.jpg) 用户可在配置页面的`录像回放`选项预览视频进行下载到本地或删除的操作。 ![ipc config](./../assets/ipc config.jpg) >**注意**： >版本为 **20221017** 的镜像后默认打开了录制保存到`/opt/mp4`的目录下。 >视频录制要储存到文件系统后才能打开，某种意义上用户也可以挂载网络路径来当监控录像使用。 #### 人脸检测 >IPCDemo 除了上文的基础功能还有进阶的 AI 功能应用，例如**：人脸检测、车牌识别**。 使用前先进行相机结构化配置再进行人脸检测，具体配置参考以下示例。 .. details::点击查看配置流程 接入页面后选择**配置**在**智能配置**里再进行**结构化配置**，用户可根据自己的需要进行勾选即可。 ![ipc video](./../assets/ipc video.jpg) 配置完成后回到预览页面即可进行人脸及人形识别，IPC 会自动框出识别人脸并且截取人脸的图片，可在预览页面下方点击截取图样放大查看附带信息。 左侧：人脸检测 右侧：人形检测 <html> <img src \"./../assets/ipc model.jpg\" width 45%> <img src \"./../assets/ipc person.jpg\" width 45%> </html> #### 车牌识别 使用前先进行**结构化配置**勾选车牌所需的检测画框即可。 .. details::点击查看 IPC 配置流程 接入页面后选择**配置**在**智能配置**里再进行**结构化配置**，用户可根据自己的需要进行勾选即可。 ![ipc video](./../assets/ipc video.jpg) 设置完成即可回到预览页面进行车牌识别，IPC 会自动框出识别到得车牌及读取车牌数字信息，用户在页面下方点击图片可查看截取到的车牌图片及信息。 ![ipc car](./../assets/ipc car.jpg) <! <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 773227207&bvid BV1B14y1Y7A4&cid 837154353&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\" style \"max width:640px; max height:480px;\"> </iframe> </p> > ### RTSP 推流 >**RTSP**：也称实时流传输协议，该协议定义了一对多应用程序如何有效地通过 IP 网络传送多媒体数据。 使用 RTSP 传送数据前，我们需要先认识工具 `VLC Media Player`。 **VLC Media Player**：[点击下载](https://www.videolan.org/vlc/) .. details::点此展开查看 VLC Media Player 介绍 VLC Media Player（VLC 多媒体播放器），是一款可播放大多数格式，而无需安装编解码器包的媒体播放器，以及支持多平台使用、支持 DVD 影音光盘，VCD 影音光盘及各类流式协议。 ![vl yolov5s](./../assets/vlc yolov5s.jpg) 运行下文命令后终端会弹出调试信息，打开 `VLC Media Player` 进行配置网络串流后即可看到画面效果。 ```bash /home/examples/vin_ivps_joint_venc_rtsp_vo_onvif_mp4v2/run.sh ``` .. details::点击查看终端运行图 ![vlr run](./../assets/vlc run.jpg) .. details::点此展开查看 VLC Media Player 配置步骤 打开后在上方选择**媒体**后选择**打开网络串流**进到配置画面。 ![vlc](./../assets/vlc.jpg) 在网络页面输入**网络 URL ：`rtsp://192.168.233.1:8554/axstream0`**， 勾选下方更多选项进行调整缓存后点击下方播放即可。 ![vlc urt](./../assets/vlc urt.jpg) 双屏tui效果如下示例： <html> <img src \"./../assets/rtsp display.jpg\" width 48%> <img src \"./../assets/rtsp axpi.jpg\" width 48%> </html> <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 731837313&bvid BV1XD4y1r7eP&cid 866903759&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> </p> >**注意**：默认摄像头为 gc4653 型号不同请移步[Maix III 系列 AXera Pi 常见问题(FAQ)](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html)更换参数。 #### ffplay RTSP 拉流工具除了 `VCL` 还可以直接使用 `ffplay`。 **ffplay** :[点击下载](https://dl.sipeed.com/shareURL/MaixIII/AXera/09_Software_tool) ```bash sudo apt install ffmpeg ffplay rtsp://192.168.233.1:8554/axstream0 fflags nobuffer ``` ### ONVIF ODM 拉流 >版本为 **20221111** 后的镜像系统内置了按键录像 mp4 和支持更换 yolov5s 人脸/物体检测模型以及对软件 ODM（ONVIF）进行支持。 在进行体验之前，我们先来认识即将使用的软件：`ONVIF Device Manager` **ONVIF Device Manager**：[点击下载](https://sourceforge.net/projects/onvifdm/) .. details::点击查看 ONVIF ODM 软件介绍 ONVIF 协议作为全球性的网络视频监控开放接口标准，推进了网络视频在安防市场的应用，特别是促进了高清网络摄像头的普及和运用。 越来越多的前端 IPC 厂家和后端 NVR 及存储提供商加入进来。而 ONVIF Device Manager 是 ONVIF 官方基于协议提供的免费第三方的 ONVIF 协议测试工具，与上文的 VLC 相比性能不同，但 ODM 的内容形式更加多样丰富。 ![odm](./../assets/odm.jpg) 运行下文命令，设备屏幕会跳出 yolov5s 模型运行画面，接着我们来配置 `ODM` 实现 PC 端显示。 ```bash /home/examples/vin_ivps_joint_venc_rtsp_vo_onvif_mp4v2/run.sh ``` .. details::点击设备运行效果图 ![odm mipi](./../assets/odm mipi.jpg) 打开下载好的 `ODM` 软件点击左侧白框的 `Refresh` 按键扫描设备，扫描成功会显示 `IP Camera` 方框点击后选择下方的 `Live video` 即可在 PC 端看到画面。 ![odm config](./../assets/odm config.jpg) 还可通过下方命令去查看文件配置： ```bash cd /home/examples/vin_ivps_joint_venc_rtsp_vo_onvif_mp4v2/ ls l ``` >**注意**：ODM 受网络影响较大，如果有卡顿现象把网络更换成以太网即可。 >默认摄像头为 gc4653 如型号不同请移步[Maix III 系列 AXera Pi 常见问题(FAQ)](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html)更换参数。 **更换模型** >**20221116** 后更新的镜像已在 `run.sh` 内置了不同摄像头参数的源码。 >**20221111** 镜像内置 yolov5s 的人脸/物体检测模型，可使用以下命令更改运行脚本内容更换模型。 ``` bash nano /home/examples/vin_ivps_joint_venc_rtsp_vo_onvif_mp4v2/run.sh ``` .. details::点击查看修改操作示例 运行后会显示 `run.sh` 的编辑页面，对当前启动的模型进行注释或调用其他模型即可， 按 **ctrl+X** 键后会提示是否保存修改内容。 ![model save](./../assets/model save.jpg) 根据提示按下 **Y** 键保存，界面会显示修改内容写入的文件名按**回车**键确定， 再次运行 `run.sh` 脚本即可看到模型更换成功。 ![model file](./../assets/model file.jpg) 除了直接在板端修改 `run.sh` 脚本，还可以通过 `MdbaXterm` 软件使用 ssh 登录查看 `/home/examples/vin_ivps_joint_venc_rtsp_vo_onvif_mp4v2/` 目录下的`run.sh` 直接进行修改保存。 **按键录制 MP4** 运行 `run.sh` 期间可按下板载的按键 `user` 进行录制视频，按下后 **LED0** 会亮起代表开始录制 MP4， .. details::点击查看按键示意图 ![odm mp4](./../assets/odm mp4.jpg) 终端界面会显示下图 `delete file`，再次按下按键板卡会停止录制而 LED0 会灭掉， ![odm adb](./../assets/odm adb.png) 录制完成的 MP4 文件可在 **`home/examples/`** 目录下查看。 ![mp4 file](./../assets/mp4 file.png) ### PP Humanseg 人体分割 >版本为 **20221116** 后的系统镜像内置了 `pp_human` 人体分割应用，并且内置了不同摄像头的参数命令在目录下的启动脚本 `run.sh` 里，用户使用只需要修改注释相应命令行即可使用。 运行下方的命令后终端会输出调试信息，设备屏幕会显示运行画面。 ```bash /home/examples/vin_ivps_joint_vo_pp_human_seg/run.sh ``` <! ![pp_human](./../assets/pp_human.jpg) > <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 902571856&bvid BV1iP4y1y75t&cid 889419118&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> </p> 使用下方命令进入图形化页面，对 `run.sh` 里不同摄像头参数的源码进行调用或注释。 ```bash nano /home/examples/vin_ivps_joint_vo_pp_human_seg/run.sh ``` .. details::点击查看图形化页面 修改后按 **ctrl+x** 退出键会提示是否保存页面，后续按终端提示操作即可。 ![pp_human_adb](./../assets/pp_humana_adb.png) ### UVC 虚拟 USB 摄像头 **usb uvc gadget**：[点击查看相关仓库](https://github.com/junhuanchen/usb uvc gadget) >版本为 **20221123** 的镜像系统内置了 uvc vo 应用，并且还可以在手机端软件使用。 >目前应用还处于不稳定的状态，第一次启动程序会改变 usb otg rndis 转成 usb otg uvc 模式导致设备重启，重启再运行即可，画面绿屏是启动脚本里摄像头配置不对。 使用前准备两条 USB type_c 的数据线以及一条双 type_c 口的数据线。 把设备的 **UART** 及 **OTG** 口用 `USB type c` 线全部接入 `PC` 端，再运行下方命令终端会弹出无报错调试信息。 ```bash /home/examples/vin_ivps_joint_venc_uvc_vo/run.sh ``` .. details::点击查看终端示例图 ![uvc_adb](./../assets/uvc_adb.png) 打开 `PC` 端自带相机应用即可在设备屏幕以及 `PC` 端观察到模型检测画面。 ![uvc_vo](./../assets/uvc_vo.jpg) 可以使用以下的命令行更换尾缀 `start` 开启、`stop` 停止、`restore` 重启来对 `uvc` 程序进行操作。 ```bash /home/usb uvc gadget/uvc gadget.sh #start/stop/restore ``` **手机端虚拟摄像头** UVC 也能在安卓手机端的 `app` 上当虚拟摄像头使用，使用前在软件商店下载好 **USB 摄像头专业版** 软件。 .. details::USB 摄像头专业版软件介绍 USB 摄像头是一款支持 USB 摄像头、适配采集卡等设备通过 OTG 连接手机并驱动设备展示画面。 ![uvc_usb](./../assets/uvc_usb.jpg) 把双头 `type c` 线的分别接上手机端以及设备的 OTG 口，运行上方命令后会自动连接。 ![uvc_phone](./../assets/uvc_phone.jpg) >**注意**：如果需要完全脱离电脑端用手机端供电的话，需要把 uvc 程序写入开机脚本即可。 ### Python API 编程 除了在板端上使用命令行去直接运行程序，还可以使用 Python 来编程直接运行调用 AI 模型和各种库。 **传送门**：[试试 Python 编程](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/python_api.html) <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 518756219&bvid BV1Ug411n7DC&cid 923425798&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> </p> ### 姿态关键点检测（人体/手势/动物） >镜像已内置了 `人体\\手势\\动物` 等模型及调用命令行在 `/home/run.sh` 目录下，用户可直接修改进行调用。 #### AX POSE PPL 人体姿态关键点 **终端使用命令行调用模型** 用户先修改内置在 `/home/run.sh` 的启动脚本，再运行 `run.sh` 脚本命令调用模型。 **如何修改 `run.sh` 脚本，以人体关键点 `ax_poes` 为例。** ![ax_poes_sh](./../assets/ax_poes_sh.jpg) 使用下文命令进入后找到自己需要调用的模型及命令，使用方向键移动取消注释更换 ` c 2` 不同摄像头参数，然后按 `ctrl+x` 键退出会提示保存，按提示操作即修改完成。 ```bash nano /home/run.sh ``` **修改后在终端输入 `/home/run.sh` 命令运行程序，即可体验人体关键点。** <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 647932316&bvid BV1Pe4y1W7n6&cid 901750338&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> </p> **前往[试试 Python 编程](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/python_api.html#%E4%BD%BF%E7%94%A8 Python %E8%B0%83%E7%94%A8 ax poes ppl %E6%A8%A1%E5%9E%8B)查看如何使用 `Python` 调用模型示例。** **如何调用运行 `run.sh` 里的更多预置模型。** 我们在 `run.sh` 里预置了调用多种模型的命令行以及相应的摄像头参数。 具体使用可参考上文 `nano /home/run.sh` 进入可视化编辑页面修改，运行启动脚本即可使用。 ```bash sample_vin_ivps_joint_vo sample_vin_ivps_joint_venc_rtsp_vo ``` ```bash yolov5_seg.json yolov7.json yolox.json yolov5s_face.json pp_human_seg.json ax_pose.json hrnet_animal_pose.json hand_pose.json ``` #### HandPose 手势姿态关键点 如上文的 `人体姿态关键点` 修改为示例，直接在 `run.sh` 脚本进行修改（图标注为需取消注释的命令）并运行 `run.sh` 即可体验模型，运行效果可看最下文的视频。 ![hand_run](./../assets/hand_run.jpg) #### HRNet_animal 动物姿态关键点 如上文的 `人体姿态关键点` 修改为示例，直接在 `run.sh` 脚本进行修改（图标注为需取消注释的命令）并运行 `run.sh` 即可体验模型，运行效果可看最下文的视频。 ![animal](./../assets/animal.jpg) <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 903331499&bvid BV1DP4y197hF&cid 909711786&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> </p> ### LVGL7 UI > 在 **20221125** 后更新的镜像系统里，我们内置了 lvgl7 UI 应用。 **运行应用前请先准备材料：**USB type c 线/USB type c 转换头/无线鼠标。 使用 USB type c 数据线两端分别接入设备的 **UART** 口与电脑端 **USB** 口，再使用转换头的 **USB** 端接入鼠标的 USB 接收器，另一端接入设备 **OTG** 口。 运行下方命令后终端会弹出无报错的启动信息后，屏幕会显示画面用户即可体验 lvgl 应用了。 ``` cd /home ./bin/sample_vin_ivps_joint_vo_lvgl c 0 ``` .. details::点击查看终端示例图 ![lvgi_adb](./../assets/lvgl_adb.png) <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 690497396&bvid BV1n24y1C7DN&cid 901748014&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> </p> **如何调用运行 `/home/bin` 目录下更多内置应用** 以下应用是内置在 `home/bin` 目录下的，用户可使用 `ls /home/bin` 查询并参考示例调用其余应用。 ```bash root@AXERA:~# ls /home/bin sample_h264_ivps_joint_vo sample_v4l2_user_ivps_joint_vo sample_vin_ivps_joint_vo sample_vin_joint sample_rtsp_ivps_joint sample_vin_ivps_joint_venc_rtsp sample_vin_ivps_joint_vo_h265 sample_rtsp_ivps_joint_rtsp_vo sample_vin_ivps_joint_venc_rtsp_vo sample_vin_ivps_joint_vo_lvgl ``` 例：调用 `sample_vin_ivps_joint_vo_h265` 运行命令如下方示例，` c 2` 为摄像头参数。 ```bash /home/bin/sample_vin_ivps_joint_vo_h265 c 2 ``` .. details::点击查看终端示例图 ![sample](./../assets/sample.jpg) ### sherpa ncnn 中英文语音识别 >版本为 `20230214` 后的镜像内置了 sherpa ncnn 中英文语音识别应用，`20230223` 模型进行了升级效果更加灵敏，用户可手动升级即可。如出现运行后无反应请先测试 [`AUDIO`](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#AUDIO) 基本的录音回放是否可用。 先运行命令先进入到 `/home/sherpa ncnn m3axpi` 的目录下，再运行中英文的启动命令体验语音识别应用。 ```bash cd /home/sherpa ncnn m3axpi ``` 中文语音识别 ```bash ./sherpa ncnn alsa \\ ./sherpa ncnn streaming zipformer zh 14M 2023 02 23/tokens.txt \\ ./sherpa ncnn streaming zipformer zh 14M 2023 02 23/encoder_jit_trace pnnx.ncnn.param \\ ./sherpa ncnn streaming zipformer zh 14M 2023 02 23/encoder_jit_trace pnnx.ncnn.bin \\ ./sherpa ncnn streaming zipformer zh 14M 2023 02 23/decoder_jit_trace pnnx.ncnn.param \\ ./sherpa ncnn streaming zipformer zh 14M 2023 02 23/decoder_jit_trace pnnx.ncnn.bin \\ ./sherpa ncnn streaming zipformer zh 14M 2023 02 23/joiner_jit_trace pnnx.ncnn.param \\ ./sherpa ncnn streaming zipformer zh 14M 2023 02 23/joiner_jit_trace pnnx.ncnn.bin \\ \"hw:0,0\" \\ 4 \\ greedy_search ``` 英文语音识别 ```bash ./sherpa ncnn alsa \\ ./sherpa ncnn conv emformer transducer small 2023 01 09/tokens.txt \\ ./sherpa ncnn conv emformer transducer small 2023 01 09/encoder_jit_trace pnnx.ncnn.int8.param \\ ./sherpa ncnn conv emformer transducer small 2023 01 09/encoder_jit_trace pnnx.ncnn.int8.bin \\ ./sherpa ncnn conv emformer transducer small 2023 01 09/decoder_jit_trace pnnx.ncnn.param \\ ./sherpa ncnn conv emformer transducer small 2023 01 09/decoder_jit_trace pnnx.ncnn.bin \\ ./sherpa ncnn conv emformer transducer small 2023 01 09/joiner_jit_trace pnnx.ncnn.int8.param \\ ./sherpa ncnn conv emformer transducer small 2023 01 09/joiner_jit_trace pnnx.ncnn.int8.bin \\ \"hw:0,0\" \\ 2 \\ greedy_search ``` 运行命令后可对着 AXera Pi 板卡**（麦克风靠近卡槽区域）**说话或播放声音，板卡会自动识别并把结果打印到终端，如下图使用中文运行效果示例。 ![sherpa](./../assets/sherpa.png) **如何升级语音识别模型** > 镜像版本日期为 `20230313` 的已内置好升级版的中文语音识别模型，用户不需要自行下载模型包更新。 使用 `git bash` 用下文命令行把更新的模型包下载到本地备用。 ```bash git lfs install git clone https://huggingface.co/marcoyang/sherpa ncnn streaming zipformer zh 14M 2023 02 23 ``` ![bash_sherpa](./../assets/bash_sherpa.png) 更新包拷贝完成后需放置到 AXera Pi 板卡上的 `/home/sherpa ncnn m3axpi` 相对应目录下，具体的文件传输方法可参考[【文件传输】](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E5%A6%82%E4%BD%95%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6)进行板卡与电脑互传。 ## 商业应用方案 ### SENSOR 支持双摄方案 > （20230412 暂时废弃，目前 GC4653 双摄在软件上调不出来，折衷方案可以用 USB 摄像头过度，只验证过 OS04A10 双摄） 目前 AXera Pi 板卡物理上理论支持 GC4653 实现双摄方案，而 OS04A10 在硬件上不支持使用双摄 2 * 4lane，软件上支持但硬件不支持，属于设计意外。 ![dual_gc4653](./../assets/dual_gc4653.jpg) 使用双摄方案需替换相关的设备树文件，此处设备树只是配置 I2C 设备与摄像头型号无关，详情资料可参考：[资料包。](https://dl.sipeed.com/shareURL/MaixIII/AXera/11_patch/dual_gc4653_patch) ```bash juwan@juwan n85 dls:~/Downloads/m3axpi_dual_gc4653_notes$ tree . . ├── 0001 support dual gc4653 camera.patch // 给软件 sample_vin 的示例补丁，用于说明如何在应用层添加双摄支持。 ├── dtb.img.lcd20221025.dual.gc4653 // 需要更新设备树，主要原因是第二个摄像头的 i2c 设备结点不对需要启用和修改，注 emmc 方案没有这个问题 ├── res.jpg // 用于给硬件接线排查 接线是否正常，正常的情况是怎样的，配合 sample_vin_ c_3 测试确认。 ├── run.png // 接线图 同上 └── sample_vin_ c_3 // 测试程序 同上 0 directories, 5 files ``` 基于此，就可以实现双摄支持了！ ### EMMC 量产相关方案 目前已经支持 M3AXPI EMMC 量产的相关方案实现。 **相关资料例程**：[[m3axpi]关于爱芯 ax620a 方案如何采用 EMMC 商业化量产成品这件事](https://www.cnblogs.com/juwan/p/17266132.html) ![emmc](./../assets/emmc.jpg)"},"/hardware/zh/maixIII/ax-pi/python_api.html":{"title":"Maix-III AXera-Pi 试试 Python 编程","content":"时间负责人更新内容: :: :: :2022.12.02lyx初次编写文档2022.12.15lyx增加内容2023.01.04lyx增加人脸/车牌识别、Yolov6等新模型2023.01.29lyx补充细节说明2023.02.23lyx增加YOLOV8、YOLOV8 SEG、ax_bvc_det（人车非检测）、crowdcount（人流量统计）等模型基于前文的[产品上手指南](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/flash_system.html)以及[系统使用手册](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html)后，本文章会介绍如何在MAIX IIIAXera Pi板卡上体验Python编程！##前言从MIAX IMCU、MAIX IIISOC、再到MAIX IIILinux系列，SIPEED一直在致力于让更多的人轻松快捷的把板卡使用起来，所以衍生了各种各样的上手指南文档，板卡也在增加着更多形式的编程体验，Linux基础差不熟悉？C++有难度？调用AI模型困难？没有关系，那就由这篇适合初学者的Python编程文档来帮助你快速把AXera Pi板卡用起来并调用AI模型应用。在进入到使用Python编程之前，我们需要先认识要使用的语言以及工具，一起往下看吧。在AXera Pi板卡内置了`Python3、JupyterNotebook、Pinpong、Pillow`等包让用户更便捷的进行使用Python编程，本篇文档以在`JupyterNotebook`网页上进行Python编程为示例阐述。###什么是Python**Python**是一种广泛使用的解释型、高级和通用的编程语言。它支持多种编程范型包括函数式、指令式、反射式、结构化和面向对象编程，还拥有动态类型系统和垃圾回收功能，能够自动管理内存使用，并且其本身拥有一个巨大而广泛的标准库。![api_python_logo 3.jpg](attachment:api_python_logo 3.jpg) **Python与C++相比有什么区别？**从上文得知Python是一种解释型语言，用户不需要编译以扩展名为`.py`的代码可直接传递给解释器生成输出。而C++是编译型语言，编译器需要把源代码生成目标代码再执行生成输出。对于初学者来说Python更易于学习并且语法简单、可读性更强。而C++在系统编程及性能上更优胜，但语法复杂编写起来对初学者有一定的挑战难度。 **Python基础及入门学习**在使用JupyterNotebook进行Python编程之前，同学们需要掌握一定的Python语言的基础才能接着往下走，可根据下列提供的传送门进行学习。[什么是Python?](https://wiki.sipeed.com/soft/maixpy3/zh/origin/python.html?highlight python)[国内Python基础教程](https://wiki.sipeed.com/soft/maixpy3/zh/origin/video.html)**以下的文章适合有一定Python基础想深入的同学们：**[大佬鼠の嵌入式Python入门教程[1]](https://wiki.sipeed.com/soft/maixpy3/zh/origin/hello_world.html)[大佬鼠の嵌入式Python入门教程[2]](https://wiki.sipeed.com/soft/maixpy3/zh/origin/loop_python.html)###什么是JupyterNotebook它是同时兼具Python3、Markdown及Terminal的环境并基于网页用于交互计算的应用程序。其可应用于开发、文档编写、运行代码和展示结果，以网页的形式打开并可直接编写及运行代码，运行结果也会直接显示在代码框下层。如在过程中需要编写说明文档，可在同页面中编写便于及时的解释和说明。![api_jupyter.jpg](attachment:api_jupyter.jpg)##启动网页>如果你浏览完上面的段落后到达这里，相信你已经掌握如何在AXera Pi进行烧录并登录系统以及基础的Linux操作了，并对我们即将用到的Python语言以及工具`JupyterNotebook`有了一定的认识，那就接着往下学习如何启动网页进行Python编程吧！> [产品上手指南](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/flash_system.html)> [系统使用手册](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html)使用前准备一台AXera Pi设备并把它接入电脑端通电，参考[系统使用手册](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95)登录到板卡的Linuxdebian11系统，登录后使用`ifconfig a`命令查看板卡的IP地址方便后续使用。查询完输入`jupyternotebook`命令启动它，终端会返回一系列服务器的信息。![api_adb.jpg](attachment:api_adb.jpg)上图可以看到终端返回服务器信息，打开任意浏览器输入板卡IP地址后缀加上`:8888`即可直接访问网页端**（但请注意：lo:127.0.0.1此IP是不可用于访问）**网页端会提醒输入密码`root`后访问。![api_root.png](attachment:api_root.png)>**注意**：使用JupyterNotebook时终端需保持连接状态，否则会与本地服务器的连接断开而无法操作。输入后会跳转到`Files`的页面，点击右侧的`New`可选择符合需求的编辑环境。![api_python3.jpg](attachment:api_python3.jpg)```bashPython3：默认的python3kernelTextFile：新建一个文本文件Folder：新建一个文件夹Terminal：在浏览器中新建一个用户终端，类似于shell/adb终端.```##基础用法这里介绍每个方框称为单元格，单元框左侧会有**蓝色（命令模式）**或**绿色（编辑模式）**两种颜色。**`蓝色单元格`(命令模式)**![green.jpg](attachment:green.jpg)**`绿色单元格`(编辑模式)**![blue.jpg](attachment:blue.jpg)通用用法： **Shift+Enter：**运行单元格，且以命令模式切换到下一个单元格 **Ctrl+Enter：**运行单元格，且进入命令模式编辑模式中： **Esc**：进入命令模式命令模式中： **h：**打开帮助 **Enter：**进入编辑模式 **x：**剪切单元格 **c：**复制单元格 **v：**粘贴单元格 **dd：**删除整个单元格 **ii：**终止运行 **a：**向光标所在单元格上方添加单元格 **b：**向下添加 **m：**使得单元格变成markdown状态##运行代码>本篇文章所有的示例代码都是摄像头GC4653为例，如有OS04A10型号请前往[Maix III系列AXera Pi常见问题（FAQ）](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html)修改。用户选择`Python3`环境即可进入编辑页面，在网页上运行Python代码有以下三种示例供大家参考，代码运行后编辑框下会打印输出结果参数，用户则可以从板卡设备屏幕观察到运行实时效果。 **使用`!+cmd`运行内置的脚本或命令行，或是直接在框内编辑`Python`代码并点击运行，这里以运行`NPU`应用为例。**!lshome/imagesair.jpg carvana02.jpg\t face5.jpg\t o2_resize.jpg ssd_car.jpg\r aoa 2.jpeg carvana03.jpg\t grace_hopper.jpg pineapple.jpg ssd_dog.jpg\r aoa.jpeg carvana04.jpg\t mobileface01.jpg pose 1.jpeg\t ssd_horse.jpg\r bike.jpg cat.jpg\t\t mobileface02.jpg pose 2.jpeg\r bike2.jpg cityscape.png\t mtcnn_face4.jpg pose 3.jpeg\r cable.jpg dog.jpg\t\t mtcnn_face6.jpg pose.jpg\r carvana01.jpg efficientdet.png mv2seg.png\t selfie.jpg!/home/ax samples/build/install/bin/ax_yolov5s m/home/models/yolov5s.joint i/home/images/cat.jpg r10 model file : /home/models/yolov5s.joint image file : /home/images/cat.jpg img_h, img_w : 640 640 [AX_SYS_LOG] AX_SYS_Log2ConsoleThread_Start Run Joint Runtime version: 0.5.10 [INFO]: Virtual npu mode is 1_1 Tools version: d696ee2f run over: output len 3 Create handle took 487.99 ms (neu 22.29 ms, axe 0.00 ms, overhead 465.70 ms) Repeat 10 times, avg time 22.57 ms, max_time 22.88 ms, min_time 22.46 ms detection num: 1 15: 89%, [ 167, 28, 356, 353], cat [AX_SYS_LOG] Waiting thread(2867848448) to exit [AX_SYS_LOG] AX_Log2ConsoleRoutine terminated!!! exit[AX_SYS_LOG] join thread(2867848448) ret:0fromIPython.displayimportImageImage(\"yolov5s_out.jpg\") **也可以使用`%run`跑模块文件或`.py`文件，这里以运行`hello.py`为例。**%runhello.pyhello world！##启动终端>上文演示了如何实现Python编程，而**JupyterNotebook**还能开启终端并与`Python3`同时运行。回到`homepage`后点击右侧的`New`后选择`Terminal`新建终端进行操作。用户可以在`Files`页面直接查看内置目录的文件夹，或者是使用终端用`ls`查看目录，用`cd`进入目录。![api_wed%20.jpg](attachment:api_wed%20.jpg)##编写文档>用户可在**JupyterNotebook**里使用`Markdowm`语法编写文档提升代码的易读性以及条理性。点击编辑框把模式从代码更换成`Markdown`，在命令模式下可使用`M`键变成`Markdown`状态。![api_markdown 2.jpg](attachment:api_markdown 2.jpg)##传输文件>除了运行代码以及编写文档等还可以进行文件的传输，让用户使用更加便捷。 **如何导入电脑端的文件，以下面两种方式为例：**点击主页右侧`New`新建`TextFile：文本文件`或`Folder：文件夹或文件`，手动复制粘贴内容导入文件。![api_python3.png](attachment:api_python3.png)或者是直接从网页端导入文件，点击右侧的`Upload`直接在任意目录下导入需要的文件即可。![api_upload.jpg](attachment:api_upload.jpg) **如何导出我们在网页端编写的文件，以下面为例：**在网页端编写的的内容都可以以文档的形似输出，默认保存的是以后缀名为`.ipynb`的`json`格式，保存不同格式请点击`File` \\>`Downloadas` \\>`选择你需要的格式即可`，网页会自动下载到本地。![api_file 2.jpg](attachment:api_file 2.jpg)##ax pipeline api>基于`20230214`后更新的镜像包，`ax pipeline api`版本升级到1.0.9支持Python获取摄像头图像及推理结果一起显示到屏幕上或保存。[**ax pipeline api：**](https://github.com/junhuanchen/ax pipeline api)此项目基于[ax pipeline](https://github.com/AXERA TECH/ax pipeline)实现了`pybind11`和`ctypes`的PythonAPI，用户可使用Python调用内置的多种AI模型以及通用的Python库pinpong、opencv、numpy、pillow等，让AXera Pi用起来更简单！ **`ctypes`和`pybind11`两者区别？**`ctypes`是最早适配的，相较于新的`pybind11`来说支持的接口更多稳定性更好，而新的`pybind11`则是输出效果更直观（可显示到屏幕/网页上）代码更任意理解，但两者因板卡外设有限不可混用。 **使用前先安装获取`ax pipeline api`包**因`ax pipeline api`更新升级较频繁，用户在使用Python编程前可先在终端使用下方命令行更新包，确保自己使用是最新版本的即可。!pip3installax pipeline api URequirement already satisfied: ax pipeline api in /usr/local/lib/python3.9/dist packages (1.0.7) Collecting ax pipeline api Using cached ax pipeline api 1.0.7.tar.gz (15.5 MB) Using cached ax pipeline api 1.0.6.tar.gz (19.5 MB)>如果出现更新失败，可替换清华源` ihttps://pypi.tuna.tsinghua.edu.cn/simple`加速一下。##Yolov5/Yolov8目标检测（ctypes）把`ax pipeline api`包升级好后，接下来我们先体验更稳定的**ctypes**的`Yolov5/8`模型实现目标检测！importtimefromaximportpipelinepipeline.load(['libsample_vin_ivps_joint_vo_sipy.so',' p','/home/config/yolov5s.json',' c','2',])whilepipeline.work():time.sleep(0.001)tmp pipeline.result()iftmpandtmp['nObjSize']:foriintmp['mObjects']:x,y,w,h i['bbox']['x'],i['bbox']['y'],i['bbox']['w'],i['bbox']['h']objname,objprob i['objname'],i['prob']print(objname,objprob,x,y,w,h)#iftmp['nObjSize']>10:#tryexit#pipeline.drop()b'bottle' 0.5032062530517578 0.11116950958967209 0.40303218364715576 0.21706661581993103 0.5804097652435303 b'bottle' 0.7368168830871582 0.11036165803670883 0.4033470153808594 0.2250344455242157 0.5822746157646179 b'bottle' 0.7751374244689941 0.11194521933794022 0.3943900167942047 0.21920150518417358 0.5996366739273071 b'bottle' 0.7996727228164673 0.1136007010936737 0.4050813317298889 0.21979697048664093 0.579041600227356 b'bottle' 0.7779128551483154 0.11486124992370605 0.4005553424358368 0.21681155264377594 0.5885791778564453 b'bottle' 0.7506007552146912 0.11348568648099899 0.4008048176765442 0.2208258956670761 0.5853195190429688 b'bottle' 0.7448824644088745 0.11283267289400101 0.40612301230430603 0.22086872160434723 0.5755194425582886importtimefromaximportpipelinepipeline.load(['libsample_vin_ivps_joint_vo_sipy.so',' p','/home/config/yolov8.json',' c','2',])whilepipeline.work():time.sleep(0.001)tmp pipeline.result()iftmpandtmp['nObjSize']:foriintmp['mObjects']:x,y,w,h i['bbox']['x'],i['bbox']['y'],i['bbox']['w'],i['bbox']['h']objname,objprob i['objname'],i['prob']print(objname,objprob,x,y,w,h)#iftmp['nObjSize']>10:#tryexit#pipeline.drop()b'toilet' 0.4541160762310028 0.602770209312439 0.9111631512641907 0.16810722649097443 0.08513855934143066 b'toilet' 0.6902503967285156 0.606963574886322 0.9117961525917053 0.16024480760097504 0.08727789670228958 b'toilet' 0.6852353811264038 0.6020327210426331 0.9118891358375549 0.16942621767520905 0.08718493580818176 b'toilet' 0.7014157176017761 0.6041151881217957 0.9120386242866516 0.16582755744457245 0.0863698348402977 b'cup' 0.46080872416496277 0.6049922108650208 0.9143685698509216 0.1643451750278473 0.08425315469503403从上面跑的yolov8模型示例来看，运行时编辑框下会输出检测结果的相关参数，而实际画面可在板卡屏幕查看。我们也可以从上面的代码中替换不同功能的`.so`库或不同效果的`AI`模型来实现更多的AI应用。>更换`.so`库以及`AI`模型请参考以下示例进行修改，这篇文档只挑选部分经典模型作为示例，大家可以举一反三进行更换功能库以及模型，更多详细信息前往[ax pipeline api](https://github.com/junhuanchen/ax pipeline api)查看。全文示例使用`GC4653`摄像头不同型号请前往[Maix III系列AXera Pi常见问题（FAQ）](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html)修改。 以下是内置的libxxx*.so库总览：**可通过替换不同的`libxxx*.so`来体验不同的功能。**```bashlibsample_h264_ivps_joint_vo_sipy.so#inputh264videotoivpsjointoutputscreenvolibsample_v4l2_user_ivps_joint_vo_sipy.so#inputv4l2/dev/videoXtoivpsjointoutputscreenvolibsample_rtsp_ivps_joint_rtsp_vo_sipy.so#inputvideofromrtsptoivpsjointoutputrtspandscreenvolibsample_vin_ivps_joint_vo_sipy.so#inputmipisensortoivpsjointoutputscreenvolibsample_vin_ivps_joint_venc_rtsp_sipy.so#inputmipisensortoivpsjointoutputrtsplibsample_vin_ivps_joint_venc_rtsp_vo_sipy.so#inputmipisensortoivpsjointoutputrtspandscreenvolibsample_vin_ivps_joint_vo_h265_sipy.so#inputmipisensortoivpsjointoutputscreenvoandsaveh265videofilelibsample_multi_rtsp_ivps_joint_multi_rtsp_sipy.so#inputmultirtspvideotoivpsjointoutputmultirtspvideolibsample_rtsp_ivps_joint_rtsp_sipy.so#inputvideofromrtsptoivpsjointoutputrtsplibsample_rtsp_ivps_joint_rtsp_vo_sipy.so#inputvideofromrtsptoivpsjointoutputrtspandscreenvolibsample_rtsp_ivps_joint_vo_sipy.so#inputvideofromrtsptoivpsjointoutputscreenvo```**更换`libxxx*.so`可参考以下示例：**```bashpipeline.load(['libsample_vin_ivps_joint_venc_rtsp_vo_sipy.so',' p','/home/config/yolov5s.json',' c','2',])``` 以下是内置的多种AI模型总览：**AI模型被内置在`/home/config`的目录下，可通过更换模型来实现不同的AI应用。**```bashax_bvc_det.jsonhrnet_pose_yolov8.jsonyolov5s_face_recognition.jsonax_person_det.jsonlicense_plate_recognition.jsonyolov5s_license_plate.jsonax_pose.jsonnanodet.jsonyolov6.jsonax_pose_yolov5s.jsonpalm_hand_detection.jsonyolov7.jsonax_pose_yolov8.jsonpp_human_seg.jsonyolov7_face.jsoncrowdcount.jsonscrfd.jsonyolov7_palm_hand.jsonhand_pose.jsonyolo_fastbody.jsonyolov8.jsonhand_pose_yolov7_palm.jsonyolopv2.jsonyolov8_seg.jsonhrnet_animal_pose.jsonyolov5_seg.jsonyolox.jsonhrnet_pose.jsonyolov5s.jsonhrnet_pose_ax_det.jsonyolov5s_face.json```**更换AI模型可参考以下示例：**```bashpipeline.load(['libsample_vin_ivps_joint_vo_sipy.so',' p','/home/config/yolov5s_face.json',' c','2',])```##Yolov8 seg实例分割importtimefromaximportpipelinepipeline.load(['libsample_vin_ivps_joint_vo_sipy.so',' p','/home/config/yolov8_seg.json',' c','2',])whilepipeline.work():time.sleep(0.001)tmp pipeline.result()iftmpandtmp['nObjSize']:foriintmp['mObjects']:print(i)#iftmp['nObjSize']>10:#tryexit#pipeline.drop(){'label': 39, 'prob': 0.41857901215553284, 'objname': b'bottle', 'bbox': {'x': 0.02848125249147415, 'y': 0.03796946257352829, 'w': 0.03146517649292946, 'h': 0.15615946054458618}, 'bHasMask': 1, 'mYolov5Mask': {'w': 6, 'h': 15, 'data': b'\\x00\\x00\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00'}} {'label': 39, 'prob': 0.4042961299419403, 'objname': b'bottle', 'bbox': {'x': 0.027379659935832024, 'y': 0.037133704870939255, 'w': 0.033295709639787674, 'h': 0.15926814079284668}, 'bHasMask': 1, 'mYolov5Mask': {'w': 6, 'h': 15, 'data': b'\\x00\\x00\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00'}} {'label': 39, 'prob': 0.4118087887763977, 'objname': b'bottle', 'bbox': {'x': 0.028065890073776245, 'y': 0.03647643327713013, 'w': 0.0326821468770504, 'h': 0.15858806669712067}, 'bHasMask': 1, 'mYolov5Mask': {'w': 6, 'h': 15, 'data': b'\\x00\\x00\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00'}}##读取USB摄像头进行检测使用前先准备`USB摄像头`以及`USBtype c转接头`备用，把`USB摄像头`接入`USBtype c转接头`，再把转接头的type c端接入板卡设备的`OTG`口。接线完毕后运行下文代码即可支持USB摄像头输入进行检测，运行效果会输出到设备屏幕。importtimefromaximportpipelinepipeline.load(['libsample_v4l2_user_ivps_joint_vo_sipy.so',' p','/home/config/yolov8.json'])whilepipeline.work():time.sleep(0.001)tmp pipeline.result()##ax_bvc_det人车非机动车检测importtimefromaximportpipelinepipeline.load(['libsample_vin_ivps_joint_vo_sipy.so',' p','/home/config/ax_bvc_det.json',' c','2',])whilepipeline.work():time.sleep(0.001)tmp pipeline.result()iftmpandtmp['nObjSize']:foriintmp['mObjects']:x,y,w,h i['bbox']['x'],i['bbox']['y'],i['bbox']['w'],i['bbox']['h']objname,objprob i['objname'],i['prob']print(objname,objprob,x,y,w,h)#iftmp['nObjSize']>10:#tryexit#pipeline.drop()b'vehicle' 0.9299032092094421 0.3565574288368225 0.44399410486221313 0.23071418702602386 0.2580929398536682 b'vehicle' 0.9225113391876221 0.357175350189209 0.44230249524116516 0.23054184019565582 0.2606807053089142 b'vehicle' 0.9186123609542847 0.3581112325191498 0.44336238503456116 0.22992925345897675 0.26163965463638306 b'vehicle' 0.5208129286766052 0.3618425130844116 0.4461480975151062 0.23065532743930817 0.2652992308139801 b'vehicle' 0.7194858193397522 0.3608142137527466 0.45302334427833557 0.23270295560359955 0.2703518867492676 b'vehicle' 0.8540934324264526 0.3617907166481018 0.4548843204975128 0.23152287304401398 0.27814221382141113 b'vehicle' 0.8912967443466187 0.3607788681983948 0.4583750367164612 0.2328854203224182 0.27056747674942017 b'vehicle' 0.8969211578369141 0.3522576689720154 0.45107507705688477 0.22706037759780884 0.26078158617019653 b'vehicle' 0.7356315851211548 0.31006965041160583 0.45962005853652954 0.23436705768108368 0.26961490511894226##crowdcount人流量检测importtimefromaximportpipelinepipeline.load(['libsample_vin_ivps_joint_vo_sipy.so',' p','',' c','2',])whilepipeline.work():time.sleep(0.001)tmp pipeline.result()iftmpandtmp['nObjSize']:foriintmp['mObjects']:print(i)#iftmp['nObjSize']>10:#tryexit#pipeline.drop()##姿态关键点系列（人体/手/动物）姿态关键点系列包含人体姿态、手势姿态以及动物姿态的检测，出于方便大家的使用都罗列出来了。###ax pose ppl人体姿态检测关键点对应的人体部位如下：0：鼻子、1：左眼、2：右眼、3：左耳、4：右耳、5：左肩、6：右肩、7：左肘、8：右肘、9:左腕、10：右腕、11：左胯、12：右胯、13：左膝、14:右膝、15：左踝、16：右踝importtimefromaximportpipelinepipeline.load(['libsample_vin_ivps_joint_vo_sipy.so',' p','/home/config/ax_pose.json',' c','2',])whilepipeline.work():time.sleep(0.001)tmp pipeline.result()iftmpandtmp['nObjSize']:foriintmp['mObjects']:print(i)#iftmp['nObjSize']>10:#tryexit#pipeline.drop(){'label': 0, 'prob': 0.41659796237945557, 'objname': b'person', 'bbox': {'x': 0.01200273260474205, 'y': 0.0, 'w': 0.9315435290336609, 'h': 0.9421796798706055}, 'bHasBoxVertices': 0, 'bHasLandmark': 17, 'landmark': [{'x': 0.6708333492279053, 'y': 0.23333333432674408}, {'x': 0.6427083611488342, 'y': 0.16851851344108582}, {'x': 0.6520833373069763, 'y': 0.14629629254341125}, {'x': 0.7322916388511658, 'y': 0.5055555701255798}, {'x': 0.7614583373069763, 'y': 0.06481481343507767}, {'x': 0.7541666626930237, 'y': 0.09444444626569748}, {'x': 0.7541666626930237, 'y': 0.1518518477678299}, {'x': 0.7124999761581421, 'y': 0.15925925970077515}, {'x': 0.5041666626930237, 'y': 0.08703703433275223}, {'x': 0.6739583611488342, 'y': 0.07407407462596893}, {'x': 0.690625011920929, 'y': 0.6814814805984497}, {'x': 0.7833333611488342, 'y': 0.25}, {'x': 0.7614583373069763, 'y': 0.25}, {'x': 0.35104167461395264, 'y': 0.6074073910713196}, {'x': 0.3489583432674408, 'y': 0.5777778029441833}, {'x': 0.0572916679084301, 'y': 0.5185185074806213}, {'x': 0.0677083358168602, 'y': 0.5185185074806213}]}###HandPose手势姿态检测importtimefromaximportpipelinepipeline.load(['libsample_vin_ivps_joint_vo_sipy.so',' p','/home/config/hand_pose.json',' c','2',])whilepipeline.work():time.sleep(0.001)tmp pipeline.result()iftmpandtmp['nObjSize']:foriintmp['mObjects']:x,y,w,h i['bbox']['x'],i['bbox']['y'],i['bbox']['w'],i['bbox']['h']objname,objprob i['objname'],i['prob']print(objname,objprob,x,y,w,h)#iftmp['nObjSize']>10:#tryexit#pipeline.drop(){'label': 0, 'prob': 0.948456346988678, 'objname': b'hand', 'bbox': {'x': 0.26589435338974, 'y': 0.26926565170288086, 'w': 0.46994149684906006, 'h': 0.4706382751464844}, 'bHasBoxVertices': 1, 'bbox_vertices': [{'x': 1.4048067331314087, 'y': 0.42393070459365845}, {'x': 1.2827746868133545, 'y': 1.74061918258667}, {'x': 0.06521528959274292, 'y': 1.5236728191375732}, {'x': 0.18724757432937622, 'y': 0.6408770084381104}], 'bHasLandmark': 21, 'landmark': [{'x': 0.3895833194255829, 'y': 0.6722221970558167}, {'x': 0.4635416567325592, 'y': 0.5925925970077515}, {'x': 0.5979166626930237, 'y': 0.4888888895511627}, {'x': 0.6979166865348816, 'y': 0.4148148000240326}, {'x': 0.7562500238418579, 'y': 0.442592591047287}, {'x': 0.7541666626930237, 'y': 0.5388888716697693}, {'x': 0.8166666626930237, 'y': 0.4314814805984497}, {'x': 0.7927083373069763, 'y': 0.3314814865589142}, {'x': 0.768750011920929, 'y': 0.25925925374031067}, {'x': 0.746874988079071, 'y': 0.5981481671333313}, {'x': 0.778124988079071, 'y': 0.43703705072402954}, {'x': 0.7260416746139526, 'y': 0.3203703761100769}, {'x': 0.706250011920929, 'y': 0.27222222089767456}, {'x': 0.703125, 'y': 0.6499999761581421}, {'x': 0.7291666865348816, 'y': 0.4611110985279083}, {'x': 0.6666666865348816, 'y': 0.3722222149372101}, {'x': 0.628125011920929, 'y': 0.3351851999759674}, {'x': 0.6416666507720947, 'y': 0.6981481313705444}, {'x': 0.6864583492279053, 'y': 0.5814814567565918}, {'x': 0.6625000238418579, 'y': 0.5092592835426331}, {'x': 0.6447916626930237, 'y': 0.4592592716217041}]}###animal pose动物姿态检测importtimefromaximportpipelinepipeline.load(['libsample_vin_ivps_joint_vo_sipy.so',' p','/home/config/hrnet_animal_pose.json',' c','2',])whilepipeline.work():time.sleep(0.001)tmp pipeline.result()iftmpandtmp['nObjSize']:foriintmp['mObjects']:x,y,w,h i['bbox']['x'],i['bbox']['y'],i['bbox']['w'],i['bbox']['h']objname,objprob i['objname'],i['prob']print(objname,objprob,x,y,w,h)#iftmp['nObjSize']>10:#tryexit#pipeline.drop()b'cat' 0.4067786633968353 0.5895833373069763 0.0833333358168602 0.25 0.5703703761100769 b'cat' 0.47085827589035034 0.5666666626930237 0.09444444626569748 0.2708333432674408 0.5740740895271301 b'cat' 0.5028171539306641 0.5239583253860474 0.09814814478158951 0.32083332538604736 0.5888888835906982 b'cat' 0.4983457326889038 0.5302083492279053 0.1111111119389534 0.31041666865348816 0.5777778029441833 b'dog' 0.807929515838623 0.0833333358168602 0.1259259283542633 0.26875001192092896 0.5370370149612427 b'dog' 0.6479188799858093 0.15729166567325592 0.8425925970077515 0.12291666865348816 0.1518518477678299##PillowYolov5s目标检测importtimefromaximportpipelinefromPILimportImage,ImageDraw#readysipeedlogocanvaslcd_width,lcd_height 854,480img Image.new('RGBA',(lcd_width,lcd_height),(255,0,0,200))ui ImageDraw.ImageDraw(img)ui.rectangle((20,20,lcd_width 20,lcd_height 20),fill (0,0,0,0),outline (0,0,255,100),width 20)logo Image.open(\"/home/res/logo.png\")img.paste(logo,box (lcd_width logo.size[0],lcd_height logo.size[1]),mask None)defrgba2argb(rgba):r,g,b,a rgba.split()returnImage.merge(\"RGBA\",(a,b,g,r))canvas_argb rgba2argb(img)pipeline.load(['libsample_vin_ivps_joint_vo_sipy.so',' p','/home/config/yolov5s.json',#' p','/home/config/yolov8.json',' c','2',])whilepipeline.work():time.sleep(0.001)argb canvas_argb.copy()tmp pipeline.result()iftmpandtmp['nObjSize']:ui ImageDraw.ImageDraw(argb)foriintmp['mObjects']:x i['bbox']['x']*lcd_widthy i['bbox']['y']*lcd_heightw i['bbox']['w']*lcd_widthh i['bbox']['h']*lcd_heightobjlabel i['label']objprob i['prob']ui.rectangle((x,y,x+w,y+h),fill (100,0,0,255),outline (255,0,0,255))ui.text((x,y),str(objlabel))ui.text((x,y+20),str(objprob))pipeline.config(\"display\",(lcd_width,lcd_height,\"ARGB\",argb.tobytes()))print_data 2 False##PillowYolov8目标检测（pybind11）体验完`ctypes`来试试新的API`pybind11`跑Yolov8目标检测吧！新的`pybind11`支持把获取摄像头图像以及推理结果一起显示到屏幕（网页）或者是保存下来，但目前还处于不稳定状态，使用时出现不稳定闪烁或者是报错请重启内核即可。importm3axpi#m3axpi.camera(SysCase 0)#switchos04a10#m3axpi.camera(SysCase 2)#defaultgc4653m3axpi.load(\"/home/config/yolov8.json\")fromPILimportImage,ImageDraw,ImageFontlcd_width,lcd_height,lcd_channel 854,480,4fnt ImageFont.truetype(\"/home/res/sans.ttf\",20)img Image.new('RGBA',(lcd_width,lcd_height),(255,0,0,200))ui ImageDraw.ImageDraw(img)ui.rectangle((20,20,lcd_width 20,lcd_height 20),fill (0,0,0,0),outline (0,0,255,100),width 20)logo Image.open(\"/home/res/logo.png\")img.paste(logo,box (lcd_width logo.size[0],lcd_height logo.size[1]),mask None)whileTrue:rgba img.copy()tmp m3axpi.capture()rgb Image.frombuffer(\"RGB\",(tmp[1],tmp[0]),tmp[3])rgba.paste(rgb,box (0,0),mask None)##camera320x180paste854x480res m3axpi.forward()if'nObjSize'inres:ui ImageDraw.ImageDraw(rgba)ui.text((0,0),\"fps:%02d\"%(res['niFps']),font fnt)forobjinres['mObjects']:x,y,w,h int(obj['bbox'][0]*lcd_width),int(obj['bbox'][1]*lcd_height),int(obj['bbox'][2]*lcd_width),int(obj['bbox'][3]*lcd_height)ui.rectangle((x,y,x+w,y+h),fill (255,0,0,100),outline (255,0,0,255))ui.text((x,y),\"%s:%02d\"%(obj['objname'],obj['prob']*100),font fnt)rgba.paste(logo,box (x+w logo.size[1],y+h logo.size[1]),mask None)m3axpi.display([lcd_height,lcd_width,lcd_channel,rgba.tobytes()])#display(rgba)#显示到网页##调用Pillow进行图像处理并显示>**Pillow（PIL）**是Python常用的图像处理库，而Pillow是PIL支，提供了广泛的文件格式支持，强大的图像处理能力，主要包括图像储存、图像显示、格式转换以及基本的图像处理操作等。**使用以下的例子来说明如何使用PythonPillow:**!lshome/imagesair.jpg carvana02.jpg\t face5.jpg\t mv2seg.png\t selfie.jpg\r aoa 2.jpeg carvana03.jpg\t faces\t\t o2_resize.jpg ssd_car.jpg\r aoa.jpeg carvana04.jpg\t grace_hopper.jpg pineapple.jpg ssd_dog.jpg\r bike.jpg cat.jpg\t\t mobileface01.jpg pose 1.jpeg\t ssd_horse.jpg\r bike2.jpg cityscape.png\t mobileface02.jpg pose 2.jpeg\r cable.jpg dog.jpg\t\t mtcnn_face4.jpg pose 3.jpeg\r carvana01.jpg efficientdet.png mtcnn_face6.jpg pose.jpgfromPILimportImage,ImageDrawpil_im Image.open('home/images/bike2.jpg','r')draw ImageDraw.Draw(pil_im)draw.arc((0,0,400,400),start 0,end 300,fill 'red',width 3)draw.rectangle((20,20,200,100),fill (100,20,60),outline \"#FF0000\",width 3)pil_im.show()#display(pil_im) **关于Pillow更多的使用资料请[点击](https://www.itcodar.com/python/how to show pil image in ipython notebook.html)查看。**##调用Numpy进行数组计算>**NumPy**（NumericalPython）是Python语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也是针对数组运算提供大量的数学函数库。**使用以下的例子来说明如何调用Numpy：**importnumpyasnp#int8,int16,int32,int64四种数据类型可以使用字符串'i1','i2','i4','i8'代替dt np.dtype('i4')print(dt)int32 **关于Numpy的更多资料例程请[点击](https://www.runoob.com/numpy/numpy tutorial.html)查看。**##播放音视频 [如何使用Python播放音视频](https://wiki.sipeed.com/soft/maixpy3/zh/usage/Audio/play_mp4.html)##发起Http请求或MQTT通信 [如何发起Http请求或MQTT通信](https://wiki.sipeed.com/soft/maixpy3/zh/usage/net.html)##使用PinPong库控制Microbit>PinPong库是一套控制开源硬件主控板的Python库，基于Firmata协议并兼容MicroPython语法。**使用前请先准备材料并按步骤接线，使用Microusb数据线连接Microbit，然后把另一端接入转接头的USB口，再把转接头的Type c口接入设备的OTG口，使用Type c数据线连接设备的UART口及PC端通电。** 一个Type cUSB转接头 一台Microbit以及Microusb数据线 一台AXera Pi设备以及Type c数据线可直接在`Python3`环境运行下方代码即可连接microbit掌控版并会看到`helloworld`亮灯效果。importtimefrompinpong.boardimportBoard,Pinfrompinpong.extension.microbitimport*Board(\"microbit\",\"/dev/ttyACM0\").begin()display.show(Image.HEART)whileTrue:display.scroll(\"helloworld\")__________________________________________ ____ _ ____ / __ \\(_)___ / __ \\____ ____ ____ _ / /_/ / / __ \\/ /_/ / __ \\/ __ \\/ __ `/ / ____/ / / / / ____/ /_/ / / / / /_/ / /_/ /_/_/ /_/_/ \\____/_/ /_/\\__, / v0.4.9 Designed by DFRobot /____/ __________________________________________ [01] Python3.9.2 Linux 4.19.125 armv7l with glibc2.31 Board: MICROBIT selected > board: MICROBIT serial: /dev/ttyACM0 [10] Opening /dev/ttyACM0 [32] Firmata ID: 2.7 [22] Arduino compatible device found and connected to /dev/ttyACM0 [40] Retrieving analog map... [42] Auto discovery complete. Found 26 Digital Pins and 6 Analog Pins All right. PinPong go... **点击[Microbit传送门](https://pinpong.readthedocs.io/zh_CN/latest/2.pinpong%E7%A4%BA%E4%BE%8B/index1.html)查看更多的相关例程资料。**##使用PinPong库控制ArduinoUNO**使用前请先准备材料按步骤接线，先用Type B数据线连接ArduinoUNO，接着把另一端接入转接头的USB口，再把转接头的Type c口接入设备板载的OTG口，使用Type c数据线连接设备板载的UART口及电脑端进行上电操作。** 一个Type cUSB转接头 一台ArduinoUNO以及Type b数据线 一台AXera Pi设备以及Type c数据线直接在编辑框运行以下代码控制ArduinoUNO板点亮外接的**LED**灯以及板载也会亮起。importtimefrompinpong.boardimportBoard,PinBoard(\"uno\",\"/dev/ttyUSB0\").begin()led Pin(Pin.D13,Pin.OUT)#引脚初始化为电平输出whileTrue:led.value(1)#输出高电平print(\"1\")#终端打印信息time.sleep(1)#等待1秒保持状态led.value(0)#输出低电平print(\"0\")#终端打印信息time.sleep(1)#等待1秒保持状态__________________________________________ ____ _ ____ / __ \\(_)___ / __ \\____ ____ ____ _ / /_/ / / __ \\/ /_/ / __ \\/ __ \\/ __ `/ / ____/ / / / / ____/ /_/ / / / / /_/ / /_/ /_/_/ /_/_/ \\____/_/ /_/\\__, / v0.4.9 Designed by DFRobot /____/ __________________________________________ [01] Python3.9.2 Linux 4.19.125 armv7l with glibc2.31 Board: UNO selected > board: UNO serial: /dev/ttyUSB0 [10] Opening /dev/ttyUSB0 [32] Firmata ID: 2.7 [22] Arduino compatible device found and connected to /dev/ttyUSB0 [40] Retrieving analog map... [42] Auto discovery complete. Found 20 Digital Pins and 6 Analog Pins All right. PinPong go... 1 0 1 0 1 user quit process![uno 3.jpg](attachment:uno 3.jpg) **点击[ArduinoUNO传送门](https://pinpong.readthedocs.io/zh_CN/latest/2.pinpong%E7%A4%BA%E4%BE%8B/index1.html)查看更多的相关例程资料。**"},"/hardware/zh/maixIII/ax-pi/axpi.html":{"title":"MAIX-III AXera-Pi 是什么？","content":" title: MAIX III AXera Pi 是什么？ keywords: MAIX III, AXera Pi, Maix3, Sipeed, ax620a, axera, sipeed, AI, model, maixhub > 如果你想分享这款 AI 开发板给其他同学了解，请使用唯一的传送门「[ wiki.sipeed.com/m3axpi ](http://wiki.sipeed.com/m3axpi) 」。 ![maixiii_axpi](./../../../../../static/home/maixiii_axpi.jpg) > [>>> 想要购买请点此直达淘宝商品链接 <<<](https://item.taobao.com/item.htm?id 682169792430) 2021 年的时候，国内各大芯片原厂纷纷亮出了自己的 Linux 边缘 AI 芯片。 但在 AI 开发板的市场中，前有树莓派（Raspberry Pi），后有英伟达（Jetson Nano）等国外老牌选手强力围剿国内 Linux AI 开发板，在这之前国产的同类产品无论是价格还是体验，都被打的丢盔弃甲。 如今在千元内的选手有晶晨 A311D 、地平线 X3 、瑞芯微 RV1126、堪智 K510、全志 V85X 、晶视 CR182x 等等国产芯片，看上去感觉有很多选择？ 但是，它们要么资料太少（资料封闭）、能效比低、价格太贵、生态贫瘠、开发困难、视觉效果太差存在各种各样的问题。 真的很难有一款边缘 AI 板子可以满足开发者的要求！！！ 但现在！这些问题可能不再是问题了！ 是时候请出我们新一轮的参赛选手了！ 练习时长两年半（不是），一颗 3.6TOPs@INT8 大算力低功耗超强夜景的芯片总算是来到了 MAIX III Linux AI 系列！ <p align \"center\"> <img src \"https://axera tech.com/upload/8f/091a2540e7cdc5c7f62df022f80220.jpg\" alt \"img\" style \"zoom: 50%;\" /> </p> 没错，它就是来自「[爱芯元智](https://axera tech.com/)」的 [AX620A](https://axera tech.com/product/T7297367876123493768)，这是一款高算力，高能效比，低功耗的 AI SoC 芯片，芯片集成了四核 Cortex A7 @ 1Ghz CPU，带有浮点运算单元，支持 NEON，拥有 3.6TOPs@INT8 的高算力 NPU，支持 4K@30fps 的 ISP，以及支持 H.264、H.265 编码的 VPU，AX620A 还支持 32bit LPDDR4x，支持 EMMC v5.1 / SPI Flash，最多支持 6 路 MIPI 输入，同时最多支持 4 路工作，支持多路子码流，支持 1 路千兆 Ethernet，支持 1 路 USB2.0，支持 2 路 MIPI DSI/CSI 输出。拥有大算力和优异画质处理能力的 AX620A 可以实现更多的 AI 功能，带来最优的 AI 体验！（来自官方） ## 产品介绍 它其实早在九月初就参展了 2022 年世界人工智能大会了～（当时它长这样） <p align \"center\"> <img src \"./../assets/waic axpi.jpg\" style \"zoom: 70%;\" /> </p> 最后总算是在 20221001 的时候推出了这款搭载 AX620A 的开发板，正式名为：**MAIX III AXera Pi**，在以下内容中简称 **m3axpi** 喔！ <p align \"center\"> <video src \"../assets/axpi_boom.mp4\" width \"100%\" controls \"controls\" autoplay \"autoplay\" x5 playsinline \"\" \t\tplaysinline \t\twebkit playsinline \"true\" \t\tposter \"../assets/maix iii small.jpg\" \t\tpreload \"auto\" > </video> </p> 那么，它都带来了哪些内容呢？ 资料太少？文档教你从开箱到开发，从嵌入式 Linux 开发到 AI 模型开发指南一应俱全！ 能效比差？四核 A7 靠一条 USB3.0 就可以带起来！和你的外接电源、散热器说拜拜吧！！ 开发困难？支持 debian11 系统内置 SDK 直接板上编译！白嫖在线 AI 模型训练直到部署！！！ 没有生态？ SIPEED 拥有关于 LINUX、RISCV、AIOT、FPGA、MCU 等嵌入式领域的内容！！！！ 摄像效果太差？芯片主打 AI ISP 夜视增强！由原厂亲手为你调试白天到夜间的超强影像！！！！！ 价格太贵？从核心+底板+屏幕+摄像头+卡+外壳支架全套总共人民币 **579** ！（咆哮！！！！！！） 说这么多没用的，还是赶紧把东西掏出来，让大家瞧瞧都有些什么吧！ ## 微光影像效果 ### 夜景增强效果 <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 561523949&bvid BV1Ee4y1v7iF&cid 860676576&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\" style \"max width:640px; max height:480px;\"> </iframe> </p> ### 展会暗室现场 <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 430541632&bvid BV1iG41137tx&cid 831645988&page 1&t 83.6\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\" style \"max width:640px; max height:480px;\"> </iframe> </p> ### AI 应用实拍 <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 773227207&bvid BV1B14y1Y7A4&cid 837154353&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\" style \"max width:640px; max height:480px;\"> </iframe> </p> ## 多元 AI 生态 ### 大算力超多算子！ [点此 >>> 「查看 AX620A 算子支持列表」 <<< 喔！](https://pulsar docs.readthedocs.io/zh_CN/latest/appendix/op_support_list.html) 下表统计一下目前（20221012）千元内在售的 AI 主板（仅单主板，全套太贵）的 NPU 算力性能从高到低的排行（商品价格会受市场波动影响，若发现表格数据过于离谱请指正）。 芯片 产品 价格 CPU RAM NPU 晶晨 A311D Khadas VIM3 ¥850.00 四核 ARM Cortex A73@2.2GHz <br> 双核 ARM Cortex A53@1.8GHz 2GB 5TOPs 地平线 X3 旭日派 ¥499.00 四核 ARM Cortex A53@1.2GHz 2GB 5TOPs 爱芯元智 AX620A MAIX III AXera Pi ¥399.00 四核 ARM Cortex A7@1.0GHz 2GB 3.6TOPs 堪智 K510 K510 CRB KIT Lite ¥699.00 双核 RISCV 64 位 800Mhz 512MB 3TOPs 瑞芯微 RV1126 EASY EAI Nano ¥328.00 四核 ARM Cortex A7@1.5GHz 1GB 2TOPs 全志 V85X 全志 V853 单主板 ¥973.00 单核 ARM Cortex A7@1.2GHz 512MB 1TOPs ### 大量现成的模型！ 没有拿到板子之前，你可以到 [MaixHub 模型库](https://maixhub.com/model/zoo) 找到你需要的模型，可以在过滤选项中选择 `AX Pi` 来查找能在 `AXera Pi` 上运行的模型。 ![models](./../assets/models.jpg) 还可以在 [AXERA TECH/ax samples](https://github.com/AXERA TECH/ax samples) 仓库也可以找到模型，板子系统里也预置了模型资源，后续模型更新会在这里[「ax models」](https://github.com/AXERA TECH/ax models)，而 [ AX Samples 将不断更新最流行的、实用的、有趣的示例代码](https://github.com/AXERA TECH/ax samples/tree/main/examples#examples)，目前有如下模型支持列表： 物体分类 MobileNetv1 [MobileNetv2](https://github.com/AXERA TECH/ax samples/blob/main/examples/README.md#MobileNetv2) MobileOne s0 ResNet18 ResNet50 Others...... 物体检测 [PP YOLOv3](https://github.com/AXERA TECH/ax samples/blob/main/examples/README.md#yolov3paddle) YOLOv3 YOLOv3 Tiny YOLOv4 YOLOv4 Tiny YOLOv4 Tiny 3l [YOLOv5s](https://github.com/AXERA TECH/ax samples/blob/main/examples/README.md#YOLOv5s) [YOLOv5 Lite](https://github.com/AXERA TECH/ax samples/blob/main/examples/README.md#YOLOv5 Lite)([original model](https://github.com/ppogg/YOLOv5 Lite)) [YOLOv7 Tiny](https://github.com/AXERA TECH/ax samples/blob/main/examples/README.md#YOLOv7 Tiny) [YOLOv8s](https://github.com/AXERA TECH/ax samples/tree/main/examples#YOLOv8s) [YOLOX S](https://github.com/AXERA TECH/ax samples/blob/main/examples/README.md#YOLOX S) YOLO Fastest XL NanoDet 人型检测 YOLO Fastest Body 人脸检测 [scrfd](https://github.com/AXERA TECH/ax samples/blob/main/examples/README.md#Scrfd) [YOLOv5 Face](https://github.com/AXERA TECH/ax samples/blob/main/examples/README.md#YOLOv5 Face)([original model](https://github.com/deepcam cn/yolov5 face)) 人脸分割 Face_Parsing 障碍物检测 (扫地机场景) Robot Obstacle Detect 无人机视角物体检测 [YOLOv5s_visdrone](https://github.com/AXERA TECH/ax samples/blob/main/examples/README.md#YOLOv5s_visdrone) 3D单目车辆检测 [Monodlex](https://github.com/AXERA TECH/ax samples/blob/main/examples/README.md#Monodlex) 人体关键点 [HRNet](https://github.com/AXERA TECH/ax samples/blob/main/examples/README.md#HRNet) [AX POSE PPL](https://github.com/AXERA TECH/ax samples/blob/main/examples/README.md#AX POSE PPL) [HandPose](https://github.com/AXERA TECH/ax samples/blob/main/examples/README.md#HandPose) 人体分割 [PP HumanSeg](https://github.com/AXERA TECH/ax samples/blob/main/examples/README.md#PP HumanSeg) 语义分割 [PP Seg](https://github.com/AXERA TECH/ax samples/blob/main/examples/README.md#MobileSeg) 传统 CV 操作 CropResize Pipeline 示例 NV12 > CropResize > NN(Classification) 想要在板子上运行模型请看[「部署模型到 Maix III AXera Pi 开发板」](/ai/zh/deploy/ax pi.html) <p align \"center\"> <img src \"./../assets/ai_guide.jpg\" style \"zoom: 75%;\" /> </p> ### 在线训练模型吧！ 如今 [新版 MaixHub 正式上线啦！](https://wiki.sipeed.com/news/maixhub/new_maixhub.html)下为 maixhub 在线训练模型流程示意。 <p align \"center\"> <img src \"./../assets/test_maixhub.jpg\" style \"zoom: 100%;\" /> </p> > m3axpi 不支持上一代 m2dock 的扫码部署，只能选择本地上传文件部署。 <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 597374704&bvid BV1eB4y1Q74i&cid 741940038&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\" style \"max width:640px; max height:480px;\"> </iframe> </p> ### 分享有趣的模型！ 在你部署成功后会有一份模型文件，以及能运行模型的代码或程序，你可以将这些文件分享到 [MaixHub 模型库](https://maixhub.com/model/zoo) ，大家一起交流学习成长！（请开始你的表演吧） <p align \"center\"> <img src \"./../assets/share_model.jpg\" style \"zoom: 75%;\" > </p> <p align \"center\"> <img src \"./../assets/test_yolov5s.jpg\" style \"zoom: 100%;\" > </p> ## 活跃 の 社区资源 产品相关的专栏内容有（官方维护）： [MAIX III AXera Pi 系列文章（1）：新一代 3.6T 视觉 AI 板卡面世](https://aijishu.com/a/1060000000374898) [MAIX III AXera Pi 系列文章（2）：丰富多采的 AI 应用](https://aijishu.com/a/1060000000374900) [MAIX III AXera Pi 系列文章（3）：Debian 系统 & 开箱案例](https://aijishu.com/a/1060000000374902) [MAIX III AXera Pi 系列文章：开箱之硬件初体验](https://aijishu.com/a/1060000000378968) [MAIX III AXera Pi 系列文章：上手之丝滑玩转 AI 板卡【一】](https://aijishu.com/a/1060000000380513) [MAIX III AXera Pi 系列文章：上手之丝滑玩转 AI 板卡【二】](https://aijishu.com/a/1060000000383970) [YOLOv8 目标检测：训练自定义数据集并部署到爱芯派（一）](https://aijishu.com/a/1060000000395215) [YOLOv8 目标检测：训练自定义数据集并部署到爱芯派（二）](https://aijishu.com/a/1060000000395812) [MMPose：在爱芯派上玩转你的关键点检测](https://aijishu.com/a/1060000000396746) [MOT：如何在爱芯派上实现多目标跟踪的神奇效果！](https://aijishu.com/a/1060000000399566) [MMPoes（衍生章）：如何在爱芯派上实现跌倒检测并预警](https://aijishu.com/a/1060000000401084) 以下是由社区开发者贡献的内容，欢迎你也来贡献喔！！！（直接丢群里都可以喔！） [爱芯派 AI微光全彩夜视 开箱体验](https://zhuanlan.zhihu.com/p/571233089) [爱芯 AX620A NPU 初体验](https://neucrack.com/p/440) [MMYOLO 检测算法部署在 AX620A 记录](https://zhuanlan.zhihu.com/p/614698969?utm_campaign &utm_medium social&utm_oi 815507548294770688&utm_psn 1620047438693208065&utm_source qq) [部署你的yolov8来识别杠精（bushi）](https://www.yuque.com/prophetmu/chenmumu/pd3sdkb8z4vvvgai) [[m3axpi] YOLOv5 训练到部署全流程（最新）](https://github.com/Abandon ht/m3axpi_model/blob/main/yolov5/README_zh CN.md) [[m3axpi] YOLOv8 训练到部署全流程（最新）](https://github.com/Abandon ht/m3axpi_model/blob/main/yolov8/README_zh CN.md) [爱芯元智AX620A部署yolov5 6.0模型实录（已过时）](https://zhuanlan.zhihu.com/p/569083585) [ubuntu22.04搭建AX620A官方例程开发环境](http://t.csdn.cn/p8Nno) [AX620A运行yolov5s自训练模型全过程记录（windows）](http://t.csdn.cn/oNeYG) [MAIX III AXera Pi爱芯派从零入门开发【1】开箱试玩](https://www.bilibili.com/video/BV1LP4y1274d/?spm_id_from 333.999.0.0) [MAIX III AXera Pi爱芯派从零入门开发【2】开发部署](https://www.bilibili.com/video/BV1Ne4y117U9/?spm_id_from 333.999.0.0) [MAIX III AXera Pi爱芯派从零入门开发【3】模型转换及部署](https://www.bilibili.com/video/BV1jg411z7C8/?spm_id_from 333.999.0.0) [MAIX III AXera Pi爱芯派从零入门开发【4】视频推理及推流](https://www.bilibili.com/video/BV14D4y147Ed/?spm_id_from 333.999.0.0) [小手智联老徐 —— AI 边缘计算平台 爱芯元智 AX620A 爱芯派开箱](https://blog.csdn.net/weixin_43978579/article/details/127966677) [HonestQiao —— 矽速 MAIX III AXera Pi 开箱](https://bbs.elecfans.com/m/jishu_2314161_1_1.html) [一款国产「3.6TOPS@INT8」视觉 AI 开发板](https://mp.weixin.qq.com/s/3bxFxO0Q0UmpzSM3_K794g) [国产AI开发板测评 MAIX III AXera Pi 上手 YOLOv5s 实时目标检测](https://mp.weixin.qq.com/s/lqxL DmhBa K9gu3uEyebQ) [【AXPI】如何在 M1/M2 Mac上使用 Rndis](https://blog.csdn.net/flamebox/article/details/127103964) 产品相关的新闻内容有： [AI ISP 的黎明——大话成像](https://axera tech.com/tech/T7297054127901756535) [2022世界人工智能大会启动:爱芯元智发布AI ISP“爱芯智眸®”_中华网](https://tech.china.com/article/20220901/092022_1134965.html) [爱芯元智AX620A与百度飞桨完成 I 级兼容性测试 开源生态建设更进一步](https://mp.weixin.qq.com/s/k6G1pE 31VXlrBA3F6_Liw) [AI 视觉新势力×微光全彩“黑”科技](https://mp.weixin.qq.com/s/JIvVprWlQPvE7bTxozAG_Q) [爱芯派™AXera Pi™亮相ICCAD 爱芯元智开源生态建设加速](https://mp.weixin.qq.com/s/_nZLfEjxOb4QLpGWgaLVWQ) [新一代 Kaldi 嵌入式端实时语音识别](https://mp.weixin.qq.com/s/r4nGu04o1sjdFZt_vYbUAA) > 截止更新时间：20221205 <p align \"center\"> <img src \"./../assets/demo_one.jpg\" style \"zoom: 100%;\"> <img src \"./../assets/demo_two.jpg\" style \"zoom: 100%;\"> </p> ## 丰富 の Linux 内容 ### 超高性价比与能效比 别搞那些虚的。来点实际点的，以下是目前（20221014）市场上销量排行的典型 AI 开发产品，**商品价格会随时变动，有疑问可查询或指出并纠正**。（已除去低成本 38 板摄像头和芯片原厂超昂贵开发板） AI 开发板 全家桶套餐的主要内容 大致价格（20221013） 英伟达JETSON NANO开发板 4GB 主板、铝合金外壳（带风扇）、5V4A 电源、双频无线网卡、64G U盘、IMX279 摄像头、HDMI 线 + 网线、7 寸触摸屏+支架、 ¥2129.00 Raspberry Pi 树莓派4B 4GB 主板、七寸触摸屏+支架、64G U盘、散热片、HDMI 线 + 网线、5V3A 电源、亚克力外壳（带风扇）、500w USB 摄像头、入门指导手册 ¥1439.00 Khadas vim3物联网a311d（目前线上销量不高，但很典型） VIM3（4GB+32G）开发板、外壳、散热器、风扇、30W 电源、HDMI 线 ¥1399.00 迅为RK3568开发板瑞芯微 商业级2G+16G、7寸MIPI屏、OV5695摄像头、（没有配电源） ¥1380.00 EASY EAI Nano AI开发板 瑞芯微RV1126 1GB 单主板、200w双目摄像头（gc2xxx）、5寸ips屏、天线、喇叭、铜柱、2A电源 ¥799.00 亚博智能 旭日X3派开发板 2GB 主板、古月居课程、WIFI 天线、铝合金外壳、gc4663 摄像头、32G U盘、5V3A 开关电源、HDMI 线 ¥769.00 Sipeed M3AXPI Linux AI 微光夜视 爱芯派 2GB 单主板、400w gc4653 摄像头、5寸ips屏、外壳、数据线、32G TF 卡、在线模型训练服务、活力四射的开源社区 ¥579.00 想想某些产品为什么卖这么贵，销量还这么好？凭什么？ 这些产品除了本身的质量要过硬，功能要够强，还要凭借自身的社区生态、软件支持、丰富资料、开源代码、用户口碑等等特色，来支撑产品高性价比的形象。 > 笔者在这里认为所谓的性价比不是一昧地追求产品的最低价，而是在同类产品市场的主流价格区间内，选出社区用户群体可以接受的价格，然后在这个定位里去尽力做出效果最好的产品。 从这些典型的产品中可以看出 m3axpi 套餐是没有配「散热片和风扇还有外接电源」的，这也是它的另一个特色「高能效比」。 是的，这个产品不需要散热器/风扇，也不需要外接 2A 电源就可以启动系统，更不需要找 hdmi 线和显示器。 来一个实际测量的温度和功耗，注意要使用 USB3.0 的口来供电喔。 <p align \"center\"> <img src \"./../assets/temp_test_axpi.jpg\" style \"zoom: 100%;\" /> </p> > 从实测结果上来看，这个功耗和温度控制得挺好，用 USB3.0 5V@1A 承载了底板、核心板、WIFI、以太网、摄像头、5寸屏的工作。 ### 基于 debian 系统开发 提供 debian11 Linux 系统，支持 SD 卡启动 DD 烧录系统，方便用户开箱上手，同时支持 Python API 编程开发 AI 应用。 1. 烧录方法：[WIKI AXera Pi 烧录系统](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/flash_system.html#%E8%8E%B7%E5%8F%96%E9%95%9C%E5%83%8F) 2. 上手指南：[WIKI AXera Pi 上手必看](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/flash_system.html) 2. Python 编程：[ax_pipeline_api ](https://github.com/junhuanchen/ax_pipeline_api) （由社区大佬鼠贡献） 3. 开发笔记：[[maixpy3 axpi] 关于爱芯 ax620a 移植 debian11 系统这件事](https://www.cnblogs.com/juwan/p/16751348.html) 4. 开发笔记：[[maixpy3 axpi] 编辑发布 debian 镜像与在 PC 上交叉编译程序 ](https://www.cnblogs.com/juwan/p/16769237.html) ### 开放 BSP SDK 源码 提供各类开发源码，提供 API 开发文档，SDK 开发方法等说明，细节可以从[准备 C/C++ 编程](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/dev_prepare.html#%E8%8E%B7%E5%8F%96 SDK %E6%BA%90%E7%A0%81) 得知。 #### [ax sample](https://github.com/AXERA TECH/ax samples) 由爱芯提供典型 AI 模型的开发与评估验证，提供给有经验的 AI 开发者使用或只想蹭模型的同学，不涉及任何硬件外设有关的内容。 1. [示例项目 examples](https://github.com/AXERA TECH/ax samples/tree/main/examples) 2. [物体检测 PP YOLOv3](https://github.com/AXERA TECH/ax samples/blob/main/examples/README.md#yolov3paddle) 3. [人体分割 PP HumanSeg](https://github.com/AXERA TECH/ax samples/blob/main/examples/README.md#MobileSeg) 4. [语义分割 PP Seg](https://github.com/AXERA TECH/ax samples/blob/main/examples/README.md#PP HumanSeg) #### [libmaix](https://github.com/sipeed/libmaix) 由 SIPEED 提供在嵌入式平台统一的嵌入式开发环境，主要有摄像头、屏幕、视觉、图像处理、部署 Pipeline 相关的实机例程，适合刚入门嵌入式 linux 开发的同学使用。 1. [测试一下屏幕显示](https://github.com/sipeed/libmaix/tree/release/examples/display) 2. [把摄像头显示到屏幕](https://github.com/sipeed/libmaix/tree/release/examples/axpi) 3. [摄像头+yolov5 模型+屏幕](https://github.com/sipeed/libmaix/tree/release/examples/axpi_yolov5_cam) ##### [axpi_bsp_sdk](https://github.com/sipeed/axpi_bsp_sdk) 芯片商用时所用的 bsp 开发包，这里主要提供的是芯片的原始开发资料，如 uboot、linux、msp 、sample、rtsp、ipcdemo 等工程代码，这个部分是逐步开源的，你可以从这里得到商业评估用的代码，例如 ipcdemo 这样的程序，但这些代码会很复杂且高耦合，适合有经验的同行出于商业落地的目的使用。 1. 开发文档 [docs](https://github.com/sipeed/axpi_bsp_sdk/tree/main/msp/sample/vo_fb) 2. 框架应用 [ipcdmeo](https://github.com/sipeed/axpi_bsp_sdk/tree/main/app/IPCDemo) 3. 外设验证 [sample](https://github.com/sipeed/axpi_bsp_sdk/tree/main/msp/sample) #### [ax pipeline](https://github.com/AXERA TECH/ax pipeline) AX Pipeline 由爱芯主导开发。该项目基于 AXera Pi 展示 ISP、图像处理、NPU、编码、显示 等功能模块软件调用方法，方便社区开发者进行快速评估和二次开发自己的多媒体应用。 1. [快速编译](https://github.com/AXERA TECH/ax pipeline/blob/main/docs/compile.md) 基于 cmake 实现简单的跨平台编译。 2. [如何更换自己训练的 yolov5 模型](https://github.com/AXERA TECH/ax pipeline/blob/main/docs/how_to_deploy_custom_yolov5_model.md) 3. [如何部署自己的其他模型](https://github.com/AXERA TECH/ax pipeline/blob/main/docs/how_to_deploy_custom_model.md) 4. [如何调整图像方向](https://github.com/AXERA TECH/ax pipeline/blob/main/docs/how_to_adjust_image_orientation.md) 5. [ModelZoo](https://github.com/AXERA TECH/ax pipeline/blob/main/docs/modelzoo.md) 一些支持或将支持的模型和一些模型的说明。 ## 选择 M3AXPI 的理由 >为什么要选择 M3AXPI 呢？由这个视频来回答你的所有疑问吧！ 视频简述了 M3AXPI 比起 M2DOCK 的优势，还有超多实际使用效果案例以及彩蛋！ <iframe src \"//player.bilibili.com/player.html?aid 992194128&bvid BV1px4y1w75T&cid 1018084963&page 1&t 372\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> ## 相关硬件参数 <p align \"center\"> <img src \"./../assets/waiguan1.jpg\" style \"zoom: 51%;\" /> <img src \"./../assets/maix iii small.jpg\" style \"zoom: 80%;\" /> <img src \"./../assets/waiguan2.jpg\" style \"zoom: 45%;\" /> </p> ### 硬件标注图 <p align \"center\"> <img src \"./../assets/layout_axpi_2.png\" alt \"layout_axpi_2\" width \"45%\"> <img src \"./../assets/layout_axpi_1.png\" alt \"layout_axpi_1\" width \"45%\"> </p> ### 核心板参数 项目 参数 CPU 四核 Cortex A7, 支持 NEON 和 FPU NPU 14.4Tops@int4，3.6Tops@int8 ISP 4K@30fps 编解码格式 H.264, H.265 视频编码 4K@30fps 视频解码 1080P@60fps Ethernet 支持双路RGMII / RMII 接口模式的以太网 显示输出 MIPI DSI 4 Lane，最高支持4K@30FPS DRAM 2GB LPDDR4X 3733Mhz 存储 可选16GB EMMC（默认是 TF 卡启动） IO 引出 DDR4 SODIMM 260P 金手指全 IO 引出 ### 底板参数 项目 参数 摄像头输入 （默认单摄）最高支持 3 摄:1个MIPI4 LANE+2个MIPI2 LANE 屏幕输出 支持最高 4 LANE MIPI DSI 屏幕 SD 插槽 默认从 SD 卡启动 录音输入 板载两个 MEMS MIC 支持双麦降噪 音频输出 3.5MM耳机接口 支持立体声输入和 MIC 输入 网络接口 支持 千兆以太网（ETH） 和 2.4GHZ WI FI 板载天线 USB 接口 1xUSB2.0HS 支持 OTG 或 HOST 功能，1xUSB UART 系统串口 其他资源 1x用户按键，3x系统按键，1xRTC时钟，2xLED 对外接口 引出CJTAG，可自行连接相应调试器，引出2x12排针，4个M2.5螺丝定位孔 [硬件资源汇总链接](https://dl.sipeed.com/shareURL/MaixIII/AXera) [产品规格书](https://dl.sipeed.com/shareURL/MaixIII/AXera/01_Specification) [原理图](https://dl.sipeed.com/shareURL/MaixIII/AXera/02_Schematic) [点位图](https://dl.sipeed.com/shareURL/MaixIII/AXera/03_Bit_number_map) [模型文件](https://dl.sipeed.com/shareURL/MaixIII/AXera/05_3D_file) [尺寸图](https://dl.sipeed.com/shareURL/MaixIII/AXera/04_Dimensional_drawing) [GC4653 摄像头参考使用手册](https://dl.sipeed.com/shareURL/MaixIII/AXera/07_Chip_manual) ### 摄像头一览 低配 gc4653 400w 基础体验版本。 <p align \"center\"> <img src \"./../assets/ax620a_gc.jpg\" style \"zoom: 100%;\" /> </p> 高配 os04a10 400w 夜景增强版本。 <p align \"center\"> <img src \"./../assets/ax620a_os.jpg\" style \"zoom: 100%;\" /> </p> > [更换摄像头常见问题](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html) ## 常见问题（FAQ） AI 服务 http://maixhub.com 在线文档 http://wiki.sipeed.com 交流社区 http://bbs.sipeed.com 开源组织 http://github.com/sipeed AXERA 技术交流群：（ 139953715 ）专供 AI ISP 技术交流 荔枝 MaixPy3 AI 交流群：（ 756313869 ）给产品开箱小白答疑 Q & A 请到 [Maix III 系列 AXera Pi 常见问题（FAQ）](./faq_axpi.html) 了解喔。"},"/hardware/zh/maixIII/ax-pi/dev_prepare.html":{"title":"Maix-III AXera-Pi 开发板 SDK 使用介绍","content":" title: Maix III AXera Pi 开发板 SDK 使用介绍 > 本文假定你是一名不了解 linux 系统的开发方式的开发者，但知道 gcc 和 make 命令使用的相关专业工程师，如果你不了解 gcc 编译程序，可以先学习[Linux中gcc/g++ gdb make/Make 的基本使用和理解](https://blog.csdn.net/m0_46606290/article/details/123083945) 。 ## 准备工作 欲善其事，必先利其器。在开始开发之前，需要准备好开发板、开发环境、开发工具等。 根据前面的章节，你掌握了开发板的 烧录系统 和 登录系统 等一系列 Linux 基础操作，这可以帮助你在开发过程中排查设备问题或调试驱动代码。 但接下来要开发程序就需要准备好开发环境和开发工具了，以下是给从来没接触过嵌入式 linux 系统开发的同学了解的内容，如软件工程的同学。 首先认识一下什么是交叉编译，通常来说，编译程序有交叉编译和本地编译两种情况，本地编译就是在本机上使用 gcc 进行编译运行程序（例如在 Visual Studio 上编译运行 hello world ），而交叉编译就是本机没有编译环境，需要在另一台机器上完成编译再送进来运行（例如在 Android Studio 上编译 apk 送到手机里安装程序运行）。 > 交叉编译是指在一种计算机架构上编译出另一种计算机架构的可执行程序。交叉编译的目的是为了在一种计算机架构上运行另一种计算机架构的程序。例如，可以在 x86 架构的计算机上编译出 ARM 架构的可执行程序，或者在 ARM 架构的计算机上编译出 x86 架构的可执行程序。交叉编译的目的是为了在一种计算机架构上运行另一种计算机架构的程序。例如，可以在 x86 架构的计算机上编译出 ARM 架构的可执行程序，或者在 ARM 架构的计算机上编译出 x86 架构的可执行程序。 两者的区别在于编译一些复杂大型软件，本机性能太弱内存又少，导致编译出来的时间太长，所以需要交叉编译来完成，比如 ax sample 在本机完整编译需要十几分钟，而在一台高性能的桌面计算机上只需要数十秒即可。 所以从开发的角度来说，本机编译只是为了快速应用查看效果，真正得开发起来还是得交叉编译，就像原厂提供的 bsp sdk 一样，在计算机上完成编译后，再送进板子中运行。 ## 板子与电脑的文件互传 在编译程序之前，你需要了解一些拷贝文件到板子或电脑的方法，免得交叉编译完程序不知道怎么传文件进去板子里运行。 ssh 相关的远程工具需要，你知道板子的 IP 地址，可以从 ifconfig 得知。 serial 相关的有线串口工具，需要你接好线配置好参数连上板子。 如何登录板子均可以从前文【系统使用手册】中得知。 ### 使用 ssh 远程管理工具 在 windows 上有许多远程管理 linux 服务器的工具都提供了文件传输的功能，这里只推荐免费绿色好用的 mobaxterm 工具。 [利用MobaXterm实现linux和windows之间传输文件](https://jingyan.baidu.com/article/9f63fb91e2bc6688400f0e93.html) [用MobaXterm 在linux和windows之间上传/下载文件](https://blog.csdn.net/unforgettable2010/article/details/123930796) > [如何使用 mobaxterm](https://wiki.sipeed.com/hardware/zh/maixII/M2/tools/mobaxterm.html) 想了解更多可以看 [推荐7款超级好用的终端工具 —— SSH+FTP](https://zhuanlan.zhihu.com/p/301653835) ，而其他系统都提供了好用的命令行终端，支持 ssh 、 scp 等命令直接执行。 ### 使用 scp 命令复制文件 和 cp 复制文件等命令一样，它就是 ssh + cp scp 这个意思。 [linux操作系统scp命令使用方法](https://cloud.tencent.com/developer/article/1876623) ### 使用读卡器物理拷贝文件 由于 linux 系统采用 ext4 分区在 Windows / Mac 默认系统上看不到，需要额外安装增强工具才能读取到具体的分区。 [如何在 Windows 下访问 ext4 格式的硬盘？](https://zhuanlan.zhihu.com/p/448535639) [[macOS] 在 macOS 上挂载 Linux 的 ext/ext3/ext4 文件系统](https://blog.twofei.com/773/) Linux 系统可以直接看到卡里的分区和内容，实在不行也可以把读卡器接到安卓设备通过 otg 转接头实现文件拷贝。 ### 使用有线串口互传文件 接好串口连上设备，安装 `apt get install lrzsz` 工具后参考以下文章： 使用 命令行工具 `minicom D /dev/ttyUSB0 b 115200` 可以看[ubuntu中使用 minicom 玩转文件的上传与下载](https://blog.csdn.net/wanyeye/article/details/42002377)。 使用 mobaxterm 可以看 [MobaXterm 使用 rz/sz 传送文件](https://blog.csdn.net/qq_28837389/article/details/120073720) 其他的可以自行百度。 ## 本机编译可直接运行程序 这里把 m3axpi 板子当作一台本地的微型 linux 服务器的角色来看待，使用 vscode remote 或 mobaxterm 这类远程开发工具连接到板子里，这样就可以得到一个和在 linux 服务器一样的本地开发环境，可以在本地编辑代码后直接编译运行程序。 ### vscode remote vscode remote 是 vscode 的一个插件，可以直接连接到远程的 linux 服务器，然后在本地编辑代码，同步到远程服务器上编译运行，这里以一台 ubuntu20.04 的桌面计算机系统为例，只要能安装 vscode 编辑器软件计算机都行，这里只是为了示意如何连接到板子里。 安装插件： ```bash sudo apt install code code install extension ms vscode remote.remote ssh ``` <! [附图] > 连接到板子： ```bash ssh root@192.168.233.1 ``` <! [附图] > 不想输入密码可以用 sshpass 命令省略。 ```bash sshpass p root ssh root@192.168.233.1 ``` 接着就可以在 vscode 里编译运行 linux 系统的程序了，幸运的是在 debian 系统上可以直接通过 apt 得到本机的编译工具链，而不用交叉编译就可以直接编译运行程序，这些都已经提前准备好了，对用户来说可以节省不少搭建内部开发环境的时间。 所以可以直接在板子里编译运行 libmaix 项目： ```bash cd /home/libmaix/examples/axpi/ python3 project.py build fbon ./dist/start_app.sh ``` > 按 ctrl + c 中断停止程序直到退出。 <! 附图： > ### mobaxterm 在 Windows 上可以用 mobaxterm 这样的工具连接到板子进行 linux 服务器管理，但编译还是需要在 linux 系统上进行。 ![mobaxterm_ssh](./../assets/ssh.jpg) ## 交叉编译上传程序再运行 在这之前需要有本地编译的认知，然后发现本地内存和性能不能满足自身开发需求的时候，就要准备交叉编译程序了，此时程序是在另一台更强的 x86 linux 系统上完成的，并且编译出来的程序需要拷贝到板子里运行。 > **[20221010 现提供一种借助 docker qemu arm 虚拟机来实现在 x86 机器上实现本地编译 arm 程序的方法，这种方法既提高了编译效率又不用配环境的方法值得一试！](https://www.cnblogs.com/juwan/p/16769237.html)** 首先得有一台 linux 系统，如 ubuntu20.04 这样的桌面计算机，接着和上面一样，也可以在这台计算机上安装 vscode remote 或 idea clion 这类开发工具直接连接到板子里，这可以方便你编辑代码或传输文件。 想要在 x86 的机器上编译出 arm 架构的程序，想要先配置专用的交叉编译工具链，例如这里使用的是 arm linux gnueabihf 这个工具链，这个编译链可以直接通过 apt 安装。 `sudo apt install gcc arm linux gnueabihf` 安装完成后，可以在 /usr/bin 目录下找到 `arm linux gnueabihf gcc` 这个交叉编译工具，这个工具可以用来编译 linux 系统的程序。 ```bash juwan@juwan n85 dls:~$ /usr/bin/arm linux gnueabihf gcc v Using built in specs. COLLECT_GCC arm linux gnueabihf gcc COLLECT_LTO_WRAPPER /usr/lib/gcc cross/arm linux gnueabihf/9/lto wrapper Target: arm linux gnueabihf Configured with: ../src/configure v with pkgversion 'Ubuntu 9.4.0 1ubuntu1~20.04.1' with bugurl file:///usr/share/doc/gcc 9/README.Bugs enable languages c,ada,c++,go,d,fortran,objc,obj c++,gm2 prefix /usr with gcc major version only program suffix 9 enable shared enable linker build id libexecdir /usr/lib without included gettext enable threads posix libdir /usr/lib enable nls with sysroot / enable clocale gnu enable libstdcxx debug enable libstdcxx time yes with default libstdcxx abi new enable gnu unique object disable libitm disable libquadmath disable libquadmath support enable plugin enable default pie with system zlib without target system zlib enable libpth m2 enable multiarch enable multilib disable sjlj exceptions with arch armv7 a with fpu vfpv3 d16 with float hard with mode thumb disable werror enable multilib enable checking release build x86_64 linux gnu host x86_64 linux gnu target arm linux gnueabihf program prefix arm linux gnueabihf includedir /usr/arm linux gnueabihf/include Thread model: posix gcc version 9.4.0 (Ubuntu 9.4.0 1ubuntu1~20.04.1) ``` 本地与交叉编译唯一不同的地方就是需要把将编译出来的程序，上传到板子运行，而不能直接运行程序。 以 libmaix 这个项目为例：在 x86 的机器上编译时需要修改本机的交叉编译链，如：python3 project.py board axpi toolchain /usr/bin toolchain prefix arm linux gnueabihf config 之中的编译链可能会发生改变，这里需要根据你的实际情况进行修改，比如本机环境下可能有多个编译链，但一般来说是不需要修改的。 除了修改交叉编译链，如果出现编译失败，还需要修改编译配置中所需要的依赖文件或头文件的路径： ``` list(APPEND ADD_INCLUDE \"lib/arch/axpi/joint\" \"lib/arch/axpi/opt/include\" \"lib/arch/axpi/opt/include/opencv4\" ) \"/lib/aarch64 linux gnu/libm.so\" \"/lib/aarch64 linux gnu/libpthread.so\" \"/lib/aarch64 linux gnu/libopencv_videoio.so\" \"/lib/aarch64 linux gnu/libopencv_highgui.so\" \"/lib/aarch64 linux gnu/libopencv_imgcodecs.so\" \"/lib/aarch64 linux gnu/libopencv_imgproc.so\" \"/lib/aarch64 linux gnu/libopencv_core.so\" \"/lib/aarch64 linux gnu/libopencv_freetype.so\" ``` 当换了编译链后也要修改到其他路径下的链接库： ``` list(APPEND ADD_INCLUDE \"lib/arch/axpi/joint\" \"/opt/include\" \"/usr//local/include/opencv4\" ) \"/lib/arm linux gnueabihf/libm.so\" \"/lib/arm linux gnueabihf/libpthread.so\" \"/lib/arm linux gnueabihf/libopencv_videoio.so\" \"/lib/arm linux gnueabihf/libopencv_highgui.so\" \"/lib/arm linux gnueabihf/libopencv_imgcodecs.so\" \"/lib/arm linux gnueabihf/libopencv_imgproc.so\" \"/lib/arm linux gnueabihf/libopencv_core.so\" \"/lib/arm linux gnueabihf/libopencv_freetype.so\" ``` 简而言之，更换了桌面系统和编译链，那源码中对应的一些依赖文件肯定也会发生改变，这需要看所用的 sdk 是如何解决这个问题的，通常来说只需要换交叉编译链和修改链接目录即可。 上文介绍了如何在 linux 系统上编译运行 libmaix 项目，以及如何在 linux 系统上交叉编译 libmaix 项目，希望对大家有所帮助，只要掌握了如何管理开发环境和如何编译运行 linux 的程序，接下来就可以基于我们提供的 sdk 开发属于自己的项目了。 在这里「大佬鼠」推荐自己的开发流程和方法，最开始就是先在板子上本地编译测试现有的代码和功能，然后根据 [[maixpy3 axpi] 编辑发布 debian 镜像与在 PC 上交叉编译程序 ](https://www.cnblogs.com/juwan/p/16769237.html) 来安装 docker arm 虚拟机。 接着，将之前烧录到板子里的根文件系统（.img）通过 losetup + mount + chroot 挂载（.img）出来，这时候你就会得到和板子一样的 arm 虚拟机环境，就可以直接本地编译啦！不过，这个方法需要学习 docker 的安装喔，包括后面的模型开发也上会用到 docker 的。 > 如果你不嫌麻烦的话，可以选择配置交叉编译链、板子依赖的头文件、第三方链接库后才能进行程序的编译，但这个 docker arm 虚拟机的方法是最省事的，甚至还可以通过读卡器（或网络）挂载板子里的根文件系统进行编译。 * [什么是交叉编译？](https://cn.bing.com/search?q %E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%EF%BC%9F) * [超详细解答vscode如何远程连接Linux以及可能会出现的一些问题](https://blog.csdn.net/cxn15335120506/article/details/123238233) * [vscode remote](https://code.visualstudio.com/docs/remote/remote overview) * [ssh scp 是什么？](https://cn.bing.com/search?q ssh+scp+%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F) * [libmaix](https://github.com/sipeed/libmaix) * [mobaxterm](https://mobaxterm.mobatek.net) * [arm linux gnueabihf gcc](https://packages.ubuntu.com/focal/gcc arm linux gnueabihf) ## 获取 SDK 源码 前文介绍了基础的开发环境搭建和使用方法，你应该了解什么是本地编译和交叉编译，下面开始介绍如何使用这些 sdk 源码开发程序。 [libmaix](https://github.com/sipeed/libmaix) 由 sipeed 提供在 linux 平台统一的嵌入式开发环境，主要有摄像头、屏幕、视觉、图像处理、NPU pipiline 相关的实机部署例程，适合刚入门嵌入式 linux 开发的同学使用。 [ax sample](https://github.com/AXERA TECH/ax samples) 由爱芯提供 AI 模型的开发与评估验证，提供给有经验的 AI 开发者使用，不涉及任何硬件外设有关的内容。 [axpi_bsp_sdk](https://github.com/sipeed/axpi_bsp_sdk) 芯片商用时所用的 bsp 开发包，这里主要提供的是芯片的原始开发资料，如 uboot 、 linux 、 msp 、msp 等工程代码，这个部分是逐步开源的，你可以从这里得到商业评估用的代码，例如 ipcdemo 这样的程序，但这些代码会很复杂且高耦合，适合有经验的同行出于商业落地的目的使用。 [ax pipeline](https://github.com/AXERA TECH/ax pipeline) 基于 axpi_bsp_sdk 制作的 AI 部署高性能仓库，在这里主要用于该项目基于 AXera Pi 展示 ISP、图像处理、NPU、编码、显示 等功能模块软件调用方法，方便社区开发者进行快速评估和二次开发自己的多媒体应用。 ### libmaix 这是一个适用于 sipeed 所用 linux 芯片开发的 C/C++ 基础开发框架，使用 cmake 构建，提供了许多开箱参考的案例，还有一些第三方库代码的链接，如 opencv openmv 这些视觉库的链接。 SDK 源码在 [libmaix](https://github.com/sipeed/libmaix)， 需要使用 git 命令下载： ```bash git clone https://github.com/sipeed/libmaix.git recursive ``` >! 注意这里` recursive` 参数是必须的，用来下载仓库里面的子模块，如果没有这个参数，代码会不完整，导致编译出错。 > 中国国内可能下载速度较慢，可以多取消重试几次，可能会遇到速度快的节点，当然最好还是通过设置代理来加速下载。 另外， AI 模型及例程在 [MaixHub 模型库](https://maixhub.com/model/zoo) 可以找到， 以及 [AXERA TECH/ax samples](https://github.com/AXERA TECH/ax samples) 仓库。 ## 编译 SDK 源码 回顾一下前文的内容，编译有两种方式： * 直接在开发板上编译：编译速度较慢，但是不需要额外的环境配置。 * 在 PC 上编译，然后拷贝可执行文件到开发板，也就是交叉编译： 编译速度更快，但是需要额外的环境配置。 ### [libmaix](https://github.com/sipeed/libmaix) > /home/ 目录已预置，可以 git pull 联网拉取更新。 对于 `libmaix`， 按照其`README.md` 文件描述的方法编译即可， 不过需要在`menuconfig`命令中选择 `AXera Pi` 作为编译目标。 这里简要介绍一下编译过程（libmaix 目前还未稳定，未来可能会有大的更新），实际以[libmaix 仓库](https://github.com/sipeed/libmaix)代码和说明为准。 * 先安装依赖 ``` apt install build essential cmake python3 sshpass git ``` > sshpass 也可以不安装， build essential, cmake, git, python3 必须安装 * 克隆仓库到本地或者开发板 ``` git clone https://github.com/sipeed/libmaix recursive ``` >! 注意 ` recursive` 参数是必须的，用以克隆子模块，否则会缺代码。 这里以在开发板上编译为例： ```bash cd /home/libmaix # git clone https://github.com/sipeed/libmaix recursive cd examples/axpi python3 project.py distclean # python3 project.py menuconfig # 可以配置相关参数 python3 project.py build # 如果增加文件了，需要 python3 project.py rebuild 命令 ./dist/start_app.sh # 运行示例程序 ``` ### [ax samples](https://github.com/AXERA TECH/ax samples) > /home/ 目录已预置，可以 git pull 联网拉取更新。 [ax samples](https://github.com/AXERA TECH/ax samples) 是爱芯官方提供的例程，包含了一些 AI 模型和运行代码，编译完能直接在开发板上运行，只不过输入是图片，不是摄像头。 进入开发板终端，执行以下代码： ```bash cd /home/ax samples # git clone https://github.com/AXERA TECH/ax samples.git mkdir build cd build cmake .. make install ``` 然后就能在`ax samples/build/install/bin/`目录下找到编译好的可执行文件。 ### [axpi_bsp_sdk](https://github.com/sipeed/axpi_bsp_sdk) 回到芯片原厂开发的环境，这需要有经验的嵌入式 Linux 开发者来操作，直接看 readme 进行操作，文档在 docs 目录下。 #### What is this? this is a ax620 linux bsp sdk form AX620_R1.22.2801_Sipeed. currently it is application layer open source. ```bash juwan@juwan n85 dls:~/GIT_AX620_SDK_V0.31.0_P23/sipeed/axpi_bsp_sdk$ tree L 1 . ├── app ├── build ├── msp ├── readme.md ├── rootfs └── third party 5 directories, 1 file ``` #### ready arm gcc ```bash git clone https://github.com/sipeed/axpi_bsp_sdk.git cd axpi_bsp_sdk wget http://releases.linaro.org/components/toolchain/binaries/latest 7/arm linux gnueabihf/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf.tar.xz sudo tar xvf gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf.tar.xz C /opt/ ``` #### how to compile bsp msp sample ```bash cd msp/sample/ export PATH \"/opt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/:$PATH\" && make p AX620_demo all install ``` third party libs ```bash cd third party export PATH \"/opt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/:$PATH\" && make p AX620_demo all install ``` bsp app ipcdemo ```bash cd app/ export PATH \"/opt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/:$PATH\" && make p AX620_demo all install ``` bsp msp component lib, such as `cd app/msp/component/common && make xxxx`. ``` juwan@juwan n85 dls:~/GIT_AX620_SDK_V0.31.0_P23/sipeed/axpi_bsp_sdk/msp/component$ tree L 1 . ├── axsyslog ├── common └── thermal 4 directories, 0 files ``` #### run your program on pc ``` sshpass p root scp ./vo_fb/sample_vo_fb root@192.168.233.1:/opt/bin/sample_vo_fb ``` on board ``` chmod 777 /opt/bin/sample_vo_fb /opt/bin/sample_vo_fb v dsi0@480x854@60 m 0 & fbv /home/examples/480x360.jpg killall sample_vo_fb ``` ## 组合 SDK 和 AI 模型例程 比如我们要跑一个视觉 AI 模型，需要用到摄像头，屏幕，还有 AI 模型，你需要借助以下仓库代码完成这个目标。 ### 借助 libmaix 实现（开发难度最小，适合验证） 基于 libmaix 的 axpi 项目进行开源快速验证效果，代码简单易懂，基于在线服务完成模型部署，只用于新手上路，与 ax sample 的模型一起被支持。 [axpi](https://github.com/sipeed/libmaix/tree/release/examples/axpi) [axpi_classification_cam](https://github.com/sipeed/libmaix/tree/release/examples/axpi_classification_cam) [axpi_yolov5_cam](https://github.com/sipeed/libmaix/tree/release/examples/axpi_yolov5_cam) > 20221113 目前仓库只保证用户初次上手时能够不报错的安全调用 AI 模型，不代表芯片的最好效果。 ### 借助 ax pipeline 实现（开发难度适中，适合优化） 到了这里要有基本的芯片 bsp sdk 开发的基础（axpi_bsp_sdk），这部分会略显专业一些，这个仓库目前追求最高性能的效果。 [准备编译环境](https://github.com/AXERA TECH/ax pipeline/blob/main/docs/compile.md) [如何更换自己训练的 yolov5 模型？](https://github.com/AXERA TECH/ax pipeline/blob/main/docs/how_to_deploy_custom_yolov5_model.md) [如何部署自己的其他模型](https://github.com/AXERA TECH/ax pipeline/blob/main/docs/how_to_deploy_custom_model.md) ### 借助 ipcdemo 实现（开发难度最大，适合落地） 基于 axpi_bsp_sdk 的 ipcdemo 商用视频推流应用，由于源码过于复杂，需要有上述基础才能介入。 [axpi_bsp_sdk/app/IPCDemo](https://github.com/sipeed/axpi_bsp_sdk/tree/main/app/IPCDemo)"},"/hardware/zh/maixIII/ax-pi/flash_system.html":{"title":"AXera-Pi 上手指南","content":" title: AXera Pi 上手指南 tags: AXera Pi, 烧录系统, 上手指南 keywords: AXera Pi，烧录, 上手 desc: AXera Pi 产品上手指南 update: date: 2022 11 25 version: v0.4 author: lyx content: 增加上手使用说明 date: 2022 11 10 version: v0.3 author: wonder content: 优化排版 date: 2022 09 29 version: v0.2 author: wonder content: 丰富内容 date: 2022 09 13 version: v0.1 author: lyx content: 初稿 ## 上手指南 为了让小伙伴们轻松、快速、平稳地把产品用起来，我们准备了新手初学者上手指南： ### Linux 系统简介 **AXera Pi 默认板卡没有存储介质，因此需要准备一张系统卡来启动设备。** 目前 AXera Pi 提供的是 Debian11 Bullseye 镜像，[Ubuntu 源自 Debian，这意味着 Ubuntu 使用与 Debian 相同的 apt 打包系统，并共享来自 Debian 存储库的大量软件包和库，利用 Debian 基础设施作为基础。 大多数“派生” Linux 发行版，它们使用相同的包管理系统并与基于的发行版共享软件包。](https://zhuanlan.zhihu.com/p/426219868) > ![debian_logo](./../assets/debian_logo.jpg) > [选择 Debian 的理由](https://www.debian.org/intro/why_debian) [官方淘宝店](https://sipeed.taobao.com/)可以购买预烧录系统镜像的 SD 卡，否则就需要自己进行以下的操作来准备 SD 镜像卡。 ### 选择 SD 卡 > 已在官方购买镜像卡的同学跳过这一步骤，直接在设备插入 TF 卡[ 点击查看 ](#%E5%90%AF%E5%8A%A8 Linux %E7%B3%BB%E7%BB%9F)启动 Linux 系统。 为了方便用户有更多的选择，我们对部分 SD 卡在 AXera Pi 板子上进行了读写测速。 ![sd](./../assets/flash_system/sd.jpg) > 因为部分 SD 卡是后面陆续才进行测试，没有一一单独拍照但可以根据型号辨认。 序号 型号 <p style \"white space:nowrap\">写入速度（写入量 160MB）</p> <p style \"white space:nowrap\">读取速度（读取量 160MB） </p> 1. Netac 朗科 A2 P500 超高速 64GB 存储卡 2.04697 s, 80.0 MB/s 1.8759 s, 87.3 MB/s 2. 三星 microSDXC UHS I 128G 存储卡（蓝卡） 2.53387 s, 64.7 MB/s 1.99882 s, 82.0 MB/s 3. EAGET TF 卡（T1 系列）64G 存储卡 6.56955 s, 24.9 MB/s 7.13792 s, 23.0 MB/s 4. 京东 高性能 microSDXC UHS I 128G 存储卡 2.28133 s, 71.8 MB/s 1.92001 s, 85.3 MB/s 5. KIOXIA microSDXC UHS I 32G 存储卡 6.71284 s, 24.4 MB/s 2.36794 s, 69.2 MB/s 6. Netac 朗科 A1 32GB 存储卡 4.31411 s, 38.0 MB/s 2.00759 s, 81.6 MB/s 7. BanQ JOY card 白金 64G 存储卡 9.08105 s, 18.0 MB/s 9.02843 s, 18.1 MB/s 8. 海康威视 HS TF P2 64G 存储卡 2.28079 s, 71.8 MB/s 1.87698 s, 87.3 MB/s 下面为没有拍照但是测速过的卡： 序号 型号 <p style \"white space:nowrap\">写入速度（写入量 160MB）</p> <p style \"white space:nowrap\">读取速度（读取量 160MB） </p> 1. 雷克沙（Lexar）64GB TF（MicroSD）存储卡 C10 U3 V30 A2 2.59644 s, 63.1 MB/s 1.9106 s, 85.8 MB/s 2. 雷克沙（Lexar）128GB TF（MicroSD）存储卡 C10 U3 V30 6.73793 s, 24.3 MB/s 6.94079 s, 23.6 MB/s ### 烧录 Linux 系统 ![axpi flash](./../assets/axpi flash.png) 因为开发板上的 EMMC 仅默认预留焊盘，所以需要从 TF 卡启动 Linux Debian 系统。 #### 如何获取镜像？ 因为镜像文件比较大，因此仅提供百度云下载链接。 前往百度云[点击进入下载页面](https://pan.baidu.com/s/1 UtDoAVP6spwqjHP2wneJA)，输入提取码 `sdls` 即可下载文件，镜像包与校验文件都已经放在里面了。 ![debian](./../assets/debian.jpg) 其中拓展名为 `img.xz` 的是压缩文件，我们就是需要烧录这个文件，拓展名是 `img.xz.md5sum` 的是校验文件，可以用来校压缩文件的完整性。 镜像压缩文件命名的组成为：`镜像提供方` _ `适用芯片` _ `Linux 发行版` _ `镜像时间` + `img.xz` 校验文件需要在 Linux 环境中使用，windows10 及以上的用户可以使用 wsl 来提供 Linux 环境 使用命令为在镜像文件和校验文件共同存在的目录使用 `md5sum c *.md5sum*`，就可以来查看完整性了。 校验成功 校验失败 ![md5sum_success](./../assets/flash_system/md5sum_success.jpg) ![md5sum_failed](./../assets/flash_system/md5sum_failed.jpg) 可以看到校验失败的话会消失 FAILED。当然通常不需要进行校验，这里只是给有需要的人提前预留一下。 #### 如何烧录镜像？ **烧录前我们需要进行以下准备：** 一张容量大于 8G 的 SD 卡；建议购买官方镜像卡，不然可能会因为 SD 卡质量差而带来糟糕的体验 一个读卡器：建议使用支持 USB3.0 的读卡器，不然会因为读卡器的速度过低会使烧录时间过长 [Etcher](https://www.balena.io/etcher/)软件：根据自身电脑下载对应版本的软件即可 **镜像系统烧录方法：** 首先运行 [Etcher](https://www.balena.io/etcher/ \"Etcher\") 软件，点击 `Flash from file` 选中已经下载好的 `img.xz` 文件镜像，然后点击 `Select target` 选中 SD 卡，最后点击 `Flash` 进行烧录等待完成即可。 **烧录镜像文件到 SD 卡：** ![burn_image_by_etcher](./../../../assets/maixIII/ax pi/burn_image_by_etcher.gif) 烧录中 烧录完成 ![axera_burning_image](./../../../assets/maixIII/ax pi/axera_burning_image.png) ![finish_flash](./../../maixII/M2A/assets/finish_flash.png) 需要注意的是在烧录完成后显示的应该是 `Flash Complete!`，并且显示的是 `Successful` 。 进行完上述操作后，电脑可能会提示需要格式化 U 盘，这个时候我们直接忽略这个提示（因为在 Etcher 软件里面已经烧录完成且 `Successful` 了），将内存卡取下，准备安装到板子上准备使用。 #### 烧录问题 ##### 1. 使用 Etcher 选择镜像的后出现错误 可以重新运行 Etcher 来解决该软件由于缓存等问题而造成的加载错误 ##### 2. 结束烧录后提示的是 Failed 重新一次烧录内存卡镜像 ##### 3. 格式化后内存卡可用容量很小 这种情况使用对于 Windows 和 MacOS 可以使用 [SD Card Formatter](https://www.sdcard.org/downloads/formatter/eula_windows/SDCardFormatterv5_WinEN.zip)来格式化 SD 卡，Linux 系统可以使用系统的 disk 工具或 [Gparted](https://gparted.org/)来格式化。 ### 启动 Linux 系统 完成上面的烧录镜像卡后，接着接可以组装板子了。 ![axpi connect](./../assets/axpi connect.png) #### 如何连接外设和配件？ > 购买全功能套餐的同学们跳过装配步骤[点击前往](#如何启动 AXera Pi ？)上电启动 AXera Pi 设备登录 Linux 系统即可。 **接线前我们需要进行准备工作：** 一块 AXera Pi 开发板 一个 USB3.0 （或者两个 USB2.0）的电脑接口来连接板子 一张已经烧录适用于 m3axpi 的系统镜像的 SD 卡 GC4653 Sensor 普通版摄像头 或者 OS04a10 Sensor 夜视版摄像头 配套的 5 寸 MIPI 屏 ![axpi config](./../assets/axpi config.jpg) **可参考以下示例避免误接：** 将屏幕**（排线反面朝上）**接入底板背面 LCD 接口，组装好后翻正板子在右侧的卡槽处插入烧录好的镜像卡。 <html> <img src \"./../assets/mipi.jpg\" width 48%> <img src \"./../assets/sensor.jpg\" width 48%> </html> **摄像头接线认准以下注意点：** >因物料更换摄像头现有两种版本，`V3753` 版本的摄像头接线座子以及线序进行了更改，**如若接反后上电的话底板的 LED 灯会不亮，接反时间久会导致烧坏板卡或摄像头，请根据以下注意点正确接入摄像头。** 进行接线前确保摄像头底部的小人与板子丝印同向再进行接线，如下图所示。 ![sensor_oldnew](./../assets/sensor_oldnew.jpg) 接线时确保底板接口座子与摄像头座子的线序 **`1`** 在同一侧，认准排线正面蓝色线序接入即可。 <html> <img src \"./../assets/senror_v3751.jpg\" width 48%> <img src \"./../assets/sensor_v3753.jpg\" width 48%> </html> #### 如何启动 AXera Pi ？ >因物料更换屏幕现有不同的版本，需区别版本以及使用屏幕时出现锯齿等画面请移步到[ Maix III 系列 AXera Pi 常见问题(FAQ) ](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html#Q：硬件物料更改说明、没有 wlan0 、屏幕烧屏、摄像头倒过来怎么解决？)查询。 如果 PC 支持 USB3.0 * 用 type c 接入 `USB UART`，串口方式登录开发板 * 或者接 `USB OTG`， ssh 方式登录开发板 如果 PC 只支持 USB2.0 * 需要两个 USB2.0 端口、两根 type c，同时连接 `USB UART` 和 `USB OTG` ，否则电流不足无法开机 ![start](./../assets/start.jpg) > 在 **20221013** 后设备通电开机会从耳机播放音乐和点亮出厂的 5 寸屏幕，并在串口输出如下的 debian11 系统启动日志（截取部分日志如下）.[有些同学会遇到 Ubuntu22.04 CH340 系列串口驱动（没有 ttyUSB）问题，点此查看解决方案](https://blog.csdn.net/qq_27865227/article/details/125538516)。 .. details:: 点击查看 debian11 系统启动日志 ```bash Vddr init success! The system boot form EMMC enter boot normal mode U Boot 2020.04 (Jun 16 2022 00:16:34 +0800) Model: AXERA AX620_demo Board DRAM: 1 GiB NAND: unknown raw ID 77ee0178 uclass_get_device: Invalid bus 0 (err 524) 0 MiB initr_pinmux: delay pinmux_init for env board id MMC: enter sdhci_cdns_get_cd call mmc_getcd enter sdhci_cdns_get_cd call mmc_getcd mmc@10000000: 0, mmc@4950000: 1 Loading Environment from MMC... OK In: serial Out: serial Err: serial MMC: no card present sd card is not present enter normal boot mode Net: reset EMAC0: ethernet@0x4970000 ... Warning: ethernet@0x4970000 (eth0) using random MAC address 6a:e4:fd:58:97:ea eth0: ethernet@0x4970000 Hit any key to stop autoboot: 0 reading DTB and BOOT image ... reading bootimg header... MAGIC: AXERA! img size: 4841536 kernel_size: 4841472 kernel_addr: 64 id:bc 19 bb a7 2d 27 74 de 7c 91 4b 70 ea c9 ab 96 50 61 bd e0 2b 02 8b e5 c8 ee 22 ce df b1 cf ea load kernel image addr 0x40008000,load dtb image addr 0x48008000 boot cmd is :bootm 0x40008000 0x48008000 ## Booting kernel from Legacy Image at 40008000 ... Image Name: Linux 4.19.125 Image Type: ARM Linux Kernel Image (uncompressed) Data Size: 4839952 Bytes 4.6 MiB Load Address: 40008000 Entry Point: 40008000 Verifying Checksum ... OK ## Flattened Device Tree blob at 48008000 Booting using the fdt blob at 0x48008000 Loading Kernel Image Using Device Tree in place at 48008000, end 480103d6 Starting kernel ... Welcome to Debian GNU/Linux 11 (bullseye)! [ OK ] Created slice system getty.slice. [ OK ] Created slice system modprobe.slice. [ OK ] Created slice system serial\\x2dgetty.slice. [ OK ] Created slice User and Session Slice. [ OK ] Started Dispatch Password …ts to Console Directory Watch. [ OK ] Started Forward Password R…uests to Wall Directory Watch. [ OK ] Reached target Local Encrypted Volumes. [ OK ] Reached target Network is Online. ...... ``` ### 登录到板子里 > 当 **AXera Pi** 出现上述 logo 画面后代表开机成功，这时我们把板子当做一台 Linux 服务器来对待。 ![axpi login](./../assets/axpi login.png) 通过**「系统登录方式」**快速帮助用户了解如何登录到设备里的 Linux 系统，用户可以选择 `USB UART 串口` 或 `USB OTG SSH` 登录，可点击[**「系统使用手册 登录方式」**](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95)前往查看，以下文 USB OTG 口的 usb0 网卡（192.168.233.1）作为 ssh 登录的 ip 进入板子为例。 ```bash juwan@juwan n85 dls:~/sipeed_wiki$ sshpass p root ssh root@192.168.233.1 Linux AXERA 4.19.125 #53 SMP PREEMPT Tue Sep 13 13:16:27 HKT 2022 armv7l The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Wed Oct 12 16:43:43 2022 from 192.168.233.10 root@AXERA:~# screenfetch _,met$$$$$gg. root@AXERA ,g$$$$$$$$$$$$$$$P. OS: Debian ,g$$P\"\" \"\"\"Y$$.\". Kernel: armv7l Linux 4.19.125 ,$$P' `$$$. Uptime: 2d 3h 5m ',$$P ,ggs. `$$b: Packages: 785 `d$$' ,$P\"' . $$$ Shell: bash 5.1.4 $$P d$' , $$P Disk: 2.6G / 3.6G (77%) $$: $$. ,d$$' CPU: ARMv7 rev 5 (v7l) @ 4x 1.248GHz $$\\; Y$b._ _,d$P' RAM: 88MiB / 744MiB Y$$. `.`\"Y$$$$P\"' `$$b \" .__ `Y$$ `Y$$. `$$b. `Y$$b. `\"Y$b._ `\"\"\"\" root@AXERA:~# ax_clk AX620A: DDR: 3733 MHz CPU: 800 MHz BUS of VPU: 624 MHz BUS of NPU: 624 MHz BUS of ISP: 624 MHz BUS of CPU: 624 MHz NPU OTHER: 800 MHz NPU GLB: 24 MHz NPU FAB: 800 MHz NPU CORE1: 800 MHz NPU CORE0: 800 MHz ISP: 533 MHz MM: 594 MHz VPU: 624 MHz root@AXERA:~# ``` <! 由上文我们可以知道板子的基础信息，在 **20221202** 后更新的镜像包里已经开放了 1.22G 的用户空间。 > <! 我们可以跟着指南往下看学会把板子用起来！ > <! 我们可以知道板子的基础信息，目前默认是用 800Mhz 来跑，而且内存分配较保守能留给用户的空间内存不到 1GB，但不用担心，板子贴得内存最小都得是 2G 的，所以之后会通过更新内核开放更多内存给用户空间。 > ### 学会使用板子 ![axpi ai](./../assets/axpi ai.png) 由于默认没有配置桌面环境（只显示 logo），所以我们需要将 **AXera Pi** 连接一台电脑，通过终端管理软件（shell）与它进行命令行交互，这些可以在[「系统使用手册 验证外设」](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E9%AA%8C%E8%AF%81%E7%B3%BB%E7%BB%9F%E5%A4%96%E8%AE%BE)学会板上所有验证过的系统调频、外设、驱动、应用等资源的用法，像一些 Linux 操作基础、如何控制 I2C / UART / SPI 这些硬件设备的操作，还可以在[「系统使用手册 内置 AI 应用」](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E9%AA%8C%E8%AF%81%E7%B3%BB%E7%BB%9F%E5%A4%96%E8%AE%BE)里调用内置的开箱 AI 应用及例程，快去用起来吧！ ![serial](./../assets/serial.jpg) ### 试试 Python 编程（适用初学者） 基于这篇上手指引的一路走下来的学习，相信小伙伴们也基本对 **AXera Pi** 基础使用以及验证外设有一定的掌握了，那我们就踏入编程的世界，一起来试试 Python 编程吧！ [试试 Python 编程](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/python_api.html) 我们内置了以 `jupyter notebook/ax pipline api/pinpong` 等 Python 包，你可以在**「试试 Python 编程」**里获得如何在 **AXera Pi** 上进入 Python 模式启动 `jupyter notebook` 并使用运行 AI 模型。 ![python_jy](./../assets/python_jy.jpg) 以及如何连接 **Arduino UNO** 以及 **Microbit** 进行 Python 编程的效果如下图。 <html> <img src \"./../assets/arduino.jpg\" width 48%> <img src \"./../assets/microbit.jpg\" width 48%> </html> ### 准备 C/C++ 编程（适用开发者） 能走到这里就说明板子已经用起来了，那就来开发吧！在这之前需要**「准备 C/C++ 编程」**了解如何拷贝文件到板子里，如何搭建本地编译或交叉编译，然后学习到如何基于现有的代码进行开发。 [准备 C/C++ 编程](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/dev_prepare.html) 快速了解现在提供哪些开源代码仓库以及用法，这些开源仓库会持续更新和开放的。 ![axpi_sdk.jpg](./../assets/axpi_sdk.jpg) ### 训练模型部署 初学者训练模型可以从 [AI 开发指南](https://wiki.sipeed.com/ai/zh/deploy/ax pi.html) 学习如何训练一个最简单的模型到量化转换部署测试。 更专业更深入的调优需要了解 [Pulsar](https://pulsar docs.readthedocs.io/) ，这是由**「爱芯元智」**自主研发的 all in one 神经网络编译器，充分发挥片上异构计算单元(CPU+NPU)算力， Pulsar 工具链核心功能是将 .onnx 模型编译成芯片能解析并运行的 （.joint） 模型。 目前有以下几种部署方式（Pipeline）推荐： **libmaix**：并不在意程序的性能和效率，用最快的方式把摄像头图像输入 AI 模型后输出识别结果绘制到显示到屏幕上验证一下识别效果。 **ax pipeline**：没有多余的封装，直接操作芯片核心资源 vin \\ ivps \\ npu \\ vo 等硬解设备进行部署开发，可以使模型部署达到一个非常好的效果。 **IPCDemo**：以效果最好、性能最好、占用最少、稳定可靠、功能最多、确保最终能部署到用户的现场不出问题的框架代码来开发 AI 程序。 #### libmaix 部署 在板子上编译这个示例代码 [axpi_classification_cam](https://github.com/sipeed/libmaix/tree/release/examples/axpi_classification_cam)，然后放入模型运行后即可看到效果，截止 **20221013** 前代码还没有优化所以性能不高只够看个结果，想要效果和性能可以看 **ax pipeline** 部署。 <p align \"center\"> <img src \"./../assets/mobilenet_axpi.jpg\" alt \"img\" style \"zoom: 100%;\" /> </p> 即可验证效果：[详细可从 maixhub 上获取](https://maixhub.com/model/zoo/89)。 #### ax pipeline 部署 以上的部署方式都出于快速验证或应用落地的角度进行的，还有一套基于 **bsp sdk** 的 [ax pipeline](https://github.com/AXERA TECH/ax pipeline) 部署方式，它面向既了解 AI 又知道芯片底层 Linux 开发方法的同学，目前内置应用中提供了板子的 **rtsp** 和屏幕双推流 **yolov5** 实时识别以及新增 **yolov5s seg** 实例分割的程序就是来自于它。 ![rtsp display](./../assets/rtsp display.jpg) #### IPCDemo 部署 这是一个典型的 IPC 演示程序，源码在这里 [axpi_bsp_sdk IPCDemo](https://github.com/sipeed/axpi_bsp_sdk/tree/main/app/IPCDemo) ，其中 IPCDemo 的功能模块有： ISP：负责从 Sensor 获取图像 RAW 数据并转为 YUV，最终分 3 路通道输出以上信息。 IVPS：图像视频处理模块。实现对视频图形进行一分多、Resize、Crop、旋转等功能。 VENC / JENC：视频/JPEG 编码输出。 Detect：支持人脸或结构化检测。 Web 显示：实现 H264 流的 Web 传输和提供 Web 方式查看实时视频。 RTSP 推流：实现 H264 流的 RTSP 封装以及传输。 录像 TF 卡存储：封装 H264 流为 MP4 格式文件并保存至 TF 卡或者 FLASH 空间。 以下视频中的 IPCDemo 程序使用方法请点击<a href \"https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E5%86%85%E7%BD%AE%E5%BC%80%E7%AE%B1%E5%BA%94%E7%94%A8\" target \"blank\">内置开箱应用</a>查看。 <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 260625114&bvid BV1me411T7g8&cid 837160730&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\" style \"max width:640px; max height:480px;\"> </iframe> </p>"},"/hardware/zh/maixIII/ax-pi/sdk_usage.html":{"title":"Maix-III 系列 AXera-Pi 开发板 SDK 使用介绍","content":" title: Maix III 系列 AXera Pi 开发板 SDK 使用介绍 ## 获取 SDK 源码 上一篇介绍了基础的开发环境搭建和使用方法，你应该了解什么是本地编译和交叉编译，这一篇介绍如何使用这些 sdk 源码开发程序。 [libmaix](https://github.com/sipeed/libmaix) 由 sipeed 提供在 linux 平台统一的嵌入式开发环境，主要有摄像头、屏幕、视觉、图像处理、NPU pipiline 相关的实机部署例程，适合刚入门嵌入式 linux 开发的同学使用。 [ax sample](https://github.com/AXERA TECH/ax samples) 由爱芯提供 AI 模型的开发与评估验证，提供给有经验的 AI 开发者使用，不涉及任何硬件外设有关的内容。 [axpi_bsp_sdk](https://github.com/sipeed/axpi_bsp_sdk) 芯片商用时所用的 bsp 开发包，这里主要提供的是芯片的原始开发资料，如 uboot 、 linux 、 msp 、msp 等工程代码，这个部分是逐步开源的，你可以从这里得到商业评估用的代码，例如 ipcdemo 这样的程序，但这些代码会很复杂且高耦合，适合有经验的同行出于商业落地的目的使用。 [ax pipeline](https://github.com/AXERA TECH/ax pipeline) 基于 axpi_bsp_sdk 制作的 AI 部署高性能仓库，在这里主要用于该项目基于 AXera Pi 展示 ISP、图像处理、NPU、编码、显示 等功能模块软件调用方法，方便社区开发者进行快速评估和二次开发自己的多媒体应用。 ### libmaix 这是一个适用于 sipeed 所用 linux 芯片开发的 C/C++ 基础开发框架，使用 cmake 构建，提供了许多开箱参考的案例，还有一些第三方库代码的链接，如 opencv openmv 这些视觉库的链接。 SDK 源码在 [libmaix](https://github.com/sipeed/libmaix)， 需要使用 git 命令下载： ```bash git clone https://github.com/sipeed/libmaix.git recursive ``` >! 注意这里` recursive` 参数是必须的，用来下载仓库里面的子模块，如果没有这个参数，代码会不完整，导致编译出错 > 中国国内可能下载速度较慢，可以多取消重试几次，可能会遇到速度快的节点，当然最好还是通过设置代理来加速下载。 另外， AI 模型及例程在 [MaixHub 模型库](https://maixhub.com/model/zoo) 可以找到， 以及 [AXERA TECH/ax samples](https://github.com/AXERA TECH/ax samples) 仓库。 ## 编译 SDK 源码 回顾一下前文的内容，编译有两种方式： * 直接在开发板上编译：编译速度较慢，但是不需要额外的环境配置。 * 在 PC 上编译，然后拷贝可执行文件到开发板，也就是交叉编译： 编译速度更快，但是需要额外的环境配置。 ### [libmaix](https://github.com/sipeed/libmaix) > /home/ 目录已预置，可以 git pull 联网拉取更新。 对于 `libmaix`， 按照其`README.md` 文件描述的方法编译即可， 不过需要在`menuconfig`命令中选择 `AXera Pi` 作为编译目标。 这里简要介绍一下编译过程（libmaix 目前还未稳定，未来可能会有大的更新），实际以[libmaix 仓库](https://github.com/sipeed/libmaix)代码和说明为准。 * 先安装依赖 ``` apt install build essential cmake python3 sshpass git ``` > sshpass 也可以不安装， build essential, cmake, git, python3 必须安装 * 克隆仓库到本地或者开发板 ``` git clone https://github.com/sipeed/libmaix recursive ``` >! 注意 ` recursive` 参数是必须的，用以克隆子模块，否则会缺代码 这里以在开发板上编译为例： ```bash cd /home/libmaix # git clone https://github.com/sipeed/libmaix recursive cd examples/axpi python3 project.py distclean # python3 project.py menuconfig # 可以配置相关参数 python3 project.py build # 如果增加文件了，需要 python3 project.py rebuild 命令 ./dist/start_app.sh # 运行示例程序 ``` ### [ax samples](https://github.com/AXERA TECH/ax samples) > /home/ 目录已预置，可以 git pull 联网拉取更新。 [ax samples](https://github.com/AXERA TECH/ax samples) 是爱芯官方提供的例程，包含了一些 AI 模型和运行代码，编译完能直接在开发板上运行，只不过输入是图片，不是摄像头。 进入开发板终端，执行以下代码： ```bash cd /home/ax samples # git clone https://github.com/AXERA TECH/ax samples.git mkdir build cd build cmake .. make install ``` 然后就能在`ax samples/build/install/bin/`目录下找到编译好的可执行文件。 ### [axpi_bsp_sdk](https://github.com/sipeed/axpi_bsp_sdk) 回到芯片原厂开发的环境，这需要有经验的嵌入式 Linux 开发者来操作，直接看 readme 进行操作，文档在 docs 目录下。 #### What is this? this is a ax620 linux bsp sdk form AX620_R1.22.2801_Sipeed. currently it is application layer open source. ```bash juwan@juwan n85 dls:~/GIT_AX620_SDK_V0.31.0_P23/sipeed/axpi_bsp_sdk$ tree L 1 . ├── app ├── build ├── msp ├── readme.md ├── rootfs └── third party 5 directories, 1 file ``` #### ready arm gcc ```bash git clone https://github.com/sipeed/axpi_bsp_sdk.git cd axpi_bsp_sdk wget http://releases.linaro.org/components/toolchain/binaries/latest 7/arm linux gnueabihf/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf.tar.xz sudo tar xvf gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf.tar.xz C /opt/ ``` #### how to compile bsp msp sample ```bash cd msp/sample/ export PATH \"/opt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/:$PATH\" && make p AX620_demo all install ``` third party libs ```bash cd third party export PATH \"/opt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/:$PATH\" && make p AX620_demo all install ``` bsp app ipcdemo ```bash cd app/ export PATH \"/opt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/:$PATH\" && make p AX620_demo all install ``` bsp msp component lib, such as `cd app/msp/component/common && make xxxx`. ``` juwan@juwan n85 dls:~/GIT_AX620_SDK_V0.31.0_P23/sipeed/axpi_bsp_sdk/msp/component$ tree L 1 . ├── axsyslog ├── common └── thermal 4 directories, 0 files ``` #### run your program on pc ``` sshpass p root scp ./vo_fb/sample_vo_fb root@192.168.233.1:/opt/bin/sample_vo_fb ``` on board ``` chmod 777 /opt/bin/sample_vo_fb /opt/bin/sample_vo_fb v dsi0@480x854@60 m 0 & fbv /home/examples/480x360.jpg killall sample_vo_fb ``` ## 组合 SDK 和 AI 模型例程 比如我们要跑一个视觉 AI 模型，需要用到摄像头，屏幕，还有 AI 模型，你需要借助以下仓库代码完成这个目标。 ### 借助 libmaix 实现（开发难度最小，适合验证） 基于 libmaix 的 axpi 项目进行开源快速验证效果，代码简单易懂，基于在线服务完成模型部署，只用于新手上路，与 ax sample 的模型一起被支持。 [axpi](https://github.com/sipeed/libmaix/tree/release/examples/axpi) [axpi_classification_cam](https://github.com/sipeed/libmaix/tree/release/examples/axpi_classification_cam) [axpi_yolov5_cam](https://github.com/sipeed/libmaix/tree/release/examples/axpi_yolov5_cam) > 20221113 目前仓库只保证用户初次上手时能够不报错的安全调用 AI 模型，不代表芯片的最好效果。 ### 借助 ax pipeline 实现（开发难度适中，适合优化） 到了这里要有基本的芯片 bsp sdk 开发的基础（axpi_bsp_sdk），这部分会略显专业一些，这个仓库目前追求最高性能的效果。 [准备编译环境](https://github.com/AXERA TECH/ax pipeline/blob/main/docs/compile.md) [如何更换自己训练的 yolov5 模型？](https://github.com/AXERA TECH/ax pipeline/blob/main/docs/how_to_deploy_custom_yolov5_model.md) [如何部署自己的其他模型](https://github.com/AXERA TECH/ax pipeline/blob/main/docs/how_to_deploy_custom_model.md) ### 借助 ipcdemo 实现（开发难度最大，适合落地） 基于 axpi_bsp_sdk 的 ipcdemo 商用视频推流应用，由于源码过于复杂，需要有上述基础才能介入。 [axpi_bsp_sdk/app/IPCDemo](https://github.com/sipeed/axpi_bsp_sdk/tree/main/app/IPCDemo)"}}